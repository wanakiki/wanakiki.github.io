<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wanakiki`s Blog on Wanakiki`s Blog</title>
    <link>https://wanakiki.github.io/</link>
    <description>Recent content in Wanakiki`s Blog on Wanakiki`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 07 May 2019 23:55:50 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>数据结构作业六 旅行商（TSP）</title>
      <link>https://wanakiki.github.io/2019/tsp/</link>
      <pubDate>Tue, 07 May 2019 23:55:50 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/tsp/</guid>
      <description>

&lt;p&gt;图论第一次作业，不需要提交报告，在OJ上提交。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;描述&#34;&gt;描述&lt;/h2&gt;

&lt;p&gt;Shrek是一个大山里的邮递员，每天负责给所在地区的n个村庄派发信件。但杯具的是，由于道路狭窄，年久失修，村庄间的道路都只能单向通过，甚至有些村庄无法从任意一个村庄到达。这样我们只能希望尽可能多的村庄可以收到投递的信件。&lt;/p&gt;

&lt;p&gt;Shrek希望知道如何选定一个村庄A作为起点（我们将他空投到该村庄），依次经过尽可能多的村庄，路途中的每个村庄都经过仅一次，最终到达终点村庄B，完成整个送信过程。这个任务交给你来完成。&lt;/p&gt;

&lt;h3 id=&#34;输入&#34;&gt;输入&lt;/h3&gt;

&lt;p&gt;第一行包括两个整数n，m，分别表示村庄的个数以及可以通行的道路的数目。&lt;/p&gt;

&lt;p&gt;以下共m行，每行用两个整数v1和v2表示一条道路，两个整数分别为道路连接的村庄号，道路的方向为从v1至v2，n个村庄编号为[1, n]。&lt;/p&gt;

&lt;p&gt;1 ≤ n ≤ 1,000,000&lt;/p&gt;

&lt;p&gt;0 ≤ m ≤ 1,000,000&lt;/p&gt;

&lt;p&gt;输入保证道路之间没有形成环&lt;/p&gt;

&lt;h3 id=&#34;输出&#34;&gt;输出&lt;/h3&gt;

&lt;p&gt;输出一个数字，表示符合条件的最长道路经过的村庄数。&lt;/p&gt;

&lt;h3 id=&#34;输入样例-1&#34;&gt;输入样例 1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;4 3
1 4
2 4
4 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;输出样例-1&#34;&gt;输出样例 1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;

&lt;p&gt;先进性拓扑排序，之后dp找到最大值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;
#define myMax(x,y) ((x) &amp;gt; (y) ? (x) : (y))
int inDeg[1000005] = {0};   //入度 用于拓扑排序
int tpSorted[1000005] = {0};    //拓扑排序的顺序

//单个村庄
struct village{
    int id;
    village * next_village;
    village(int _id, village* next = NULL):id(_id),next_village(next){}
};

struct villages{
    village* _next;
    int dp; //直接写入属性
    villages():_next(NULL), dp(1){}
    void add(int next_id);
}Villages[1000005];

void villages::add(int next_id){
    inDeg[next_id] ++;
    if(!_next){
        _next = new village(next_id);
    }
    else{
        _next = new village(next_id, _next);
    }
}

//全局变量真好用...
int topologicalSort(int n){
    int res = 0;    //记录最大值
    int size = 0;   //拓扑数组长度
    for(int i = 1; i &amp;lt;= n; i++)
        if(!inDeg[i])
            tpSorted[size++] = i;
    
    //对数组进行操作
    for(int i = 0; i &amp;lt; size; i++){
        village* cur = Villages[tpSorted[i]]._next;
        while(cur){
            Villages[cur-&amp;gt;id].dp = myMax(Villages[tpSorted[i]].dp+1, Villages[cur-&amp;gt;id].dp);
            res = myMax(Villages[cur-&amp;gt;id].dp, res);

            inDeg[cur-&amp;gt;id]--;
            if(!inDeg[cur-&amp;gt;id])
                tpSorted[size++] = cur-&amp;gt;id;
            cur = cur-&amp;gt;next_village;
        }
    }
    return res;
}
int main(){
    int n, m, v1, v2;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while(m--){
        cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;
        Villages[v1].add(v2);        
    }
    cout &amp;lt;&amp;lt; topologicalSort(n) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业四 表达式树</title>
      <link>https://wanakiki.github.io/2019/bin-tree/</link>
      <pubDate>Fri, 03 May 2019 18:56:50 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/bin-tree/</guid>
      <description>

&lt;p&gt;从中缀表达式构建二叉树
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190146.jpg&#34; alt=&#34;题目要求&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;问题分析-解决方案&#34;&gt;问题分析 &amp;amp; 解决方案&lt;/h2&gt;

&lt;p&gt;题目要求输入一个中缀表达式，构建其相应的表达式树，并输出验证。&lt;/p&gt;

&lt;p&gt;表达式树的特点是操作符所对应的两个操作数分别对应于操作符的左孩子和右孩子。直接从中缀表达式构建相对困难，考虑此前已经有过从中缀表达式构建后缀表达式的经验，以及后缀表达式运算符位于操作数之后的特点，可以从后缀表达式入手解决该问题。&lt;/p&gt;

&lt;p&gt;通过对表达式树和后缀表达式的观察不难得出可以通过以下方法从后缀表达式得到表达式树：后缀表达式自后向前遍历，在右节点优先级高于左节点的前提下根据当前遍历元素类型进行以下两种操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当前元素为运算符，将运算符构建为树的一个节点，若为右孩子则将操作节点压栈。无论是左孩子还是右孩子，之后操作节点转移到新建节点。&lt;/li&gt;
&lt;li&gt;当前元素为操作数，将运算符构建为树的一个节点，若为左孩子则操作节点转移到栈顶节点，栈弹出。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最终解决方案为：将输入的中缀表达式转化为后缀表达式，再按照上述规则构建整个表达式树。同时还要注意最终树形的输出。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;参照课本，构建节点类、二叉树类，并对其中的相关函数进行实现，另外准备一个函数将中缀表达式构建为后缀表达式，并进行树的构建。&lt;/p&gt;

&lt;p&gt;课本中并没有节点深度这个属性，但终端输出时节点如果具有深度属性会非常方便，于是对其进行了补充，并添加了相关的函数对节点的深度进行更新，与高度更新一致调用。这里需要注意，高度的更新是自下向上，深度的更新则是自上而下，需要一个遍历的过程，我在具体实现的过程中采用了层遍历的方式。&lt;/p&gt;

&lt;h3 id=&#34;终端输出的思考&#34;&gt;终端输出的思考&lt;/h3&gt;

&lt;p&gt;如何在终端中输出是一个比较困难的问题。因为终端输出一行后不能回退到上一行，如果不对各个元素提前保存，就要在遍历的时候进行一些小操作。同时输出时空格的控制也需要细节处理。在这里简单介绍一下我的做法。&lt;/p&gt;

&lt;p&gt;我采用的方法是使用层遍历的方法，同时为每一个节点增加横坐标，遍历节点的同时更新节点的横坐标，根据横坐标和深度的情况判断是否需要换行和需要输出空格的数量。伴随着二叉树深度的增加，每层的节点呈指数级增长，如果一开始输出的节点之间的间隔控制的不好，后续的输出就会变得困难。&lt;/p&gt;

&lt;p&gt;高度为n的满二叉树，最底层有2^n个节点，考虑到底层节点不能直接相邻（至少隔一个空格），所以最底层所占字符总长为2^(n+1)个。现假设我们按照满二叉树的形式对整个树进行输出，输出区域为长为2^(n+1)个字符，高为n行的矩形，根节点位于整个图形的对称轴上，故根节点的横坐标为2^n，同理可推得根节点的左孩子的横坐标为2^(n-1)。考虑到在满二叉树的情况下每层节点之间的间隔是一定值，且为该层最左侧节点的横坐标，故在已知一个节点的横坐标及下一层的固定节点间隔的情况下，可以更新出该节点两个孩子的横坐标。&lt;/p&gt;

&lt;p&gt;按照上述方法在进行层遍历的同时对节点横坐标进行更新，记录上一个节点的横坐标，即使二叉树不是完全二叉树也能够正常输出形状。当然，因为终端的宽度一定，当层数大到最后一排无法显示的时候形状一定会发生改变。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190620.png&#34; alt=&#34;结构示意&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190145.jpg&#34; alt=&#34;中缀表达式变为逆波兰表达式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190144.jpg&#34; alt=&#34;从逆波兰表达式构建树&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;p&gt;共编写了三个文件：node.h、Bintree.h、main.cpp&lt;/p&gt;

&lt;p&gt;1.node.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define stature(p) ((p) ? (p)-&amp;gt;height : -1)

//节点指针的判断
#define IsLc(x) ((x)-&amp;gt;parent &amp;amp;&amp;amp; ((x) == (x)-&amp;gt;parent-&amp;gt;l_c))
#define IsRc(x) ((x)-&amp;gt;parent &amp;amp;&amp;amp; ((x) == (x)-&amp;gt;parent-&amp;gt;r_c))

#include &amp;lt;iostream&amp;gt;
using namespace std;
//NULL 在何处定义？

template &amp;lt;typename T&amp;gt;
struct node{
    T data;
    node&amp;lt;T&amp;gt;* parent;
    node&amp;lt;T&amp;gt;* l_c;
    node&amp;lt;T&amp;gt;* r_c;
    int height;
    int axis;  //打印时空格
    int depth;  //深度非常重要！
    
    //构造函数
    node():parent(NULL), l_c(NULL), r_c(NULL), height(0), axis(0), depth(0){}
    node(T e, node&amp;lt;T&amp;gt;* p=NULL, node&amp;lt;T&amp;gt;* lc=NULL, node&amp;lt;T&amp;gt;* rc = NULL, int h=0):data(e),parent(p),l_c(lc),r_c(rc),height(h),axis(0),depth(0){}

    node&amp;lt;T&amp;gt;* insertLc(T const&amp;amp;);
    node&amp;lt;T&amp;gt;* insertRc(T const&amp;amp;);
};

//两个插入的实现
template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* node&amp;lt;T&amp;gt;::insertLc(T const&amp;amp; e){
    return l_c = new node(e, this);
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* node&amp;lt;T&amp;gt;::insertRc(T const&amp;amp; e){
    return r_c = new node(e, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.bintree.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;node.h&amp;quot;
#include &amp;lt;queue&amp;gt;

template &amp;lt;typename T&amp;gt;
class Bintree{
    node&amp;lt;T&amp;gt;* _root;
    int _size;

public:
    //构造
    Bintree():_root(NULL),_size(0){}

    //更新高度、深度
    void updateHight(node&amp;lt;T&amp;gt; *x);
    void updateDepth(node&amp;lt;T&amp;gt;* x);
    void updateHD(node&amp;lt;T&amp;gt; *x);

    //节点插入e
    node&amp;lt;T&amp;gt;* insertAsRoot (T const&amp;amp; e);
    node&amp;lt;T&amp;gt;* insertAsLc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e);
    node&amp;lt;T&amp;gt;* insertAsRc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e); 

    //获得节点指针
    node&amp;lt;T&amp;gt;* getRoot();
    // node&amp;lt;T&amp;gt;* getLc(node&amp;lt;T&amp;gt;* x);
    // node&amp;lt;T&amp;gt;* getRc(node&amp;lt;T&amp;gt;* x);
    //上面这两个没有用了....

    //大小
    int size(){ return _size;}

    //表达
    void treeShow();

    // void createBlank(int n);
};



template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::updateHight(node&amp;lt;T&amp;gt;* x){
    x-&amp;gt;height = 1 + (stature(x-&amp;gt;l_c) &amp;gt; stature(x-&amp;gt;r_c) ? stature(x-&amp;gt;l_c) : stature(x-&amp;gt;r_c));
}

template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::updateDepth(node&amp;lt;T&amp;gt;* x){
    if(x == _root)  return;
    x-&amp;gt;depth = 1 + x-&amp;gt;parent-&amp;gt;depth;
    
}
template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::updateHD(node&amp;lt;T&amp;gt;* x){
    node&amp;lt;T&amp;gt;* y = x;
    while(x){
        updateHight(x);
        x = x-&amp;gt;parent;
    }
    queue&amp;lt; node&amp;lt;T&amp;gt;* &amp;gt; tmp;
    if(y){
        tmp.push(y);
        while(!tmp.empty()){
            updateDepth(tmp.front());
            if(tmp.front()-&amp;gt;l_c)
                tmp.push(tmp.front()-&amp;gt;l_c);
            if(tmp.front()-&amp;gt;r_c)
                tmp.push(tmp.front()-&amp;gt;r_c);
            tmp.pop();
        }
    }
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::insertAsRoot(T const&amp;amp; e){
    _size = 1;
    return _root = new node&amp;lt;T&amp;gt;(e);
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::insertAsLc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e){
    _size++;
    x-&amp;gt;insertLc(e);
    updateHD(x);
    return x-&amp;gt;l_c;
}   

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::insertAsRc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e){
    _size++;
    x-&amp;gt;insertRc(e);
    updateHD(x);
    return x-&amp;gt;r_c;
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::getRoot(){
    return _root;
}

template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::treeShow(){
    int num = 1;
    int  n = _root-&amp;gt;height;  //获得高度
    while(n--){ num *= 2;}

    //层遍历
    queue&amp;lt; node&amp;lt;T&amp;gt;* &amp;gt; tmp;
    node&amp;lt;T&amp;gt;* curr;
    int last_axis = 0, last_depth = 0;
    if(_root)
        tmp.push(_root);
    while(!tmp.empty()){
        // if(last != tmp.front()-&amp;gt;parent){
        //     num /=2;
        //     cout &amp;lt;&amp;lt; endl;
        //     for(int i = 0; i &amp;lt; num; i++)
        //         cout &amp;lt;&amp;lt; &#39; &#39;;
        // }
        // else
        //     for(int i = 0; i &amp;lt; 2*num-1; i++)
        //         cout &amp;lt;&amp;lt; &#39; &#39;;
        //改为从父亲那里得到横坐标

        //新的一层 改变num 同时last_axis清零  (通过比较深度)
        curr = tmp.front();
        if(last_depth != curr-&amp;gt;depth){
            num/=2;
            last_axis = 0;
            cout &amp;lt;&amp;lt; endl;
        }
            
        if(curr == _root)
            _root-&amp;gt;axis = num;
        else{
            if(IsLc(curr))
                curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis - num;
            else
                curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis + num; 
        }


        //输出空格 需要减一
        for(int i = 0; i &amp;lt; curr-&amp;gt;axis - last_axis - 1; i++) 
            cout &amp;lt;&amp;lt; &#39; &#39;;
        cout &amp;lt;&amp;lt; curr-&amp;gt;data;
        last_depth = curr-&amp;gt;depth;
        last_axis = curr-&amp;gt;axis;

        if(curr -&amp;gt; l_c)
            tmp.push(curr-&amp;gt;l_c);
        if(curr -&amp;gt; r_c)
            tmp.push(curr-&amp;gt;r_c);
        tmp.pop();
    }

    return ;
}

// template &amp;lt;typename T&amp;gt;
// void Bintree&amp;lt;T&amp;gt;::createBlank(int n){
//     while(n--)
//         cout &amp;lt;&amp;lt; &#39; &#39;;
//     return ;
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.main.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;bintree.h&amp;quot;
#include &amp;lt;string&amp;gt;
#include &amp;lt;stack&amp;gt;


//从中缀表达式构建
void create_from_infix(Bintree&amp;lt;char&amp;gt;&amp;amp; my_tree){
    string strs, res;
    stack&amp;lt;char&amp;gt; tmp;    //运算符
    
    cout &amp;lt;&amp;lt; &amp;quot;Input infix expression :&amp;quot; &amp;lt;&amp;lt; endl;
    cin &amp;gt;&amp;gt; strs;
    

    for(int i = 0; i &amp;lt; strs.size(); i++){
        if(strs[i] &amp;gt;= &#39;0&#39;)
            res += strs[i];
        else if(strs[i] == &#39;(&#39;)
            tmp.push(strs[i]);
        else if(strs[i] == &#39;)&#39;){
            while(tmp.top() != &#39;(&#39;){
                res += tmp.top();
                tmp.pop();
            }
            tmp.pop();  //清除多余的&#39;(&#39;
        }
        else if(strs[i] == &#39;+&#39; || strs[i] == &#39;-&#39;){
            while(!tmp.empty()){
                if(tmp.top() == &#39;(&#39;)
                    break;  //左括号额外注意
                res += tmp.top();
                tmp.pop();
            }
            tmp.push(strs[i]);     //当前操作的运算符入栈
        }
        else if(strs[i] == &#39;*&#39; || strs[i] == &#39;/&#39;){
            while(!tmp.empty()){
                if(tmp.top() == &#39;(&#39; || tmp.top()  == &#39;+&#39; || tmp.top()  == &#39;-&#39;)
                    break;  //不能全部输出
                res += tmp.top();
                tmp.pop();
            }
            tmp.push(strs[i]);     //入栈当前运算符
        }
    }

    //栈中多余运算符
    while(!tmp.empty()){
        res += tmp.top();
        tmp.pop();
    }

    cout &amp;lt;&amp;lt; &amp;quot;Postfix expression is :&amp;quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;

    //开始造树
    my_tree.insertAsRoot(res[res.size()-1]);
    node&amp;lt;char&amp;gt;* x = my_tree.getRoot();
    stack&amp;lt;node&amp;lt;char&amp;gt;*&amp;gt; nodes;
    nodes.push(x);  //防止最后一个操作数访问错误
    for(int i = res.size()-2; i &amp;gt;= 0; i--){
        if(res[i] &amp;gt;= &#39;0&#39;){
            //数字或者字母作为左孩子插入时需要向上返回
            if(x-&amp;gt;r_c){
                my_tree.insertAsLc(x, res[i]);
                x = nodes.top();
                nodes.pop();
            }
            else
                my_tree.insertAsRc(x, res[i]);
        }
        else{
            //字符一定会移动
            
            if(x-&amp;gt;r_c)
                x = my_tree.insertAsLc(x, res[i]);
            else{
                nodes.push(x);
                x = my_tree.insertAsRc(x, res[i]);
            }
        }
    }
}


int main(){
    Bintree&amp;lt;char&amp;gt; my_tree;
    create_from_infix(my_tree);
    cout &amp;lt;&amp;lt; &amp;quot;Tree is:&amp;quot;&amp;lt;&amp;lt;endl;
    my_tree.treeShow();
}

//封装的意义只是为了自动更新高度？删除更加方便？
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;qt图形化界面&#34;&gt;QT图形化界面&lt;/h2&gt;

&lt;p&gt;初次接触QT，花费了较多的时间来了解Qt的使用。对QpaintEvent理解的不是很透彻，实现的时候参考了网上的一些代码。程序使用了此前编写的二叉树类，中缀表达式转化为二叉树部分也与控制台程序一致。&lt;/p&gt;

&lt;h3 id=&#34;程序实现&#34;&gt;程序实现&lt;/h3&gt;

&lt;p&gt;Qt项目使用了此前编写的二叉树头文件，draw.cpp、main.cpp、draw.h实现如下：&lt;/p&gt;

&lt;p&gt;1.draw.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#ifndef DRAW_H
#define DRAW_H

#include &amp;lt;QMainWindow&amp;gt;
#include &amp;lt;QPaintEvent&amp;gt;
#include &amp;quot;bintree.h&amp;quot;

namespace Ui {
class draw;
}

class draw : public QMainWindow
{
    Q_OBJECT

public:
    Bintree&amp;lt;char&amp;gt; my_tree;
    QPaintEvent * tmp;
    explicit draw(QWidget *parent = nullptr);
    ~draw();
    void createTree();
    void paintEvent(QPaintEvent *);

private:
    Ui::draw *ui;
signals:

public slots:
//    void paintEvent(QPaintEvent *);
//    void createTree();
    //void showTree(bool checked);
    void createClicked();

};

#endif // DRAW_H
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.draw.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;draw.h&amp;quot;
#include &amp;quot;ui_draw.h&amp;quot;
#include &amp;lt;QPainter&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;QString&amp;gt;
#include &amp;lt;QtDebug&amp;gt;
#include &amp;lt;QChar&amp;gt;
#include &amp;lt;QtCore&amp;gt;

draw::draw(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::draw)
{

    ui-&amp;gt;setupUi(this);
    //this-&amp;gt;connect(ui-&amp;gt;pushButton, SIGNAL(clicked(bool)), this, SLOT(createTree()));
    this-&amp;gt;connect(ui-&amp;gt;huizhi, SIGNAL(clicked(bool)), this, SLOT(createClicked()));
}

draw::~draw()
{
    delete ui;
}

void draw::createClicked(){
    createTree();
    paintEvent(tmp);
    update();

}
void draw::paintEvent(QPaintEvent *)
{
    QPainter painter(this);
    node&amp;lt;char&amp;gt;* x = my_tree.getRoot();
    node&amp;lt;char&amp;gt;* curr;
    if(x){
        //层遍历第一遍
        int last_axis = 0, last_depth = 0;
        int num = 1, n = x-&amp;gt;height;
        while(n--)  num *= 2;

        queue&amp;lt;node&amp;lt;char&amp;gt;* &amp;gt; tmp;

        //画线
        tmp.push(x);
        while(!tmp.empty()){
            curr = tmp.front();
            if(last_depth != curr-&amp;gt;depth){
                        num/=2;
                        last_axis = 0;
             }
            if(curr == x)
                        curr-&amp;gt;axis = num;
             else{
                        if(IsLc(curr))
                            curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis - num;
                        else
                            curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis + num;
             }

            last_depth = curr-&amp;gt;depth;
            last_axis = curr-&amp;gt;axis;
            if(curr-&amp;gt;l_c)
                tmp.push(curr-&amp;gt;l_c);
            if(curr-&amp;gt;r_c)
                tmp.push(curr-&amp;gt;r_c);
            tmp.pop();

            if(x == curr)
                continue;   //根节点不用画线
            painter.drawLine(30*curr-&amp;gt;axis+30, 130+100*curr-&amp;gt;depth, 30*curr-&amp;gt;parent-&amp;gt;axis+30, 130+100*curr-&amp;gt;parent-&amp;gt;depth);

       }

        //层遍历第二遍 画节点
        tmp.push(x);
        while(!tmp.empty()){
            curr = tmp.front();
            painter.setBrush(Qt::green);
            painter.drawEllipse(30*curr-&amp;gt;axis, 100+100*curr-&amp;gt;depth,60,60);
            painter.drawText(30*curr-&amp;gt;axis+25, 100*curr-&amp;gt;depth+135, QChar(curr-&amp;gt;data));
            qDebug()&amp;lt;&amp;lt;QChar(curr-&amp;gt;data)&amp;lt;&amp;lt;endl;

            if(curr-&amp;gt;l_c)
                tmp.push(curr-&amp;gt;l_c);
            if(curr-&amp;gt;r_c)
                tmp.push(curr-&amp;gt;r_c);
            tmp.pop();
        }
    }
}

void draw::createTree()
{
    //QString str = ui-&amp;gt;line-&amp;gt;toPlainText().toStdString().data();    //我佛了
      QString str = ui-&amp;gt;line-&amp;gt;text();
//    QString res;
    std::string res;
    std::string strs = str.toStdString();
    stack&amp;lt;char&amp;gt; tmp;

    for(int i = 0; i &amp;lt; strs.size(); i++){
            if(strs[i] &amp;gt;= &#39;0&#39;)
                res += strs[i];
            else if(strs[i] == &#39;(&#39;)
                tmp.push( strs[i]);
            else if(strs[i] == &#39;)&#39;){
                while(tmp.top() != &#39;(&#39;){
                    res += tmp.top();
                    tmp.pop();
                }
                tmp.pop();  //清除多余的&#39;(&#39;
            }
            else if(strs[i] == &#39;+&#39; || strs[i] == &#39;-&#39;){
                while(!tmp.empty()){
                    if(tmp.top() == &#39;(&#39;)
                        break;  //左括号额外注意
                    res += tmp.top();
                    tmp.pop();
                }
                tmp.push(strs[i]);     //当前操作的运算符入栈
            }
            else if(strs[i] == &#39;*&#39; || strs[i] == &#39;/&#39;){
                while(!tmp.empty()){
                    if(tmp.top() == &#39;(&#39; || tmp.top()  == &#39;+&#39; || tmp.top()  == &#39;-&#39;)
                        break;  //不能全部输出
                    res += tmp.top();
                    tmp.pop();
                }
                tmp.push(strs[i]);     //入栈当前运算符
            }
        }

        //栈中多余运算符
        while(!tmp.empty()){
            res += tmp.top();
            tmp.pop();
        }

        //开始造树
        my_tree.insertAsRoot(res[res.size()-1]);
            node&amp;lt;char&amp;gt;* x = my_tree.getRoot();
            stack&amp;lt;node&amp;lt;char&amp;gt;*&amp;gt; nodes;
            nodes.push(x);
            for(int i = res.size()-2; i &amp;gt;= 0; i--){
                if(res[i] &amp;gt;= &#39;0&#39;){
                    //数字或者字母作为左孩子插入时需要向上返回
                    if(x-&amp;gt;r_c){
                        my_tree.insertAsLc(x, res[i]);
                        x = nodes.top();
                        nodes.pop();
                    }
                    else
                        my_tree.insertAsRc(x, res[i]);
                }
                else{
                    //字符一定会移动

                    if(x-&amp;gt;r_c)
                        x = my_tree.insertAsLc(x, res[i]);
                    else{
                        nodes.push(x);
                        x = my_tree.insertAsRc(x, res[i]);
                    }
                }
            }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.main.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;draw.h&amp;quot;
#include &amp;lt;QApplication&amp;gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    draw w;
    w.show();

    return a.exec();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行效果&#34;&gt;运行效果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190211.jpg&#34; alt=&#34;样例&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190213.jpg&#34; alt=&#34;非对称树&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190212.jpg&#34; alt=&#34;一般情况&#34; /&gt;&lt;/p&gt;

&lt;p&gt;两个参考链接：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.itread01.com/content/1541521344.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.itread01.com/content/1541521344.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.yalewoo.com/2016/01/14/binary_tree_graphical_display/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.yalewoo.com/2016/01/14/binary_tree_graphical_display/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;p&gt;这次作业因为事先没有考虑到横坐标的问题，遍历更新横坐标的代码写了两遍，其实这个部分完全可以作为一个成员函数写在类中，不过当我发现这个问题的时候第二遍已经写了一半多了，所以就没有改。大部分时间都去研究Qt了，所以构建树的部分可能会有漏洞。由于时间紧迫Qt程序就没有多做细节处理，另外报告撰写的质量也较低。&lt;/p&gt;

&lt;p&gt;Qt程序不是生成图片，而是调用画笔，所以当深度过大之后会有很大部分看不到，而且经某人测试，层数达到十几层之后程序会直接bug，具体是那个地方越界还没有时间判断。现在有一个无限画布的想法但是还没有尝试去实现。总之收获还是蛮大的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有时候先画出来流程图简化过程之后再写代码效率会更高。&lt;/li&gt;
&lt;li&gt;面对新领域而又不需要实现特别困难的功能时：犹豫，就会败北，头铁，就会白给。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业五 Compression</title>
      <link>https://wanakiki.github.io/2019/compression/</link>
      <pubDate>Fri, 03 May 2019 14:00:51 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/compression/</guid>
      <description>

&lt;p&gt;图片有损压缩大作业&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;问题分析-解决方案&#34;&gt;问题分析 &amp;amp; 解决方案&lt;/h2&gt;

&lt;p&gt;本次编程任务给出了一个纯英文的PDF文件，较为详细地介绍了图像有损压缩算法的实现方式，通过二叉树的树剪枝达到保留图片细节的目的。任务要求达到的效果如下图所示，可以看出较为复杂的图腾部分得到了很好的保留，而树叶和远处的背景则被明显地压缩成了像素区块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134525.jpg&#34; alt=&#34;示例&#34; /&gt;&lt;/p&gt;

&lt;p&gt;和编程任务一同给出的源码包中已经实现了绝大部分代码，我们需要按照给出的方法对缺失的代码进行补充，从这方面来讲，整个编程任务相当于一个稍微复杂的程序填空题。另外不得不提的一点是，所给的源码格式较为规范，仔细研究代码的整体框架对日后的编程也有一定的好处，也正因其规范性，代码整体阅读难度较低。&lt;/p&gt;

&lt;p&gt;总体来看，整个工程由五个部分组成，其从属关系为：PNG类包含RGBAPixel类，并且通过loadpng中的函数对图片进行最底层的读写。twoDtree通过一个PNG类进行构建，stats在构建的过程中起到辅助作用，加快整个构建过程。程序的宏观框架大致如此，stats中的所有函数都要我们对其进行具体实现，twoDtree中的大部分关键代码都要我们对其进行补充，而其余的三个文件在了解了类的定义方式及大致的成员函数的用法之后便可不必深究。&lt;/p&gt;

&lt;p&gt;不难看出，任务只要求对twoDtree和stats两个部分进行补充，刚好将整个任务分为两个部分，由于twoDtree对stats有一定依赖性，首先处理stats的部分。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;此前已经叙述清楚，任务可以被分为两个部分，接下来对两个部分算法的设计进行说明。&lt;/p&gt;

&lt;h3 id=&#34;stats类函数的实现&#34;&gt;stats类函数的实现&lt;/h3&gt;

&lt;p&gt;从任务说明中可以了解到，stats类是通过对图片各个通道的像素值进行预计算，使生成二叉树时每种分割情况下计算variability measurement 的复杂度降到常数时间，并能够返回指定小矩阵的多种信息。其中最大的难点便是如何进行预计算使下面的公式降低到常数时间。这里，为了计算方便我们使用等式右边的公式。&lt;/p&gt;

&lt;p&gt;$$\sum(x-\bar x)^{2}=\sum x^{2}-\frac{(\sum x)^{2}}{\left| R \right|}$$&lt;/p&gt;

&lt;p&gt;结合stats中已经定义的六个二维矩阵不难想到对整个图片各个通道的颜色值及其平方进行累加，如果我们采用当前点的值等于位于该点上方和左侧的两个值及自身三个值累加的方式对整个图片进行递推计算的话，算到最终结果之后会发现很难对这个生成的二维向量进行高效的利用，因为多次累了重复值，起初不明显，等到面积增大之后就会变成很难处理的问题。&lt;/p&gt;

&lt;p&gt;稍加思考（hhh，花了将近一个小时）之后我们得到了另外的一种方法，既然我们之前的问题是每计算一个点的值都会导致之前的值被重复计算，为了解决它，我们在计算的时候直接减去会被重复计算的点，这样，最终生成的二维向量中的每个值都等于以原点和当前点确定的矩形中的所有点的累加。&lt;/p&gt;

&lt;p&gt;具体实现为：在计算一个点的值的时候，除了加上其上方和左侧的两个点，还要减去左上方的点，按照这个规则进行递推计算，最终的结果就是我们想要的情况。&lt;/p&gt;

&lt;p&gt;对于生成矩阵的利用我们用图形进行解释：如图所示，我们已经得到了我们所需的累加和矩阵，矩阵中的每个点的值都等于该点与原点确定的矩形中所有点的累加和。现在我们想要计算出图中绿色矩形所对应的累加和。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/compression/20190503135249.png&#34; alt=&#34;示例图&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;直观来看，sum = 整体 - 蓝色 - 橙色 - 红色
已知: 整体 = D, 蓝色 = B - A，橙色 = C - A，红色 = A
则不难推出，sum = D - B - C + A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照上述公式我们便可以在常数时间内计算出任何子矩阵对应的累加和。为了方便后续的计算，我在处理矩阵的时候多开辟了额外的空间并存上零，简化了代码。&lt;/p&gt;

&lt;h3 id=&#34;twodtree的探索&#34;&gt;twoDtree的探索&lt;/h3&gt;

&lt;p&gt;twoDtree中主要让我们实现的功能有两个，建树和剪枝，至于从树还原到图片和树的基础操作函数是相对基本的内容，通过课上的学习以及对程序框架的理解应该可以很轻松地写出来，在这里不浪费笔墨一个个进行阐述。&lt;/p&gt;

&lt;h4 id=&#34;建树函数buildtree&#34;&gt;建树函数buildTree&lt;/h4&gt;

&lt;p&gt;通过对程序的阅读我们可以了解到，二叉树是从图片构建来的，而buildTree便是构造树的关键函数，我们可以把树的一般初始化先在构造函数内写出来，提前准备好该函数需要的参数，之后在构造函数中对其进行调用，生成整个树的框架。&lt;/p&gt;

&lt;p&gt;首先审视一下作业PDF中对树的构造方法的解释，我理解的方法是：父节点对应于一个大矩形，如果这个大矩形内有大于两个的像素值，我们就要对它进行分割，划为两个矩形，使两个子矩阵的色彩多样性（我反正这么叫）之和达到最小，这两个矩形就分别对应于左右孩子，这里需要注意左右孩子的顺序。这个过程需要一直执行下去，直到图片中的每个像素都对应于树的叶子节点。&lt;strong&gt;需要注意，由于我们不是对称切分，所以最终生成的树并不会是理想结构，我们只能保证的一点是，这个树是一个真二叉树。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这样我们要做的事情就很清楚了，无非就是从根节点开始这个过程，每到一个节点都假设一条虚拟的线，对这个矩形进行切割，分别计算两个矩形的色彩多样性之和，考虑完所有的横纵情况后选择最好的那种。按着这条线切割后继续进行这个过程，直到分为单个像素点。关于如何在常数时间内计算出一个矩形的色彩多样性，我们在stats相关内容中已经进行了说明。&lt;/p&gt;

&lt;h4 id=&#34;剪枝函数prune&#34;&gt;剪枝函数prune&lt;/h4&gt;

&lt;p&gt;在我看来，这个函数是整个问题最难的点，因为我想不到一个高效的算法只遍历一遍叶子节点。&lt;/p&gt;

&lt;p&gt;如何剪枝？一个子树的根节点像素值便是这个子树对应矩形所有像素值的平均，我们要做的事情是计算出这个矩形中和各通道色值与平均值差的平方的和小于等于tolerance的个数，然后计算这一部分像素占像素总个数的比例，如果大于给定值，就代表这个矩形中像素之间的差异不大，我们就可以将这个子树的枝叶剪掉，只留下根节点。反映到图形上来，就是将这个矩形的颜色涂成了平均值。&lt;/p&gt;

&lt;p&gt;最终的实现方法很简单，先进行层序遍历，对遍历到的每个节点再进行一次遍历，统计满足条件叶子的个数，最后计算比例，判断是否需要删除。但是这个程序中有这么一句话，让我以为有超级简单的算法可以实现这个过程。但是很不幸，最终还是没有找到。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pruning criteria should be evaluated on the original tree, not on a pruned subtree. (we only expect that trees would be pruned once.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134502.png&#34; alt=&#34;stats&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134518.png&#34; alt=&#34;建树&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;p&gt;stats.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;stats.h&amp;quot;
using namespace std;
using namespace cs221util;

stats::stats(PNG &amp;amp;im){
    //resize
    unsigned width = im.width();
    unsigned height = im.height();
    sumRed.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumGreen.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumBlue.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumsqRed.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumsqGreen.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumsqBlue.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));

    RGBAPixel *tmp ;
    // sumRed[0][0] = int(tmp-&amp;gt;r);
    // sumGreen[0][0] = int(tmp-&amp;gt;g);
    // sumBlue[0][0] = int(tmp-&amp;gt;b);
    // sumsqRed[0][0] = int(tmp-&amp;gt;r)*int(tmp-&amp;gt;r);
    // sumsqBlue[0][0] = int(tmp-&amp;gt;b)*int(tmp-&amp;gt;b);
    // sumsqGreen[0][0] = int(tmp-&amp;gt;g)*int(tmp-&amp;gt;g);

    // for(int i = 1; i &amp;lt; im.width; i++){
    //     tmp = im.getPixel(i,0);    
    //     sumRed[i][0] = int(tmp-&amp;gt;r);
    //     sumGreen[i][0] = int(tmp-&amp;gt;g);
    //     sumBlue[i][0] = int(tmp-&amp;gt;b);
    //     sumsqRed[i][0] = int(tmp-&amp;gt;r)*int(tmp-&amp;gt;r);
    //     sumsqBlue[i][0] = int(tmp-&amp;gt;b)*int(tmp-&amp;gt;b);
    //     sumsqGreen[i][0] = int(tmp-&amp;gt;g)*int(tmp-&amp;gt;g);
    // }
    // for(int i = 1; i &amp;lt; im.height; i++){
    //     tmp = im.getPixel(0, i);
    //     sumRed[0][i] = int(tmp-&amp;gt;r);
    //     sumGreen[0][i] = int(tmp-&amp;gt;g);
    //     sumBlue[0][i] = int(tmp-&amp;gt;b);
    //     sumsqRed[0][i] = int(tmp-&amp;gt;r)*int(tmp-&amp;gt;r);
    //     sumsqBlue[0][i] = int(tmp-&amp;gt;b)*int(tmp-&amp;gt;b);
    //     sumsqGreen[0][i] = int(tmp-&amp;gt;g)*int(tmp-&amp;gt;g);
    // }

    for(unsigned int i = 1; i &amp;lt;= width; i++)
    for(unsigned int j = 1; j &amp;lt;= height; j++){
        tmp = im.getPixel(i-1, j-1);
        sumRed[i][j] = (int)(tmp-&amp;gt;r) + sumRed[i-1][j] + sumRed[i][j-1] - sumRed[i-1][j-1];
        sumGreen[i][j] = (int)(tmp-&amp;gt;g) + sumGreen[i-1][j] + sumGreen[i][j-1] - sumGreen[i-1][j-1];
        sumBlue[i][j] = (int)(tmp-&amp;gt;b) + sumBlue[i-1][j] + sumBlue[i][j-1] - sumBlue[i-1][j-1];
        sumsqRed[i][j] = (int)(tmp-&amp;gt;r)*(int)(tmp-&amp;gt;r) + sumsqRed[i-1][j] + sumsqRed[i][j-1] - sumsqRed[i-1][j-1];
        sumsqBlue[i][j] = (int)(tmp-&amp;gt;b)*(int)(tmp-&amp;gt;b) + sumsqBlue[i-1][j] + sumsqBlue[i][j-1] - sumsqBlue[i-1][j-1];
        sumsqGreen[i][j] = (int)(tmp-&amp;gt;g)*(int)(tmp-&amp;gt;g) + sumsqGreen[i-1][j] + sumsqGreen[i][j-1] - sumsqGreen[i-1][j-1];
    }
    //没有必要强转为int...
}

long stats::getSum(char channel, pair&amp;lt;int, int&amp;gt; ul, pair&amp;lt;int, int&amp;gt; lr){
    long ans = 0;
    switch (channel)
    {
    case &#39;r&#39;:
        /* code */
        ans = sumRed[lr.first+1][lr.second+1];
        ans -= sumRed[ul.first][lr.second+1];
        ans -= sumRed[lr.first+1][ul.second];
        ans += sumRed[ul.first][ul.second];
        break;
    case &#39;g&#39;:
        ans = sumGreen[lr.first+1][lr.second+1];
        ans -= sumGreen[ul.first][lr.second+1];
        ans -= sumGreen[lr.first+1][ul.second];
        ans += sumGreen[ul.first][ul.second];
        break;
    case &#39;b&#39;:
        ans = sumBlue[lr.first+1][lr.second+1];
        ans -= sumBlue[ul.first][lr.second+1];
        ans -= sumBlue[lr.first+1][ul.second];
        ans += sumBlue[ul.first][ul.second];
        break;
    default:
        break;
    }
    return ans;
}

long stats::getSumSq(char channel, pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    long ans = 0;
    switch (channel)
    {
    case &#39;r&#39;:
        /* code */
        ans = sumsqRed[lr.first+1][lr.second+1];
        ans -= sumsqRed[ul.first][lr.second+1];
        ans -= sumsqRed[lr.first+1][ul.second];
        ans += sumsqRed[ul.first][ul.second];
        break;
    case &#39;g&#39;:
        ans = sumsqGreen[lr.first+1][lr.second+1];
        ans -= sumsqGreen[ul.first][lr.second+1];
        ans -= sumsqGreen[lr.first+1][ul.second];
        ans += sumsqGreen[ul.first][ul.second];
        break;
    case &#39;b&#39;:
        ans = sumsqBlue[lr.first+1][lr.second+1];
        ans -= sumsqBlue[ul.first][lr.second+1];
        ans -= sumsqBlue[lr.first+1][ul.second];
        ans += sumsqBlue[ul.first][ul.second];
        break;
    default:
        break;
    }
    return ans;
}

long stats::rectArea(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    return (lr.first-ul.first+1)*(lr.second-ul.second+1);
}

RGBAPixel stats::getAvg(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    long sum = rectArea(ul, lr);
    long sum_r, sum_g, sum_b;
    sum_r = getSum(&#39;r&#39;, ul, lr) / sum;
    sum_g = getSum(&#39;g&#39;, ul, lr) / sum;
    sum_b = getSum(&#39;b&#39;, ul, lr) / sum;
    return RGBAPixel(sum_r, sum_g, sum_b);
}

long stats::getScore(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    long sum = rectArea(ul, lr);
    long sum_r, sum_g, sum_b;
    long sumsq_r, sumsq_g, sumsq_b;
    sum_r = getSum(&#39;r&#39;, ul, lr);
    sum_g = getSum(&#39;g&#39;, ul, lr);
    sum_b = getSum(&#39;b&#39;, ul, lr);
    sumsq_r = getSumSq(&#39;r&#39;, ul, lr);
    sumsq_g = getSumSq(&#39;g&#39;, ul, lr);
    sumsq_b = getSumSq(&#39;b&#39;, ul, lr);

    //alpha置一？
    //是否考虑溢出？
    sum_r = sum_r * sum_r / sum;
    sum_g = sum_g * sum_g / sum;
    sum_b = sum_b * sum_b / sum;
    sumsq_r -= sum_r;
    sumsq_g -= sum_g;
    sumsq_b -= sum_b;
    return sumsq_r + sumsq_g + sumsq_b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;twoDtree.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
 *
 * twoDtree (pa3)
 * slight modification of a Kd tree of dimension 2.
 * twoDtree.cpp
 * This file will be used for grading.
 *
 */

#include &amp;quot;twoDtree.h&amp;quot;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;queue&amp;gt;

/* given */
twoDtree::Node::Node(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr, RGBAPixel a)
    :upLeft(ul),lowRight(lr),avg(a),left(NULL),right(NULL)
    {}

/* given */
twoDtree::~twoDtree(){
    clear();
}

/* given */
twoDtree::twoDtree(const twoDtree &amp;amp; other) {
    copy(other);
}

/* given */
twoDtree &amp;amp; twoDtree::operator=(const twoDtree &amp;amp; rhs){
    if (this != &amp;amp;rhs) {
        clear();
        copy(rhs);
    }
    return *this;
}

twoDtree::twoDtree(PNG &amp;amp; imIn){ 
    /* your code here */
    height = imIn.height();
    width = imIn.width();
    stats my_stat(imIn);
    pair&amp;lt;int, int&amp;gt; cur_ul, cur_lr;
    cur_ul = make_pair(0,0);
    cur_lr = make_pair(width-1, height-1);  
    //注意坐标从零开始
    
    root = buildTree(my_stat, cur_ul, cur_lr);
}

twoDtree::Node * twoDtree::buildTree(stats &amp;amp; s, pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr) {
    /* your code here */
    Node *cur = new Node(ul, lr, s.getAvg(ul, lr));

    //遍历所有情况
    //if(s.rectArea(ul,lr) &amp;gt; 1){    条件导致死循环
    if(ul != lr){
        bool flag = 1;  //1 means horizontal 0 means vertical
        int line = 0;
        long tmp;
        long Min = 9999999999;
        for(int i = ul.second; i &amp;lt; lr.second; i++){
            tmp = s.getScore(ul, pair&amp;lt;int,int&amp;gt; (lr.first, i)) + s.getScore(pair&amp;lt;int,int&amp;gt; (ul.first, i+1),lr);
            if(tmp &amp;lt; Min){
                Min = tmp;
                line = i;
            }
        }

        for(int i = ul.first; i &amp;lt; lr.first; i++){
            tmp = s.getScore(ul, pair&amp;lt;int,int&amp;gt; (i,lr.second)) + s.getScore(pair&amp;lt;int,int&amp;gt;(i+1, ul.second), lr);
            if((i == ul.first &amp;amp;&amp;amp; ul.second == ul.first) || tmp &amp;lt; Min){
                flag = 0;
                Min = tmp;
                line = i;
            }
        }
        
        if(flag){
            cur-&amp;gt;left = buildTree(s, ul, pair&amp;lt;int,int&amp;gt;(lr.first, line));
            cur-&amp;gt;right = buildTree(s, pair&amp;lt;int,int&amp;gt;(ul.first, line+1), lr);
        }
        else{
            cur-&amp;gt;left = buildTree(s, ul, pair&amp;lt;int,int&amp;gt;(line, lr.second));
            cur-&amp;gt;right = buildTree(s, pair&amp;lt;int,int&amp;gt;(line+1,ul.second), lr);
        }
    }
    else{
        cur-&amp;gt;left = NULL;
        cur-&amp;gt;right = NULL;
    }
    return cur;
}

PNG twoDtree::render(){
    /* your code here */
    PNG res(width, height);
    renderHelper(res, root);
    return res;
}

void twoDtree::renderHelper(PNG&amp;amp; res, Node* cur_node){
    if(!cur_node) return;   //稍微多余

    if(cur_node-&amp;gt;left == cur_node-&amp;gt;right){
        //只有两个都是空也就是叶子节点才会进行操作
        for(int i = cur_node-&amp;gt;upLeft.first; i &amp;lt;= cur_node-&amp;gt;lowRight.first; i++)
        for(int j = cur_node-&amp;gt;upLeft.second; j &amp;lt;= cur_node-&amp;gt;lowRight.second; j++){
            *res.getPixel(i, j) = cur_node-&amp;gt;avg;
        }
        return ;
    }
    else{
        renderHelper(res, cur_node-&amp;gt;left);
        renderHelper(res, cur_node-&amp;gt;right);
    }
}




void twoDtree::prune(double pct, int tol){
    /* your code here */
    //先逐层遍历，对每个节点判断是否需要剪枝
    queue&amp;lt;Node*&amp;gt; traverse_save;
    Node* cur;
    int sum, total; //小于tol个数，矩形像素数
    double rate;
    traverse_save.push(root);
    while(!traverse_save.empty()){
        cur = traverse_save.front();
        traverse_save.pop();

        if(cur == NULL)
            continue;
        sum = pruneHelper(cur, tol, cur-&amp;gt;avg);
        total = (cur-&amp;gt;lowRight.first-cur-&amp;gt;upLeft.first+1)*(cur-&amp;gt;lowRight.second-cur-&amp;gt;upLeft.second+1);
        rate = sum / total;

        if(rate &amp;gt;= pct){
            removeNode(cur-&amp;gt;left);
            cur-&amp;gt;left = NULL;
            removeNode(cur-&amp;gt;right);
            cur-&amp;gt;right = NULL;
        }
        else{
            traverse_save.push(cur-&amp;gt;left);
            traverse_save.push(cur-&amp;gt;right);
        }
    }
}

int twoDtree::pruneHelper(Node* cur, int tol, RGBAPixel avg){
    if(!cur)
        return 0;
    
    //只计算叶子
    if(cur-&amp;gt;left == NULL &amp;amp;&amp;amp; cur-&amp;gt;right == NULL){
        long diff = (avg.r - cur-&amp;gt;avg.r)*(avg.r - cur-&amp;gt;avg.r) + (avg.g - cur-&amp;gt;avg.g)*(avg.g - cur-&amp;gt;avg.g) + (avg.b - cur-&amp;gt;avg.b);
        if(diff &amp;lt;= tol)
            return 1;
        else return 0;
    }
    return pruneHelper(cur-&amp;gt;left, tol, avg) + pruneHelper(cur-&amp;gt;right, tol, avg);
}
void twoDtree::clear() {
    /* your code here */
    removeNode(root);
    root = NULL;
}

void twoDtree::removeNode(Node * x){
    if(!x) return ;
    removeNode(x-&amp;gt;left);
    removeNode(x-&amp;gt;right);
    delete x;
    return ;
}

void twoDtree::copy(const twoDtree &amp;amp; orig){
    /* your code here */
    //已经对copy进行了说明，不需要进行空间释放
    //本程序中仅有两次调用，调用之前都保证空间已经被初始化
    height = orig.height;
    width = orig.width;
    root = copyNode(orig.root);
}

twoDtree::Node*  twoDtree::copyNode(const Node* x){
    if(!x) return NULL;
    Node *tmp = new Node(x-&amp;gt;upLeft, x-&amp;gt;lowRight, x-&amp;gt;avg);
    tmp-&amp;gt;left = copyNode(x-&amp;gt;left);
    tmp-&amp;gt;right = copyNode(x-&amp;gt;right);
    return tmp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;p&gt;程序在wsl下编译完成，在main函数中添加了显示时间的部分代码，从编译到程序结束的整个过程如下图，对wsl用户名进行了一下处理，不过不影响观察。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134416.png&#34; alt=&#34;编译运行&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面简单说一下图片的生成情况，自己程序生成的图片和示例图片取得了大体一致的效果，但在细节保留方面以及图片美观程度上稍逊一筹。两个人像画都能做到近乎一致的保留，但稍加观察便可发现细节保留上的差距，下图右侧嘴唇部分处理远不如左侧（效果示例）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134507.png&#34; alt=&#34;人像对比&#34; /&gt;&lt;/p&gt;

&lt;p&gt;两组图腾的图片，细节较多的图片效果直在几处微小处出现了不同，因为大多数像素都被保留不具备较大的对比价值，在这里不进行详细对比。而另一张则表现出了极大的差别。很容易看出，树丛的细节在我的程序中删除的程度较重，误差最大的一部分甚至直接出现了较大的单色矩形块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/compression/20190503142116.png&#34; alt=&#34;图腾对比&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;简单分析&#34;&gt;简单分析&lt;/h3&gt;

&lt;p&gt;我个人认为我的代码实现没有太大的问题，都满足了题目的要求。所给代码中给定的pct和tol值可能适合于跑出示例图片的代码，对我的代码达到不了较好的保存程度。这点是可以理解的。&lt;/p&gt;

&lt;p&gt;不同人有不同的实现方式，不同的实现会带来不同的效果，横切还是竖切的选择，数据的计算表达式的书写方式等因素都会带来影响，涉及到浮点数，计算机内部采用的是近似计算，起初微小的误差经历后续计算之后可能会放大很多倍。所以效果有偏差是情理之中的事情。&lt;/p&gt;

&lt;p&gt;对于最后图腾图片的较大色块问题，假如参数真的一致，那就应该是我的算法有一些漏洞，细节处理时有一定的问题。&lt;/p&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;p&gt;我用了一周的时间去想高效的剪枝遍历解决方式，失败之后采用我起初认为最笨最麻烦的方式实现了剪枝函数，最终的运行时间另我很意外，我感觉我一直都在低估自己电脑的运算能力，大多数情况都只停留于感觉，没有进行较为科学的判断和推理，今后应该加强自己这方面的估算能力。另外如果可以的话，我想知道有没有更高效的算法，因为四张图片17秒的速度还是很慢。😕&lt;/p&gt;

&lt;p&gt;另外在帮别人调试代码的时候发现了win和linux下long型所占内存的不同，这导致两种环境下long型对应的最大值也不同，在win下编译出来的程序在计算过程中会直接越界，需要换用long long 类型。这次编程因为之前没有用vscode建过工程所以使用wsl进行的编译。程序中有部分代码直接在win下编译也会有一点点小问题，这难道也是linux的优势🐎？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业三 列车调度</title>
      <link>https://wanakiki.github.io/2019/train/</link>
      <pubDate>Sun, 21 Apr 2019 10:41:45 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/train/</guid>
      <description>

&lt;p&gt;本次作业不需提交报告。
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;Input&lt;/p&gt;

&lt;p&gt;共两行。&lt;/p&gt;

&lt;p&gt;第一行为两个整数n，m。&lt;/p&gt;

&lt;p&gt;第二行为以空格分隔的n个整数，保证为{1, 2, &amp;hellip;, n}的一个排列，表示待判断可行性的驶出序列{a1，a2，&amp;hellip;，an}。&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;p&gt;若驶出序列可行，则输出操作序列，其中push表示车厢从A进入S，pop表示车厢从S进入B，每个操作占一行。&lt;/p&gt;

&lt;p&gt;若不可行，则输出No。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;Sample Input 1 

5 2
1 2 3 5 4
Sample Output 1

push
pop
push
pop
push
pop
push
push
pop
pop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

int main(){
    int n, m;
    int B[10000];   //B队列
    bool step[20005];   //记录操作 0压入 1弹出
    bool flag = false;  //标记是否出现错误
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    stack&amp;lt;int&amp;gt; s;   //代表中转端
    
    for(int i = 0; i &amp;lt; n; i++){
        cin &amp;gt;&amp;gt; B[i];
    }

    int i = 1, j = 0, k = 0;  //当前数字i 操作步骤标记j B队列索引k
    while(i &amp;lt;= n){
        if(s.empty()){
            s.push(i++);
            step[j++] = 0;
        }
        else{
            if(s.top() == B[k]){
                s.pop();
                step[j++] = 1;
                k++;
            }
            else{
                s.push(i++);
                step[j++] = 0;
                if(s.size() &amp;gt; m){
                    flag = 1;
                    break;
                }
            }
        }
    }

    //剩余元素的弹出讨论
    while(!s.empty()){
        if(s.top() != B[k]){
            flag = 1;
            break;
        }
        else{
            s.pop();
            step[j++] = 1;
            k++;
        }
    }

    if(flag)
        cout &amp;lt;&amp;lt; &amp;quot;no&amp;quot;;
    else{
        for(int l = 0; l &amp;lt; j; l++){
            if(step[l])
                cout &amp;lt;&amp;lt; &amp;quot;pop&amp;quot;;
            else
                cout &amp;lt;&amp;lt; &amp;quot;push&amp;quot;;
            cout &amp;lt;&amp;lt; endl;
        }
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb39a396b3.png&#34; alt=&#34;测试&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业二 List ADT</title>
      <link>https://wanakiki.github.io/2019/list-adt/</link>
      <pubDate>Sat, 20 Apr 2019 20:22:40 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/list-adt/</guid>
      <description>

&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;

&lt;p&gt;题目要求自行实现list ADT，并在此基础上实现PrintLots函数并且实现懒惰删除功能。对于PrintLots函数，题目要求分析运行时间；对于懒惰删除功能，除编写实现外，题目还要求列出懒惰删除的优点和缺点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PrintLots(L,P)&lt;/strong&gt;：有两个链表L和P, 他们包含以升序排列的整数，操作PrintLots(L,P)将打印L中那些由P所指定位置上的元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;懒惰删除（lazy deletion）&lt;/strong&gt;：为了删除一个元素，我们只标记上该元素被删除。表中被删除和非被删除元素的个数作为数据结构的一部分被保留。如果被删除元素和非被删除元素一样多，我们遍历整个表，对所有被标记的节点执行标准的删除算法。&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;设计list ADT，准备好PrintLots函数所需要的接口。主文件引用自己编写的list ADT，并在主文件中完成对PrintLots函数的实现，懒惰删除则可以直接封装在ADT中。由于本次实验缺乏示例输入输出，因此还要对输入输出部分稍微加以设计，在此不多赘述。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;list ADT的实现大体可以按照课本所给的框架来初步构建，之后对其进行丰富，首先实现节点类，再进一步实现List类。考虑到懒惰删除的需要，在实现节点类的时候我在其中加入了是否删除的标志，实现List类时增加了用于统计伪删除元素个数的变量。为了更进一步贴合标准模板库的操作，相对多此一举地加入了迭代器子类。（实践证明，我对迭代器相关知识的了解并不充分&amp;hellip;😕）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb39389ad9.jpg&#34; alt=&#34;结构示意&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;printlots函数&#34;&gt;PrintLots函数&lt;/h3&gt;

&lt;p&gt;因为两个链表的元素都是升序排列的，所以L的迭代器可以一直向一个方向移动，整个函数的实现降低了一些难度。定义一个整形变量用来记录当前L的迭代器指向位置的编号，编号若与P的迭代器指向的元素相同则进行输出，同时两个迭代器向后移动。若编号与P当前元素不同，则指向L的迭代器向后移动。函数的终止条件为链表P遍历结束。&lt;/p&gt;

&lt;h4 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h4&gt;

&lt;p&gt;从整体上来看，PrintLots函数只是两个链表的单向遍历输出，只是细节方面稍微复杂，但引入的均为常数时间可以完成的操作。因为P的元素个数不可能超过L的元素个数，所以最坏情况便是输出了L的所有元素。时间复杂度为O(n)。&lt;/p&gt;

&lt;h3 id=&#34;懒惰删除&#34;&gt;懒惰删除&lt;/h3&gt;

&lt;p&gt;函数参数为指向要删除元素的迭代器，函数通过迭代器访问该元素内部的删除标志，并对其进行修改。修改之后检查当前伪删除元素的总数，大于总元素一般对整个链表进行遍历删除。总体实现相对简单。&lt;/p&gt;

&lt;h4 id=&#34;懒惰删除优缺点分析&#34;&gt;懒惰删除优缺点分析&lt;/h4&gt;

&lt;p&gt;优点：误删数据有恢复的空间，未被释放的空间可以进行二次利用，减少了资源消耗较大的删除过程的需求次数（链表中体现不明显）。
缺点：记录元素伪删除需要额外的操作和空间，被删除的节点不及时释放增加了空间的占用，也提高了部分操作所需的时间。&lt;/p&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb3959aa95.jpg&#34; alt=&#34;lazy deletion&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;p&gt;共编写了三个文件：listnode.h、my_list.h、main.cpp&lt;/p&gt;

&lt;p&gt;1.listnode.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    #include&amp;lt;iostream&amp;gt;
    using namespace std;

    //定义列表的节点
    template &amp;lt;typename T&amp;gt; struct ListNode
    {
        T data;
        ListNode&amp;lt;T&amp;gt;* pred;
        ListNode&amp;lt;T&amp;gt;* succ;
        bool need_remove;   //need_remove为了方便懒惰消除

        ListNode() : need_remove(false) {}
        ListNode(T e, ListNode&amp;lt;T&amp;gt;* p = NULL, ListNode&amp;lt;T&amp;gt;* s = NULL)
            : data(e), pred(p), succ(s), need_remove(false) {}

        ListNode&amp;lt;T&amp;gt;* insertAsPred(T const&amp;amp; e);
        ListNode&amp;lt;T&amp;gt;* insertAsSucc(T const&amp;amp; e);
    };

    //前插入
    template &amp;lt;typename T&amp;gt;
    ListNode&amp;lt;T&amp;gt;* ListNode&amp;lt;T&amp;gt;::insertAsPred(T const&amp;amp; e){
        ListNode&amp;lt;T&amp;gt;* x = new ListNode(e, pred, this);
        pred-&amp;gt;succ = x;
        pred = x;
        return x;
    }

    //后插入
    template &amp;lt;typename T&amp;gt;
    ListNode&amp;lt;T&amp;gt;* ListNode&amp;lt;T&amp;gt;::insertAsSucc(T const&amp;amp; e){
        ListNode&amp;lt;T&amp;gt;* x = new ListNode(e, this, succ);
        succ-&amp;gt;pred = x;
        succ = x;
        return x;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.my_list.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;listnode.h&amp;quot;

template &amp;lt;typename T&amp;gt;
class List
{
  private:
    int _size;
    int _num;
    ListNode&amp;lt;T&amp;gt; *header;
    ListNode&amp;lt;T&amp;gt; *trailer;

  protected:
    void init();
    void copyNodes(ListNode&amp;lt;T&amp;gt; *, int);
    //只写出了有可能用到的函数

  public:
    List() { init(); } //默认构造
    List(List&amp;lt;T&amp;gt; const &amp;amp;L);
    List(List&amp;lt;T&amp;gt; const &amp;amp;L, int r, int n);
    List(ListNode&amp;lt;T&amp;gt; *p, int n);
    int clear();

    ~List(); //析构

    class Iterator{
      public:
        ListNode&amp;lt;T&amp;gt; *ptr;

        Iterator() : ptr(NULL) {}
        Iterator(ListNode&amp;lt;T&amp;gt; *tmp) : ptr(tmp) {}

        T operator*(){
            return ptr-&amp;gt;data;
            //为空时如何抛出错误？
        }

        bool operator==(Iterator const &amp;amp;x) { return ptr == x.ptr; }
        bool operator!=(Iterator const &amp;amp;x) { return ptr != x.ptr; }
        Iterator operator++(int){
            //不能在这里访问trailer，那么标准的迭代器是怎么操作的呢
            Iterator tmp(ptr);
            while(1){
                if(ptr-&amp;gt;succ != NULL)
                    ptr = ptr-&amp;gt;succ;
                if(!ptr-&amp;gt;need_remove)   //不需要继续访问，跳出循环
                    break;
            }
            return tmp;
        }
        Iterator operator--(int){
            Iterator tmp(ptr);
            while(1){
                if (ptr-&amp;gt;pred != NULL)
                    ptr = ptr-&amp;gt;pred;
                if(!ptr-&amp;gt;need_remove)
                    break;
            }
            return tmp;
        }
        Iterator&amp;amp; operator++(){
            while(1){
                if(ptr-&amp;gt;succ != NULL)
                    ptr = ptr-&amp;gt;succ;
                if(!ptr-&amp;gt;need_remove)   //不需要继续访问，跳出循环
                    break;
            }
            return *this;
        }
        Iterator&amp;amp; operator--(){
            while(1){
                if (ptr-&amp;gt;pred != NULL)
                    ptr = ptr-&amp;gt;pred;
                if(!ptr-&amp;gt;need_remove)
                    break;
            }
            return *this;
        }
    };

    bool empty() const { return _size &amp;lt;= 0; }
    int size() const { return _size-_num; }
    ListNode&amp;lt;T&amp;gt; *insertAsFirst(T const &amp;amp;e);
    ListNode&amp;lt;T&amp;gt; *insertAsLast(T const &amp;amp;e);
    Iterator begin() { return ++Iterator(header); }
    Iterator end() { return Iterator(trailer); }
    ListNode&amp;lt;T&amp;gt; *first() const { return header-&amp;gt;succ; } //first和begin完全没必要
    ListNode&amp;lt;T&amp;gt; *last() const { return trailer-&amp;gt;pred; }
    T remove(ListNode&amp;lt;T&amp;gt; *p);
    void lazy_deletion(Iterator i);
    void show();
    void Advance(Iterator &amp;amp;i, int n);
};

template &amp;lt;typename T&amp;gt; //列表初始化
void List&amp;lt;T&amp;gt;::init()
{
    header = new ListNode&amp;lt;T&amp;gt;;
    trailer = new ListNode&amp;lt;T&amp;gt;;
    header-&amp;gt;succ = trailer;
    header-&amp;gt;pred = NULL;
    trailer-&amp;gt;pred = header;
    trailer-&amp;gt;succ = NULL;
    _size = 0;
    _num = 0;
}

//复制自p开始的n项
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::copyNodes(ListNode&amp;lt;T&amp;gt; *p, int n)
{
    init();
    while (n--)
    {
        insertASLast(p-&amp;gt;data);
        p = p-&amp;gt;succ;
    }
}

//Clear()
template &amp;lt;typename T&amp;gt;
int List&amp;lt;T&amp;gt;::clear()
{
    int num = _size;
    if (_size)
    {
        ListNode&amp;lt;T&amp;gt; *p = header-&amp;gt;succ;
        ListNode&amp;lt;T&amp;gt; *tmp;
        while (p != trailer)
        {
            tmp = p-&amp;gt;succ;
            delete p;
            p = tmp;
        }
    }
    _size = 0;
    _num = 0;
    return num;
}

//构造函数
template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(List&amp;lt;T&amp;gt; const &amp;amp;L) { copyNodes(L.first(), L.size()); }

template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(List&amp;lt;T&amp;gt; const &amp;amp;L, int r, int n)
{
    ListNode&amp;lt;T&amp;gt; *tmp = L.first();
    while (--r)
        tmp = tmp-&amp;gt;succ;
    copyNodes(tmp, n);
}

template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(ListNode&amp;lt;T&amp;gt; *p, int n) { copyNodes(p, n); }

//析构函数
template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::~List()
{
    clear();
    delete trailer;
    delete header;
}

template &amp;lt;typename T&amp;gt;
ListNode&amp;lt;T&amp;gt; *List&amp;lt;T&amp;gt;::insertAsFirst(T const &amp;amp;e)
{
    _size++;
    return header-&amp;gt;insertAsSucc(e);
}

template &amp;lt;typename T&amp;gt;
ListNode&amp;lt;T&amp;gt; *List&amp;lt;T&amp;gt;::insertAsLast(T const &amp;amp;e)
{
    _size++;
    return trailer-&amp;gt;insertAsPred(e);
}

//删除
template &amp;lt;typename T&amp;gt;
T List&amp;lt;T&amp;gt;::remove(ListNode&amp;lt;T&amp;gt; *p)
{
    T tmp= p-&amp;gt;data;
    _size--;
    p-&amp;gt;pred-&amp;gt;succ = p-&amp;gt;succ;
    p-&amp;gt;succ-&amp;gt;pred = p-&amp;gt;pred;
    delete p;
    return tmp;
}

template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::lazy_deletion(Iterator i){
    _num++;
    ListNode&amp;lt;T&amp;gt;* tmp = i.ptr;
    tmp-&amp;gt;need_remove = true;

    //数量大于一半开始全部删除
    if(_num &amp;gt;= _size/2){
        _num = 0;
        ListNode&amp;lt;T&amp;gt; *p = header-&amp;gt;succ;
        while(trailer != p){
            if(!p-&amp;gt;need_remove){
                p = p-&amp;gt;succ;
                continue;
            }
                
            tmp = p-&amp;gt;succ;
            remove(p);
            p = tmp;       
        }
    }
    return ;
}

//输出格式化
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::show(){
    if(_size == 0){
        cout &amp;lt;&amp;lt; &amp;quot;None&amp;quot; &amp;lt;&amp;lt; endl;
        return ;
    }
    ListNode&amp;lt;T&amp;gt;* p = header;
    while(trailer != (p = p-&amp;gt;succ)){
        if(p == header-&amp;gt;succ){
            cout &amp;lt;&amp;lt; p-&amp;gt;data;
            continue;
        }
        if(p-&amp;gt;pred-&amp;gt;need_remove &amp;amp;&amp;amp; p-&amp;gt;need_remove)    cout &amp;lt;&amp;lt; &amp;quot;____&amp;quot;;
        else if(p-&amp;gt;need_remove)     cout &amp;lt;&amp;lt; &amp;quot;--__&amp;quot;;
        else if(p-&amp;gt;pred-&amp;gt;need_remove)   cout &amp;lt;&amp;lt; &amp;quot;__-&amp;gt;&amp;quot;;
        else    cout &amp;lt;&amp;lt; &amp;quot;---&amp;gt;&amp;quot;;
        cout &amp;lt;&amp;lt; p-&amp;gt;data;
    }
    return ;
}

//用于迭代器的移动
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::Advance(Iterator &amp;amp; i, int n){
    if(n &amp;gt;= 0){
        while(n--)
            i.ptr = i.ptr-&amp;gt;succ;
    }
    else{
        while(n++)
            i.ptr = i.ptr-&amp;gt;pred;
    }
}
//如果向容器里面放个pair？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.main.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;my_list.h&amp;quot;


void PrintLots(List&amp;lt;int&amp;gt;&amp;amp; L, List&amp;lt;int&amp;gt;&amp;amp; P){
    int current = 1;

    //是否存在空序列
    if(L.empty() || P.empty())  {   cout&amp;lt;&amp;lt;&amp;quot;Error, input is empty&amp;quot;&amp;lt;&amp;lt;endl; return ;}

    List&amp;lt;int&amp;gt;::Iterator l = L.begin();
    List&amp;lt;int&amp;gt;::Iterator p = P.begin();
    while(1){
        if(L.size() &amp;lt; *p){  
            cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;quot;Error, the number of P is bigger than the size of L&amp;quot; &amp;lt;&amp;lt; endl;  
            break;
        }

        if(current++ == *p){
            cout &amp;lt;&amp;lt; *l &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            p++;
        }

        //输出结束
        if(p == P.end()){  
                cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;quot;Finished!&amp;quot; &amp;lt;&amp;lt; endl;
                break;
        }
        l++;
    }
    return ;
}

int main(){
    int m, n, tmp, last;
    int select = 0;
    while(1){
        cout &amp;lt;&amp;lt; &amp;quot;Choose function(0 means lazy_deletion, 1 means PrintLots):&amp;quot;;
        cin &amp;gt;&amp;gt; select;
        if(select){
            List&amp;lt;int&amp;gt; L, P;
            cout &amp;lt;&amp;lt; &amp;quot;Input the size of L and P: &amp;quot;;
            cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of L: &amp;quot; &amp;lt;&amp;lt; endl;
            while (m--){
                cin &amp;gt;&amp;gt; tmp;
                L.insertAsLast(tmp);
            }
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of P: &amp;quot; &amp;lt;&amp;lt; endl;
            while (n--){
                cin &amp;gt;&amp;gt; tmp;
                P.insertAsLast(tmp);
            }
            PrintLots(L, P);
        }
        else{
            List&amp;lt;int&amp;gt; L;
            cout &amp;lt;&amp;lt; &amp;quot;Input the size of L: &amp;quot;;
            cin &amp;gt;&amp;gt; m;
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of L:&amp;quot; &amp;lt;&amp;lt; endl;
            for(int j = 0; j &amp;lt; m; j++){
                cin &amp;gt;&amp;gt; tmp;
                L.insertAsLast(tmp);
            }
            cout &amp;lt;&amp;lt; &amp;quot;L is: &amp;quot;;
            L.show();
            cout&amp;lt;&amp;lt;endl;


            List&amp;lt;int&amp;gt;::Iterator i = L.begin();
            last = 1;
            cout &amp;lt;&amp;lt; &amp;quot;How many elements do you want to delete? &amp;quot;;
            cin &amp;gt;&amp;gt; n;
            cout &amp;lt;&amp;lt; &amp;quot;Input them(from 1 to &amp;quot; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;quot;)&amp;quot; &amp;lt;&amp;lt; endl;
            while(n--){
                cin &amp;gt;&amp;gt; tmp;
                L.Advance(i, tmp-last);
                last = tmp;
                L.lazy_deletion(i);
            }
            cout &amp;lt;&amp;lt; &amp;quot;Now L is: &amp;quot;;
            L.show();
            cout &amp;lt;&amp;lt; endl;
        } 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;p&gt;PrintLots进行了四组测试，从测试结果可以看出对错误情况进行了有效的判断，并且能够处理一般情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb396983b0.jpg&#34; alt=&#34;PrintLots测试&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了方便懒惰删除的查看，设置了一个函数用来表现链表当前的情况，同时进行了三种样例的测试，能够代表所有类型的满足要求的输入情况。可以很容易的看出当删除元素过半时按要求完成了操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb3979a5b2.jpg&#34; alt=&#34;懒惰删除测试&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;深刻感觉到自己的宏观思维有极大的欠缺，自己设计出的类中的函数不能很好地衔接，编程思维有问题。&lt;/li&gt;
&lt;li&gt;自己写的迭代器可能称不上是迭代器，只是稍微包装了一下指针。自己测试的时候发现在iterator已经被定义，意识到平时所用的迭代器并不是定义在容器的头文件中。&lt;/li&gt;
&lt;li&gt;边界等特殊情况没有得到很好的处理，不过能够保证在输入规范的情况下得到良好的结果，代码总体有待完善。（总之还是对标准模板库特殊情况处理方式不够了解📌&lt;/li&gt;
&lt;li&gt;很多用不到的东西也进行了实现，导致代码量相对较大😓&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业一 Zuma List</title>
      <link>https://wanakiki.github.io/2019/zuma-list/</link>
      <pubDate>Sat, 20 Apr 2019 19:41:55 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/zuma-list/</guid>
      <description>

&lt;p&gt;数据结构第一次作业。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;

&lt;p&gt;题目要求书写程序对祖玛消除过程进行回放，输入为原始珠子序列以及玩家所做的一系列操作，要求我们按照游戏规则计算出每次操作后的珠子序列并进行输出。&lt;/p&gt;

&lt;p&gt;祖玛游戏规则：有三个或更多同色珠子变成相邻就会立即消失，并且可能会发生连锁反应。&lt;strong&gt;需要注意，原始情况中出现的三个或更多相邻同色珠子，在没有新珠子或者连锁反应影响时是不会消除的。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;将新的珠子插入到原有序列，在插入位置向两侧判断同色珠子个数，满足条件则进行删除。考虑到删除后的连锁反应，需要将判断的过程循环执行到无法继续删除。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;考虑到整个过程需要多次插入删除的操作，并且查找过程只需要从插入的具体位置向两侧进行判断，所以使用list对珠子序列进行存储。&lt;/p&gt;

&lt;p&gt;插入过程只需要简单的insert函数与advance函数相配合就可以了，使用advance函数使迭代器指到插入位置，之后再用insert函数进行插入。&lt;/p&gt;

&lt;p&gt;比较难的地方在于是否消除的判断上，考虑到迭代器的特殊性，为了避免不必要的麻烦，当list中的元素少于三个的时候直接不进行判断。对三个以上的元素判断时，需要从插入元素的位置向两侧查找相同颜色，可以用&lt;code&gt;end()&lt;/code&gt;和&lt;code&gt;begin()&lt;/code&gt;来判断是否到达了查找的两端，当然，如果在查找过程中就发现了不同的珠子就可以直接停止查找过程。查找结束之后直接对查找到的区间进行删除，同时保留左开右闭区间的右端点作为下次查找过程的起始位置。&lt;/p&gt;

&lt;p&gt;数据的输入和结果输出过程按照题目的要求进行编写即可。&lt;/p&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb38e8cb30.jpg&#34; alt=&#34;流程图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

void bang(list&amp;lt;char&amp;gt; &amp;amp; beads, int id, char bead){
    list&amp;lt;char&amp;gt;::iterator i, r, l;
    int num = 0;    /*计数*/
    i = beads.begin();
    advance(i, id);
    beads.insert(i, bead);  /*插入元素*/

    /*考虑到多次消除的可能，使用while循环进行消除*/
    while(1){
        if(beads.size() &amp;lt; 3)
            break;
        
        num = 0;
        r = i--;    
        /*这步操作之后r指向被插入元素以后，i指向被插入元素*/
        
        for(; r != beads.end(); r++){
            if(*r == *i)    num ++;
            else    break;
        }           /*向右判断*/

        l = i;          
        /*if(i != beads.begin()){
            l--;
            while (1){
                if(*l != *i){   l++;break;} //l需要加加
                else    num ++;
                
                if(l == beads.begin())  break;
                else    l--;    
            }
        }   //向左判断*/

        /*由流程图发现的简化方法*/
        while(l != beads.begin()){
            l--;
            if(*l != *i){   l++; break;}
            else    num++;
        }


        /*删除部分*/
        if(num &amp;gt; 1){
            beads.erase(l, r);
            i = r;
        }
        else
            break;
    }


    /*输出*/
    if(beads.empty())
        cout &amp;lt;&amp;lt; &#39;-&#39; &amp;lt;&amp;lt; endl;
    else{
        for(i = beads.begin(); i != beads.end(); i++)
            cout &amp;lt;&amp;lt; *i;
        cout &amp;lt;&amp;lt; endl;
    }
    return ;
}
int main(){
    int n, id;
    char bead;
    string initial_beads;
    list&amp;lt;char&amp;gt; beads;

    getline(cin, initial_beads);
    for(int i = 0; i &amp;lt; initial_beads.size(); i++){
        beads.push_back(initial_beads[i]);
    }
    /*构造初始状态*/

    cin &amp;gt;&amp;gt; n;
    while(n--){
        cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; bead;
        bang(beads, id, bead);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb38f267db.jpg&#34; alt=&#34;测试1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb39060e21.jpg&#34; alt=&#34;测试2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上，经过测试，程序完成要求，并且能够处理初始序列为空的情况。👍&lt;/p&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;增加了对erase函数的了解：

&lt;ol&gt;
&lt;li&gt;当参数只有一个的时候，原迭代器指向的位置被删除，迭代器无效化，不能对其继续进行操作，否则会造成错误，但函数会返回原位置之后的迭代器，所以可以利用这个特性进行区间删除（省略++步骤）。&lt;/li&gt;
&lt;li&gt;当有两个参数的时候，函数结束之后前一个迭代器会无效化，而后一个迭代器因为删除区间为左闭右开的特点，其指向的位置不会被删除。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;迭代器是一个很玄学的东西，使用不规范很容易带来错误，查错的时候可以优先考虑。&lt;/li&gt;
&lt;li&gt;流程图可以帮忙理清逻辑结构！！！😀&lt;/li&gt;
&lt;li&gt;写程序尽量一次性写完&amp;hellip;&amp;hellip;🤧&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>括号匹配</title>
      <link>https://wanakiki.github.io/2019/kuohao/</link>
      <pubDate>Sat, 20 Apr 2019 14:36:43 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/kuohao/</guid>
      <description>

&lt;p&gt;这个学期开始学数据结构，第一节课老师又提出了这个经典的问题。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;给出一个只包含&amp;rsquo;(&amp;lsquo;和&amp;rsquo;)&amp;lsquo;的字符串，判断该字符串中的括号是否匹配。并将匹配的括号用&amp;rsquo;_&amp;lsquo;代替，不匹配的括号用&amp;rsquo;$&amp;lsquo;标出。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;输入：
(())()))
输出：
(())()))
______$$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;简单解法&#34;&gt;简单解法&lt;/h2&gt;

&lt;p&gt;括号匹配问题是刚开始学习C语言的时候就接触的问题，当时老师引入这个问题的原因可能是为了介绍栈的概念，但是当时班上大多数人都采取了直接用数组模拟的方法。把整个字符串录入，之后遍历整个字符串，遇到右括号就向前寻找是否存在对应的左括号，进行判断。C++代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
using namespace std;
int main(){
    string str, tmp;    
    //tmp用于保留原来的字符串，为了方便直接用string输入
    cin &amp;gt;&amp;gt; str;
    tmp = str;
    for(int i = 0; i &amp;lt; str.length(); i++){
        if(str[i] == &#39;)&#39;){
            for(int j = i - 1; j &amp;gt;= 0; j--){
                if(str[j] == &#39;(&#39;){
                    str[i] = str[j] = &#39;_&#39;;
                    break;
                }
            }
        }
    }
    for(int i = 0; i &amp;lt; str.length(); i++){
        if(str[i] != &#39;_&#39;)
            str[i] = &#39;$&#39;;   //找出不匹配的括号
    }
    cout &amp;lt;&amp;lt; tmp &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; str;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用栈来解决&#34;&gt;使用栈来解决&lt;/h2&gt;

&lt;p&gt;首先忽略掉不匹配括号的标记问题，聚焦于判断整个字符串是否存在不匹配的括号。要看字符串是否匹配，只要看左括号是否有对应的右括号，或者右括号是否有对应的左括号，问题解决方法是相同的。&lt;/p&gt;

&lt;p&gt;读入一个左括号我们就可以把它压入栈中，遇到右括号就弹出栈中的左括号。如果所有的右括号都读取完，栈中还有左括号，或者读入一个右括号栈中已经没有了括号，就意味着该字符串中的括号不匹配。C++代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;string&amp;gt;
using namespace std;
int main(){
    stack&amp;lt;char&amp;gt; s;
    string tmp;
    cin &amp;gt;&amp;gt; tmp;
    for(int i = 0; i &amp;lt; tmp.length(); i++){
        if(tmp[i] == &#39;(&#39;)
            s.push(tmp[i]);
        else
        {
            if(s.empty())
                cout &amp;lt;&amp;lt; &amp;quot;FALSE&amp;quot;;
            else
            {
                s.pop();
            }
            
        }
        
    }
    if(!s.empty())
        cout &amp;lt;&amp;lt; &amp;quot;FALSE&amp;quot;;
    else
    {
        cout &amp;lt;&amp;lt; &amp;quot;TRUE&amp;quot;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码完全可以不用栈，设置一个变量来记录当前拥有的左括号的数量就可以大大简化代码。&lt;/p&gt;

&lt;p&gt;如果我们想要知道是哪几个字符不匹配，我的想法是直接将字符的索引压入栈中，因为只有一种括号，把字符压入栈中实际上是不必要之举。将上面的代码输出错误的地方改成记录错误的下标，就可以将出错字符的下标记录下来，当所有的右括号都判断完之后，栈中剩余的所有左括号下标也同样要记录下来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://wanakiki.github.io/about/</link>
      <pubDate>Sat, 20 Apr 2019 13:54:01 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/about/</guid>
      <description>&lt;p&gt;趁着运动会的假期把GitHub上面博客的生成方式从hexo换到了hugo，希望今后能够坚持下去😀，另外之前没有写多少博文，迁移过来并不会造成太多的麻烦。&lt;/p&gt;

&lt;p&gt;新方式的配置主要参考了&lt;a href=&#34;https://mogeko.me/2018/018/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Mogeko的博客&lt;/a&gt;，在此对他表示感谢。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>