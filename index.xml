<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wanakiki`s Blog on Wanakiki`s Blog</title>
    <link>https://wanakiki.github.io/</link>
    <description>Recent content in Wanakiki`s Blog on Wanakiki`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 17 May 2019 09:47:43 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>æ•°æ®ç»“æ„ä½œä¸šä¸ƒ Transport</title>
      <link>https://wanakiki.github.io/2019/transport/</link>
      <pubDate>Fri, 17 May 2019 09:47:43 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/transport/</guid>
      <description>

&lt;p&gt;æ¸…åOJå¹¿åº¦ä¼˜å…ˆæœç´¢é¢˜ç›®ã€‚
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2 id=&#34;æè¿°&#34;&gt;æè¿°&lt;/h2&gt;

&lt;p&gt;æŸå¹¿æ’­å…¬å¸è¦åœ¨ä¸€ä¸ªåœ°åŒºæ¶è®¾æ— çº¿å¹¿æ’­å‘å°„è£…ç½®ã€‚è¯¥åœ°åŒºå…±æœ‰nä¸ªå°é•‡ï¼Œæ¯ä¸ªå°é•‡éƒ½è¦å®‰è£…ä¸€å°å‘å°„æœºå¹¶æ’­æ”¾å„è‡ªçš„èŠ‚ç›®ã€‚&lt;/p&gt;

&lt;p&gt;ä¸è¿‡ï¼Œè¯¥å…¬å¸åªè·å¾—äº†FM104.2å’ŒFM98.6ä¸¤ä¸ªæ³¢æ®µçš„æˆæƒï¼Œè€Œä½¿ç”¨åŒä¸€æ³¢æ®µçš„å‘å°„æœºä¼šäº’ç›¸å¹²æ‰°ã€‚å·²çŸ¥æ¯å°å‘å°„æœºçš„ä¿¡å·è¦†ç›–èŒƒå›´æ˜¯ä»¥å®ƒä¸ºåœ†å¿ƒï¼Œ20kmä¸ºåŠå¾„çš„åœ†å½¢åŒºåŸŸï¼Œå› æ­¤ï¼Œå¦‚æœè·ç¦»å°äº20kmçš„ä¸¤ä¸ªå°é•‡ä½¿ç”¨åŒæ ·çš„æ³¢æ®µï¼Œé‚£ä¹ˆå®ƒä»¬å°±ä¼šç”±äºæ³¢æ®µå¹²æ‰°è€Œæ— æ³•æ­£å¸¸æ”¶å¬èŠ‚ç›®ã€‚ç°åœ¨ç»™å‡ºè¿™äº›è·ç¦»å°äº20kmçš„å°é•‡åˆ—è¡¨ï¼Œè¯•åˆ¤æ–­è¯¥å…¬å¸èƒ½å¦ä½¿å¾—æ•´ä¸ªåœ°åŒºçš„å±…æ°‘æ­£å¸¸å¬åˆ°å¹¿æ’­èŠ‚ç›®ã€‚&lt;/p&gt;

&lt;h3 id=&#34;è¾“å…¥&#34;&gt;è¾“å…¥&lt;/h3&gt;

&lt;p&gt;ç¬¬ä¸€è¡Œä¸ºä¸¤ä¸ªæ•´æ•°nï¼Œmï¼Œåˆ†åˆ«ä¸ºå°é•‡çš„ä¸ªæ•°ä»¥åŠæ¥ä¸‹æ¥å°äº20kmçš„å°é•‡å¯¹çš„æ•°ç›®ã€‚ æ¥ä¸‹æ¥çš„mè¡Œï¼Œæ¯è¡Œ2ä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºä¸¤ä¸ªå°é•‡çš„è·ç¦»å°äº20kmï¼ˆç¼–å·ä»1å¼€å§‹ï¼‰ã€‚&lt;/p&gt;

&lt;h3 id=&#34;è¾“å‡º&#34;&gt;è¾“å‡º&lt;/h3&gt;

&lt;p&gt;å¦‚æœèƒ½å¤Ÿæ»¡è¶³è¦æ±‚ï¼Œè¾“å‡º1ï¼Œå¦åˆ™è¾“å‡º-1ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;è¾“å…¥æ ·ä¾‹
4 3
1 2
1 3
2 4

è¾“å‡ºæ ·ä¾‹
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;é™åˆ¶&lt;/p&gt;

&lt;p&gt;1 â‰¤ n â‰¤ 10000&lt;/p&gt;

&lt;p&gt;1 â‰¤ m â‰¤ 30000&lt;/p&gt;

&lt;p&gt;ä¸éœ€è¦è€ƒè™‘ç»™å®šçš„20kmå°é•‡åˆ—è¡¨çš„ç©ºé—´ç‰¹æ€§ï¼Œæ¯”å¦‚æ˜¯å¦æ»¡è¶³ä¸‰è§’ä¸ç­‰å¼ï¼Œæ˜¯å¦åˆ©ç”¨ä¼ é€’æ€§å¯ä»¥æ¨å‡ºæ›´å¤šçš„ä¿¡æ¯ç­‰ç­‰ã€‚&lt;/p&gt;

&lt;p&gt;æ—¶é—´ï¼š2 sec&lt;/p&gt;

&lt;p&gt;ç©ºé—´ï¼š256MB&lt;/p&gt;

&lt;p&gt;æç¤º
BFS&lt;/p&gt;

&lt;h2 id=&#34;é—®é¢˜åˆ†æ-è§£å†³æ–¹æ¡ˆ&#34;&gt;é—®é¢˜åˆ†æ&amp;amp;è§£å†³æ–¹æ¡ˆ&lt;/h2&gt;

&lt;p&gt;é€šè¿‡è¯»é¢˜ä¸éš¾å‘ç°é¢˜ç›®çš„è¦ç‚¹æœ‰ä¸¤ä¸ªï¼šç¬¬ä¸€ï¼Œæ¯ä¸ªå°é•‡éƒ½éœ€è¦å®‰è£…ä¸€å°å‘å°„æœºï¼›ç¬¬äºŒï¼Œç›¸è·20kmä»¥å†…çš„å°é•‡ä¸èƒ½ä½¿ç”¨ç›¸åŒé¢‘ç‡çš„æ³¢æ®µã€‚æˆ‘ä»¬è¦åšçš„å°±æ˜¯é€šè¿‡é¢˜ç›®ç»™å‡ºçš„è·ç¦»å°äº20kmçš„å°é•‡åˆ—è¡¨ï¼Œåˆ¤æ–­æ˜¯å¦èƒ½å¤Ÿä¿è¯æ¯ä¸ªå°é•‡éƒ½èƒ½æ­£å¸¸æ”¶å¬å¹¿æ’­ã€‚&lt;/p&gt;

&lt;p&gt;å› ä¸ºç›¸äº’è·ç¦»å°äº20kmçš„å°é•‡ä¹‹é—´æ‰ä¼šå‘ç”Ÿå¹²æ‰°ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦è€ƒè™‘è¿™ä¸€éƒ¨åˆ†å°é•‡èƒ½å¦æ»¡è¶³æ¡ä»¶å³å¯è§£å†³é—®é¢˜ï¼Œè€Œé‚£äº›ç›¸éš”è¾ƒè¿œçš„å°é•‡åœ¨è¿™ä¸ªé¢˜ç›®ä¸­å¯¹æˆ‘ä»¬æ²¡æœ‰é€ æˆä»»ä½•å±å®³ã€‚&lt;/p&gt;

&lt;p&gt;ç°åœ¨æˆ‘ä»¬è®¨è®ºè·ç¦»å°äº20kmçš„è¿™ä¸€éƒ¨åˆ†å°é•‡ï¼Œå‡è®¾è¿™ä¸€éƒ¨åˆ†å°é•‡é˜Ÿé›†åˆä¸ºMï¼ˆå¯ä»¥ç›´æ¥ç†è§£ä¸ºå›¾ï¼‰ã€‚é¢˜ç›®å·²ç»æ˜ç¡®æŒ‡å‡ºï¼Œåœ¨è·ç¦»å°äº20kmçš„å‰æä¸‹ï¼Œå¦‚ä¸¤ä¸ªå°é•‡æœ‰ç›¸åŒçš„æ³¢æ®µå°±ä¼šäº’ç›¸å¹²æ‰°ï¼Œæ‰€ä»¥å¯¹äºMä¸­ä»»æ„ä¸€ä¸ªå°é•‡é˜Ÿ(u,v)ï¼Œåœ¨uçš„é¢‘ç‡ç¡®å®šçš„æ¡ä»¶ä¸‹ï¼Œvçš„é¢‘ç‡ä¹Ÿéšä¹‹å›ºå®šã€‚&lt;/p&gt;

&lt;p&gt;å› ä¸ºæˆ‘ä»¬å¯¹é¢‘ç‡æ²¡æœ‰æ›´å¤šçš„é™„åŠ æ¡ä»¶ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å°†FM104.2å’ŒFM98.6ä¸¤ä¸ªæ³¢æ®µç›´æ¥æŠ½è±¡ä¸ºä¸¤ä¸ªä¸åŒçš„æ ‡å¿—ï¼Œä½œä¸ºå°é•‡çš„ä¸€ä¸ªå±æ€§eleã€‚ä¹‹åæˆ‘ä»¬åœ¨Må†…ä»»æ„åˆå§‹åŒ–å…¶ä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„eleå±æ€§ï¼ˆåˆå§‹åŒ–çš„å€¼ä¹Ÿæ˜¯ä»»æ„çš„ï¼Œå› ä¸ºæŠ½è±¡åªæ˜¯ä¸ºäº†åŒºåˆ†ä¸¤ç§æƒ…å†µï¼‰ï¼ŒæŒ‰ç…§å°é•‡é˜Ÿé¢‘ç‡äº’æ–¥çš„è¦æ±‚æˆ‘ä»¬å°±å¯ä»¥æŠŠä¸ä¹‹è”é€šçš„æ‰€æœ‰å°é•‡çš„eleå±æ€§ç¡®å®šä¸‹æ¥ã€‚åªè¦è¿‡ç¨‹ä¸­ä¸å‡ºç°ç›¸äº’çŸ›ç›¾çš„ç‚¹ï¼Œæˆ‘ä»¬å°±å¯ä»¥æˆåŠŸå¸ƒç½®ã€‚&lt;/p&gt;

&lt;p&gt;è€ƒè™‘åˆ°ç»™å‡ºçš„Må¯èƒ½æ˜¯åˆ†å—çš„ï¼Œæ‰€ä»¥åœ¨æ‰§è¡Œå®Œä¸€æ¬¡æ‰©å±•ä¹‹åç¨‹åºè¿˜éœ€è¦å¯¹å…¶ä»–èŠ‚ç‚¹è¿›è¡Œåˆ¤æ–­ã€‚è¿™æ ·å°±èƒ½å¤Ÿä¿è¯ç¨‹åºçš„æ­£ç¡®æ€§ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç®—æ³•è®¾è®¡&#34;&gt;ç®—æ³•è®¾è®¡&lt;/h2&gt;

&lt;p&gt;ç°åœ¨å›é¡¾ä¸€ä¸‹æˆ‘ä»¬éœ€è¦åšçš„æ“ä½œï¼šæŒ‰ç…§äº’æ–¥çš„è§„åˆ™ä»ä»»æ„ä¸€ç‚¹å±•å¼€ï¼Œåˆ¤æ–­æ˜¯å¦èƒ½å¤Ÿè”“å»¶åˆ°æ‰€æœ‰çš„èŠ‚ç‚¹ã€‚å› ä¸ºæ•°æ®æ˜¯æˆå¯¹è¾“å…¥çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¾ˆå®¹æ˜“è”æƒ³åˆ°ç”¨å›¾æ¥ä¿å­˜ï¼Œé‚£ä¹ˆæˆ‘ä»¬åœ¨è¿™ä¸ªé¢˜ç›®ä¸­æ‰€éœ€è¦çš„æ“ä½œå®è´¨ä¸Šå°±å˜æˆäº†ä¸€ä¸ªå›¾éå†çš„é—®é¢˜ï¼Œæ›´å‡†ç¡®æ¥è®²ï¼ŒBFSé—®é¢˜ï¼Œå› ä¸ºå¹¿åº¦ä¼˜å…ˆæ›´æœ‰åˆ©äºæå‰å‘ç°ä¸æ»¡è¶³äº’æ–¥æ¡ä»¶çš„ç‚¹ã€‚&lt;/p&gt;

&lt;p&gt;æ‰€ä»¥å®ç°æ€è·¯ä¹Ÿå¾ˆæ˜ç¡®äº†ï¼šç”¨å›¾çš„å½¢å¼å°†è¾“å…¥æ•°æ®ä¿å­˜ä¸‹æ¥ï¼Œç„¶åé‡‡ç”¨BFSç­–ç•¥å¯¹å›¾è¿›è¡Œéå†ã€‚è€ƒè™‘åˆ°è¦é€šè¿‡eleå±æ€§åˆ¤æ–­æ˜¯å¦äº’æ–¥ï¼Œæ‰€ä»¥åœ¨å®šä¹‰å›¾çš„èŠ‚ç‚¹çš„æ—¶å€™è¦åŠ ä¸Šè¿™ä¸ªå±æ€§ï¼ŒBFSä¸­ä¹Ÿè¦æ ¹æ®å½“å‰ä¸€è½®æœç´¢çš„å‡ºå‘ç‚¹çš„å±æ€§è®¾ç½®ä¸ä¹‹ç›¸è¿çš„ç‚¹çš„å±æ€§ï¼Œæˆ–è€…åˆ¤æ–­å·²è®¿é—®çš„ç‚¹çš„å±æ€§æ˜¯å¦å’Œè¯¥è½®æœç´¢å‡ºå‘ç‚¹çš„å±æ€§æ˜¯å¦ç›¸åŒã€‚&lt;/p&gt;

&lt;p&gt;å…³äºå›¾çš„å­˜å‚¨å½¢å¼ï¼Œæˆ‘ä½¿ç”¨çš„æ˜¯é‚»æ¥è¡¨ï¼Œé‡‡ç”¨é‚»æ¥çŸ©é˜µä¼šè€—è´¹è¾ƒå¤§çš„ç©ºé—´ã€‚å¦å¤–è¿˜è¦æ³¨æ„ï¼Œæœ¬é¢˜ä¸­çš„å›¾ä¸ºæ— å‘å›¾ã€‚è€Œeleå±æ€§çš„ä¸‰ç§æ ‡è®°å½¢å¼ï¼Œæˆ‘æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹æ¡ˆï¼Œæˆ‘é‡‡ç”¨çš„æ˜¯å‰è€…ã€‚&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;åˆå§‹çŠ¶æ€ä¸º0ï¼Œç›¸å¯¹ç«‹çš„ä¸¤ç§çŠ¶æ€ä¸º-1å’Œ1ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡å–ç›¸åæ•°çš„æ–¹æ³•æ›´æ–°ã€‚&lt;/li&gt;
&lt;li&gt;åˆå§‹çŠ¶æ€ä¸º2ï¼Œç›¸å¯¹ç«‹çš„ä¸¤ç§çŠ¶æ€ä¸º0å’Œ1ï¼Œé€šè¿‡ï¼ˆx+1ï¼‰%2çš„æ–¹å¼è¿›è¡Œæ›´æ–°ã€‚&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;å¦å¤–ä¸€ç‚¹ï¼Œæœ¬æ¬¡é¢˜ç›®å› ä¸ºè¦åœ¨æ¸…åOJä¸Šè¿›è¡Œæµ‹è¯•ï¼Œæ²¡æœ‰stlæ ‡å‡†åº“ï¼Œå¦‚æœè¦ç”¨åˆ°é˜Ÿåˆ—çš„è¯éœ€è¦è‡ªå·±å®ç°ã€‚æˆ‘é‡‡ç”¨äº†é“¾è¡¨å’Œæ•°ç»„æ¨¡æ‹Ÿä¸¤ç§æ–¹å¼å¯¹é˜Ÿåˆ—è¿›è¡Œäº†å®ç°ï¼Œå‡é€šè¿‡äº†æµ‹è¯•ï¼Œä»£ç å°†åœ¨ä¸‹é¢ç»™å‡ºã€‚å¦å¤–ä¹Ÿä¸€å¹¶é™„ä¸Šstlç‰ˆæœ¬ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç¼–ç¨‹å®ç°&#34;&gt;ç¼–ç¨‹å®ç°&lt;/h2&gt;

&lt;h3 id=&#34;ç”¨é“¾è¡¨å®ç°é˜Ÿåˆ—&#34;&gt;ç”¨é“¾è¡¨å®ç°é˜Ÿåˆ—&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
//#include &amp;lt;queue&amp;gt;
using namespace std;

//é˜Ÿåˆ—èŠ‚ç‚¹
struct node_of_queue{
    int del;
    node_of_queue* next;
    node_of_queue(int v, node_of_queue* x = NULL):del(v),next(x){}
};

//é˜Ÿåˆ—ç±»
class myQueue{
public:
    node_of_queue* front;
    node_of_queue* back;
    myQueue():front(NULL),back(NULL){}
    int Front(){
        if(front)
            return (front-&amp;gt;del);
        return 0;
    }
    void push(int x){
        node_of_queue* tmp = new node_of_queue(x);
        if(!front)
            front = tmp;
        if(!back)
            back = tmp;
        else{
            back-&amp;gt;next = tmp;
            back = tmp;
        }
        return ;
    }
    bool empty(){
        return front == NULL;
    }
    void pop(){
        if(front){
            node_of_queue* tmp = front;
            front = front-&amp;gt;next;
            if(!front)
                back = NULL;
            delete tmp;
        }
        return ;
    }
};

//å°é•‡èŠ‚ç‚¹
struct Node{
    int _id;
    Node* _next;
    Node(int id, Node* next = NULL):_id(id), _next(next){}
};

//å°é•‡é›†åˆ
struct Nodes{
    int _ele;
    Node* _next;
    Nodes():_ele(0), _next(NULL){}
    void insert(int id);
};

void Nodes::insert(int id){
    _next = new Node(id, _next);
    return ;
}

int main(){
    Nodes nodes[10005];
    myQueue myQ;
    int n, m;
    int v, u;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while(m--){
        cin &amp;gt;&amp;gt; v &amp;gt;&amp;gt; u;
        nodes[v].insert(u);
        nodes[u].insert(v); //æ— å‘å›¾éœ€è¦ä¸¤æ¬¡æ’å…¥
    }
    for(int cur = 1; cur &amp;lt;= n; cur++){
        if(!nodes[cur]._ele){
            nodes[cur]._ele = 1;    //è¿›è¡Œæ ‡è®°
            myQ.push(cur);

            int tmp;
            while(!myQ.empty()){
                tmp = myQ.Front();
                myQ.pop();

                Node* cur_node = nodes[tmp]._next;
                while(cur_node){
                    if (nodes[cur_node-&amp;gt;_id]._ele == nodes[tmp]._ele){
                        //å·²æ”¾ç½®åŒè‰²
                        cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
                        return 0;
                    }
                    if(!nodes[cur_node-&amp;gt;_id]._ele){
                        //æœªæ”¾ç½®
                        nodes[cur_node-&amp;gt;_id]._ele = -nodes[tmp]._ele;
                        myQ.push(cur_node-&amp;gt;_id);    //åªå…¥é˜Ÿæ²¡è¢«è®¿é—®è¿‡çš„ç‚¹
                    }
                    cur_node = cur_node -&amp;gt;_next;
                }
            }
        }
    }
    cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;ç”¨æ•°ç»„æ¨¡æ‹Ÿé˜Ÿåˆ—&#34;&gt;ç”¨æ•°ç»„æ¨¡æ‹Ÿé˜Ÿåˆ—&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
//#include &amp;lt;queue&amp;gt;
using namespace std;
int myQ[10005], front, back;    //é˜Ÿåˆ—æ•°ç»„

struct Node{
    int _id;
    Node* _next;
    Node(int id, Node* next = NULL):_id(id), _next(next){}
};
struct Nodes{
    int _ele;
    Node* _next;
    Nodes():_ele(0), _next(NULL){}
    void insert(int id);
};

void Nodes::insert(int id){
    _next = new Node(id, _next);
    return ;
}

int main(){
    Nodes nodes[10005];
    //queue&amp;lt;int&amp;gt; myQ;
    int n, m;
    int v, u;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while(m--){
        cin &amp;gt;&amp;gt; v &amp;gt;&amp;gt; u;
        nodes[v].insert(u);
        nodes[u].insert(v);
    }
    for(int cur = 1; cur &amp;lt;= n; cur++){
        if(!nodes[cur]._ele){
            nodes[cur]._ele = 1;    //è¿›è¡Œæ ‡è®°
            front = back = 0;
            myQ[back++] = cur;

            int tmp;
            while(front &amp;lt; back){
                tmp = myQ[front++];

                Node* cur_node = nodes[tmp]._next;
                while(cur_node){
                    if(!nodes[cur_node-&amp;gt;_id]._ele){
                        //æœªæ”¾ç½®
                        nodes[cur_node-&amp;gt;_id]._ele = -nodes[tmp]._ele;
                        myQ[back++] = cur_node-&amp;gt;_id;
                    }
                    else if (nodes[cur_node-&amp;gt;_id]._ele == nodes[tmp]._ele){
                        //å·²æ”¾ç½®åŒè‰²
                        cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
                        return 0;
                    }
                    cur_node = cur_node -&amp;gt;_next;
                }
            }
        }
    }
    cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stlæ ‡å‡†æ¨¡æ¿åº“&#34;&gt;stlæ ‡å‡†æ¨¡æ¿åº“&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

struct Node{
    int _id;
    Node* _next;
    Node(int id, Node* next = NULL):_id(id), _next(next){}
};
struct Nodes{
    int _ele;
    Node* _next;
    Nodes():_ele(2), _next(NULL){}
    void insert(int id);
};

void Nodes::insert(int id){
    _next = new Node(id, _next);
    return ;
}

int main(){
    Nodes nodes[100];
    queue&amp;lt;int&amp;gt; myQ;
    int n, m;
    int v, u;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while(m--){
        cin &amp;gt;&amp;gt; v &amp;gt;&amp;gt; u;
        nodes[v].insert(u);
        nodes[u].insert(v);
    }

    int s = 1;
    int cur = s;
    do
        if(nodes[cur]._ele == 2){
            nodes[cur]._ele = (nodes[cur]._ele+1)%2;    //è¿›è¡Œæ ‡è®°
            myQ.push(cur);

            int tmp = cur;
            while(!myQ.empty()){
                tmp = myQ.front();
                myQ.pop();

                Node* cur_node = nodes[tmp]._next;
                while(cur_node){
                    if(nodes[cur_node-&amp;gt;_id]._ele == 2){
                        //æœªæ”¾ç½®
                        nodes[cur_node-&amp;gt;_id]._ele = (nodes[tmp]._ele+1)%2;
                        myQ.push(cur_node-&amp;gt;_id);
                    }
                    else if (nodes[cur_node-&amp;gt;_id]._ele == nodes[tmp]._ele){
                        //ä»¥æ”¾ç½®åŒè‰²
                        cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
                        return 0;
                    }

                    cur_node = cur_node -&amp;gt;_next;
                }
            }
        }
    while(s != (cur = (++cur%n)));
    cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ç»“æœåˆ†æ&#34;&gt;ç»“æœåˆ†æ&lt;/h2&gt;

&lt;p&gt;æœ€å¼€å§‹çš„ä»£ç ä½¿ç”¨çš„æ ‡å‡†æ¨¡æ¿åº“ä¸­çš„queueï¼Œä½†æ˜¯æäº¤å‘ç°ä¸èƒ½ç¼–è¯‘ï¼Œäºæ˜¯è‡ªå·±æ‰‹å†™äº†ä¸€ä¸ªé˜Ÿåˆ—è¿›è¡Œæäº¤ï¼Œä½†æ˜¯åªé€šè¿‡äº†7ä¸ªæµ‹è¯•ã€‚ç¬¬ä¸€ååº”æ˜¯è‡ªå·±çš„é˜Ÿåˆ—å†™é”™äº†ï¼Œä½†ç»è¿‡å¤šç»„æ•°æ®æµ‹è¯•ä¹‹åå‘ç°æ˜¯BFSè¿‡ç¨‹ä¸­å¯¹å·²ç»è®¿é—®è¿‡çš„ç‚¹è¿›è¡Œäº†å…¥é˜Ÿæ“ä½œã€‚æ”¹æ­£ä¹‹åæˆåŠŸæäº¤ã€‚ä¹‹åé¡ºä¾¿å†™äº†ç”¨æ•°ç»„æ¨¡æ‹Ÿé˜Ÿåˆ—çš„ä»£ç ï¼Œä¹ŸæˆåŠŸé€šè¿‡ã€‚&lt;/p&gt;

&lt;h2 id=&#34;æ€»ç»“ä½“ä¼š&#34;&gt;æ€»ç»“ä½“ä¼š&lt;/h2&gt;

&lt;p&gt;å®ç°é‚»æ¥è¡¨çš„æ—¶å€™å‘ç°è‡ªå·±å¯¹å›¾çš„æŒæ¡ç¨‹åº¦ç›¸å¯¹è¾ƒä½ï¼Œæ•´ä¸ªé€»è¾‘æƒ³äº†ä¸€ä¼šæ‰èƒ½ç”¨ä»£ç å†™å‡ºæ¥ã€‚è¿™ä¸ªç¨‹åºä¸€å¼€å§‹ä¿å­˜å›¾çš„æ—¶å€™è¿˜ä¿å­˜æˆäº†æœ‰å‘å›¾&amp;hellip;&lt;/p&gt;

&lt;p&gt;BFSæœç´¢ç­–ç•¥ä¹Ÿæ˜¯æœ€è¿‘æ‰æ¥è§¦ï¼Œæœ¬ä»¥ä¸ºä¸Šè¯¾çš„æ—¶å€™å·²ç»ç†è§£ï¼Œä½†è‡ªå·±çš„ä»£ç å†™å‡ºæ¥å°±æœ‰ä¸€äº›æ¼æ´ï¼Œè¿™ä¸æ˜¯ç»†èŠ‚å¤„ç†ä¸åˆ°ä½ï¼Œè€Œæ˜¯å¯¹è¿™ä¸ªæ¦‚å¿µç†è§£çš„è¿˜ä¸å¤Ÿæ¸…æ™°ï¼Œä¸ç„¶æ€ä¹ˆå†™éƒ½ä¸ä¼šå†™é”™ï¼Œå³ä½¿å†™é”™äº†ä¹Ÿèƒ½å¾ˆå¿«æ‰¾å‡ºæ¥ã€‚&lt;/p&gt;

&lt;p&gt;ç®—æ³•ä¸èƒ½åªåœåœ¨çº¸é¢ä¸Šï¼Œè¿˜è¦è½å®åˆ°ä»£ç ä¸­ã€‚ç»è¿‡äº†è¿™æ¬¡ç¼–ç¨‹ä»»åŠ¡ï¼Œæˆ‘è§‰å¾—æˆ‘å¯¹å›¾ã€å›¾æœç´¢ç›¸å…³çŸ¥è¯†çš„ç†è§£åˆåŠ æ·±äº†ä¸€äº›ã€‚ï¼ˆè‡³å°‘BFSè®°çš„æ›´æ¸…æ¥šäº†ğŸ™ƒ&lt;/p&gt;

&lt;p&gt;å¦å¤–æ„Ÿè§‰è¿™æ¬¡å†™çš„ä»£ç å¯è¯»æ€§ä¸æ˜¯å¾ˆé«˜ğŸ“Œ&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2019å¹´å±±ä¸œçœçœèµ›å›é¡¾</title>
      <link>https://wanakiki.github.io/2019/shengsai-2019/</link>
      <pubDate>Sun, 12 May 2019 23:24:12 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/shengsai-2019/</guid>
      <description>

&lt;p&gt;2019å¹´5æœˆ11-12å·å±±ä¸œçœACMç«èµ›å›é¡¾ï¼ˆæƒ³èµ·æ¥ä»€ä¹ˆå†™ä»€ä¹ˆï¼Œç»å¤§éƒ¨åˆ†å†…å®¹å’Œæ¯”èµ›å†…å®¹æ— å…³ï¼‰
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;ç¬¬ä¸€å¤©ä¸­åˆåˆ°æµå—å¤§å­¦ï¼Œå¼€å¹•å¼ä¹‹åå¼€å§‹çƒ­èº«èµ›ï¼ˆå¼€å¹•å¼ä¸Šé‚£ä¸ªå±±ä¸œå¤§å­¦çš„è€å¸ˆå†ä¸€æ¬¡æåˆ°äº†å±±å¤§å¤ºå† çš„é—®é¢˜ï¼‰ã€‚&lt;/p&gt;

&lt;h2 id=&#34;çƒ­èº«èµ›&#34;&gt;çƒ­èº«èµ›&lt;/h2&gt;

&lt;p&gt;ä»Šå¹´çš„æ“ä½œç¯å¢ƒæ˜¯64ä½win7ï¼Œé¢˜ç›®ç¼–è¯‘ç¯å¢ƒè¿˜æ˜¯Linuxã€‚ç”µè„‘ä¸Šé¢è‡ªå¸¦çš„IDEæ˜¯codeblockså’ŒDevC++ï¼Œæ¯”è¾ƒä»¤æˆ‘æ„å¤–çš„æ˜¯ï¼Œä»–ä»¬å±…ç„¶è¿˜æœ‰VSCodeã€‚åœ¨çƒ­èº«èµ›å¼€å§‹å‰ç¨å¾®é¼“æ£äº†ä¸€ä¸‹VSCodeï¼Œå‘ç°åªè£…äº†ä¸€ä¸ªC++é«˜äº®çš„æ’ä»¶ï¼Œä¹Ÿæ²¡æœ‰ç»™å¥½çš„debugé…ç½®æ–‡ä»¶ã€‚æˆ‘ä»¬é˜Ÿåªæœ‰æˆ‘å¹³æ—¶ç”¨VSCodeå†™ä»£ç ï¼Œä½†æˆ‘å‘ç°æˆ‘è¿˜æ˜¯ä¸ä¼šæ•´é…ç½®æ–‡ä»¶ï¼Œæ¯•ç«ŸåŸæ¥è‡ªå·±ç”¨çš„æ—¶å€™æŠ˜è…¾å¥½äº†ä¹‹åå°±ä¸€ç›´ç”¨ä¸‹å»ï¼Œå½“æ—¶ä¹Ÿæ˜¯åœ¨åˆ«äººæ–‡ä»¶çš„åŸºç¡€ä¸Šä¿®æ”¹çš„ï¼Œæœ‰æ—¶é—´çš„è¯ï¼Œè¿˜å¾—ç ”ç©¶ä¸€ä¸‹è¿™ä¸ªæ–‡ä»¶æ€ä¹ˆå†™ã€‚&lt;/p&gt;

&lt;p&gt;çƒ­èº«èµ›åªæœ‰å››ä¸ªé¢˜ï¼Œå‰ä¸‰ä¸ªéƒ½æ˜¯æŒºç®€å•çš„ï¼Œå¦‚æœæ—¥å¸¸æœ‰åˆ·é¢˜çš„è¯åº”è¯¥å¾ˆå¿«å°±èƒ½åšå‡ºæ¥ã€‚ä¸ºä»€ä¹ˆè¿™ä¹ˆè¯´å‘¢ï¼Œå› ä¸ºæˆ‘ä»¬å‘¨å›´çš„äººå¾ˆå¿«å°±æŠŠä¸‰ä¸ªé¢˜æå®šäº†ã€‚ä½†æ˜¯å¾ˆä¸å¹¸ï¼Œæˆ‘ä»¬åˆ°æœ€ååªåšå‡ºæ¥ä¸€ä¸ªï¼Œå¥½æ…Œå•Šã€‚&lt;br /&gt;
ç¬¬ä¸€é¢˜æ˜¯ç­¾åˆ°é¢˜ï¼Œå¾ˆç®€å•ï¼Œç¬¬äºŒé¢˜æˆ‘ä»¬çœ‹ä¸æ‡‚é¢˜ç›®ï¼ˆä¹ˆçš„è¯å…¸ï¼‰ï¼Œç¬¬ä¸‰é¢˜æ˜¯å½“åˆæ ¡é€‰å‡ºçš„é¢˜ï¼Œæˆ‘ä»¬ä¹Ÿæ²¡æœ‰è¡¥ğŸ˜”ã€‚æ€»ä¹‹åˆ°æœ€åå°±å¾ˆå°´å°¬çš„èµ°å‡ºå»äº†ã€‚&lt;/p&gt;

&lt;p&gt;çƒ­èº«èµ›ç»™äººå°è±¡æœ€æ·±åˆ»çš„æ˜¯æœ€åä¸€ä¸ªé¢˜ç›®ï¼Œè®©æˆ‘ä»¬è®¤å‡º21ä¸ªäºŒæ¬¡å…ƒè§’è‰²ï¼Œå¹¶è¾“å‡ºé¢˜ç›®è¦çš„é‚£å‡ ä¸ªã€‚æ²¡æœ‰ç®—æ³•ï¼Œåªè¦ä½ å¤Ÿæ­»å®…å°±å¯ä»¥äº†ï¼&lt;/p&gt;

&lt;h2 id=&#34;æ­£å¼èµ›&#34;&gt;æ­£å¼èµ›&lt;/h2&gt;

&lt;p&gt;è¿™æ¬¡æ¯”èµ›é¢˜ç›®æ¯”å»å¹´å¤šï¼Œä¸€å…±æœ‰åä¸‰é“ï¼Œè™½ç„¶é¢˜ç›®å˜å¤šï¼Œä½†æ˜¯ç»å¤§éƒ¨åˆ†äººèƒ½åšå‡ºæ¥çš„åªæœ‰äº”é“ï¼Œæˆ‘ä»¬å°±æ˜¯&amp;hellip;å¦‚æœèƒ½å…­é“å°±æ˜¯é“¶ç‰Œã€‚&lt;/p&gt;

&lt;p&gt;æœ€åä¸€é¢˜å¸¦äº†ä¹‹ç‹¼çš„å›¾ç‰‡ï¼Œæˆ‘å…ˆçœ‹çš„è¿™ä¸ªï¼Œæ˜¯ä¸€é“ç®€å•çš„ç­¾åˆ°ï¼Œæ²¡æœ‰å¾ˆéš¾çš„ç‚¹ï¼Œåªè¦æ³¨æ„ä¸€ç‚¹ä¼˜åŒ–å°±å¯ä»¥ã€‚ç¬¬ä¸€å‘WAäº†ï¼Œzzcæé†’äº†ä¸€ä¸‹æ”¹äº†æ”¹å°±è¿‡äº†ã€‚æ•´ä¸ªè¿‡ç¨‹å°±æ‰“äº†è¿™ä¸€ä¸ªé¢˜ã€‚&lt;/p&gt;

&lt;p&gt;djræ‰“äº†æˆ‘ä»¬å‰©ä¸‹çš„å››ä¸ªé¢˜ï¼ŒAé¢˜æ—¥å†ï¼Œä»–çœ‹äº†ä¹‹åç›´æ¥æ‰“äº†ï¼Œæ¥ç€å»åšçš„çŸ³å¤´ï¼Œä¸¤ä¸ªé¢˜éƒ½WAäº†ä¸€æ¬¡ï¼Œå‰©ä¸‹çš„ä¸¤ä¸ªäººå¸®å¿™æ”¹äº†æ”¹å°±è¿‡äº†ã€‚zzcè¯´å›¾æ¯”è¾ƒç®€å•ï¼Œæ‰€ä»¥ä»–ä»¬å°±ç›´æ¥å¼€çš„é‚£ä¸ªï¼Œè¿™ä¸ªæ—¶å€™æˆ‘çœ‹çš„æœºå™¨äººã€‚å›¾ä¹Ÿæ˜¯é”™äº†å‡ æ¬¡æ‰æ”¹å‡ºæ¥ï¼Œç„¶åzzcå’Œæˆ‘ç ”ç©¶æœºå™¨äººçš„è§£æ³•ï¼Œè®©ä»–å®ç°çš„æ—¶å€™ä»£ç å‡ºç°äº†å¾ˆå¤§çš„æ¼æ´ï¼Œå•†é‡ä¹‹åæ¢djräº¤äº†ã€‚&lt;/p&gt;

&lt;p&gt;å‰©ä¸‹çš„ä¸¤ä¸ªå°æ—¶ï¼Œæˆ‘ä»¬å°±ä¸€ç›´ç ”ç©¶å…¶ä»–é¢˜ç›®ï¼Œæˆ‘èŠ±äº†å¾ˆä¹…çš„æ—¶é—´çœ‹Hï¼Œä½†æ˜¯åˆ°æœ€åè¿˜æ˜¯æ²¡æå®šï¼Œè€Œä¸”ä¸­é—´è¿˜æœ‰çŸ­æ—¶é—´æœ‰æƒ³æ³•å†™ä¸å‡ºæ¥ï¼Œå¤ªåƒåœ¾äº†ã€‚æ•´ä¸ªæ¯”èµ›çš„æ—¶å€™å˜æˆäº†å–·å–·æ€ªï¼ŒæŠŠåæ²«å–·åˆ°åˆ«äººèº«ä¸Šå¥½å‡ æ¬¡ï¼Œæˆ‘ä½›äº†ğŸ™ƒ&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/shengsai/20190513000941.png&#34; alt=&#34;final&#34; /&gt;&lt;/p&gt;

&lt;p&gt;æœ€ç»ˆçš„ç»“æœæ˜¯é“œï¼Œè¿™æ˜¯é¢˜ç›®çš„é“¾æ¥ï¼Œä¸çŸ¥é“ä»€ä¹ˆæ—¶å€™æ‰èƒ½è¡¥ä¸€ä¸‹ã€‚&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://vjudge.net/problem#OJId=ZOJ&amp;amp;probNum=&amp;amp;title=&amp;amp;source=The%2010th%20Shandong&amp;amp;category=all?tdsourcetag=s_pctim_aiomsg&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://vjudge.net/problem#OJId=ZOJ&amp;amp;probNum=&amp;amp;title=&amp;amp;source=The%2010th%20Shandong&amp;amp;category=all?tdsourcetag=s_pctim_aiomsg&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;others&#34;&gt;Others&lt;/h2&gt;

&lt;p&gt;ç¬¬ä¸€å¤©æ™šä¸Šæ²¡æœ‰å‡ºå»ï¼Œä¸€ç›´åœ¨æ—…é¦†å‘†ç€äº†ï¼Œå¾ˆæ— èŠï¼ŒæŠŠå¥‡å¼‚äººç”Ÿæœ€åä¸€ç« çš„å¤§éƒ¨åˆ†çœ‹å®Œäº†ï¼Œå‰©ä¸‹çš„ä¸€ç‚¹åœ¨å›æ¥çš„è½¦ä¸Šçœ‹å®Œçš„ã€‚æˆ‘è¿˜ä»¥ä¸ºé‚£ä¸ªç”·ç”Ÿæ˜¯çœŸå¿ƒå¯¹æ­Œéœ²å°”å¥½çš„ï¼Œæ²¡æƒ³åˆ°è¿˜çœŸå°±æ˜¯å’Œæ—¥è®°é‡Œé¢å†™çš„é‚£æ ·ï¼Œå°±åªæ˜¯æƒ³æ³¡å¥¹ï¼&lt;/p&gt;

&lt;p&gt;å› ä¸ºçƒ­èº«èµ›æœ‰ä¸€é“é¢˜æä¸æ¸…è‡ªå·±çš„ç®—æ³•é”™åœ¨å“ªäº†ï¼Œæ‰€ä»¥æ™šä¸Šè¿˜æŠ˜è…¾äº†ä¸€æ®µæ—¶é—´çš„å¯¹æ‹ã€‚ç”¨Termuxå†™çš„ï¼Œä¸ä¼šshellæ‰€ä»¥ä½¿ç”¨çš„pythonï¼ŒåŸºæœ¬èƒ½è·‘ç¨‹åºäº†ï¼Œä½†æ˜¯è¿˜éœ€è¦ç¨å¾®æ•´åˆä¸€ä¸‹ã€‚&lt;/p&gt;

&lt;p&gt;çœèµ›é‡‘ç‰Œä¼šå‘å®ä¹ offerï¼Œæˆ‘è§‰å¾—å­¦å¼Ÿå­¦å¦¹ä»¬éœ€è¦çš„è¯å¯ä»¥å¾€è¿™ä¸ªæ–¹å‘ç¨å¾®ç”¨ç‚¹åŠ›ï¼Œå½“ç„¶æˆ‘ä¹Ÿä¸€æ ·ğŸ˜‚&lt;/p&gt;

&lt;p&gt;æœ€åçš„æ¯”èµ›å† å†›æ˜¯çƒŸå°å¤§å­¦ï¼Œå±±ä¸œå¤§å­¦å äº†äºŒä¸‰åğŸ¤”&lt;/p&gt;

&lt;p&gt;æœ€åæ¥çš„æ—¶å€™åˆ®èµ·äº†å¤§é£ï¼Œä¸€ä¸Šè½¦å°±å¼€å§‹ä¸‹é›¨äº†ï¼Œå»ä¸Šè½¦çš„è·¯ä¸Šæ²™å­çœ¯çœ¼äº†å¥½å‡ æ¬¡ğŸ˜’ï¼Œè¿™æ„Ÿè§‰ï¼Œçš„ç¡®æŒºäº²åˆ‡çš„&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>æ•°æ®ç»“æ„ä½œä¸šå…­ æ—…è¡Œå•†ï¼ˆTSPï¼‰</title>
      <link>https://wanakiki.github.io/2019/tsp/</link>
      <pubDate>Tue, 07 May 2019 23:55:50 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/tsp/</guid>
      <description>

&lt;p&gt;å›¾è®ºç¬¬ä¸€æ¬¡ä½œä¸šï¼Œä¸éœ€è¦æäº¤æŠ¥å‘Šï¼Œåœ¨OJä¸Šæäº¤ã€‚&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;æè¿°&#34;&gt;æè¿°&lt;/h2&gt;

&lt;p&gt;Shrekæ˜¯ä¸€ä¸ªå¤§å±±é‡Œçš„é‚®é€’å‘˜ï¼Œæ¯å¤©è´Ÿè´£ç»™æ‰€åœ¨åœ°åŒºçš„nä¸ªæ‘åº„æ´¾å‘ä¿¡ä»¶ã€‚ä½†æ¯å…·çš„æ˜¯ï¼Œç”±äºé“è·¯ç‹­çª„ï¼Œå¹´ä¹…å¤±ä¿®ï¼Œæ‘åº„é—´çš„é“è·¯éƒ½åªèƒ½å•å‘é€šè¿‡ï¼Œç”šè‡³æœ‰äº›æ‘åº„æ— æ³•ä»ä»»æ„ä¸€ä¸ªæ‘åº„åˆ°è¾¾ã€‚è¿™æ ·æˆ‘ä»¬åªèƒ½å¸Œæœ›å°½å¯èƒ½å¤šçš„æ‘åº„å¯ä»¥æ”¶åˆ°æŠ•é€’çš„ä¿¡ä»¶ã€‚&lt;/p&gt;

&lt;p&gt;Shrekå¸Œæœ›çŸ¥é“å¦‚ä½•é€‰å®šä¸€ä¸ªæ‘åº„Aä½œä¸ºèµ·ç‚¹ï¼ˆæˆ‘ä»¬å°†ä»–ç©ºæŠ•åˆ°è¯¥æ‘åº„ï¼‰ï¼Œä¾æ¬¡ç»è¿‡å°½å¯èƒ½å¤šçš„æ‘åº„ï¼Œè·¯é€”ä¸­çš„æ¯ä¸ªæ‘åº„éƒ½ç»è¿‡ä»…ä¸€æ¬¡ï¼Œæœ€ç»ˆåˆ°è¾¾ç»ˆç‚¹æ‘åº„Bï¼Œå®Œæˆæ•´ä¸ªé€ä¿¡è¿‡ç¨‹ã€‚è¿™ä¸ªä»»åŠ¡äº¤ç»™ä½ æ¥å®Œæˆã€‚&lt;/p&gt;

&lt;h3 id=&#34;è¾“å…¥&#34;&gt;è¾“å…¥&lt;/h3&gt;

&lt;p&gt;ç¬¬ä¸€è¡ŒåŒ…æ‹¬ä¸¤ä¸ªæ•´æ•°nï¼Œmï¼Œåˆ†åˆ«è¡¨ç¤ºæ‘åº„çš„ä¸ªæ•°ä»¥åŠå¯ä»¥é€šè¡Œçš„é“è·¯çš„æ•°ç›®ã€‚&lt;/p&gt;

&lt;p&gt;ä»¥ä¸‹å…±mè¡Œï¼Œæ¯è¡Œç”¨ä¸¤ä¸ªæ•´æ•°v1å’Œv2è¡¨ç¤ºä¸€æ¡é“è·¯ï¼Œä¸¤ä¸ªæ•´æ•°åˆ†åˆ«ä¸ºé“è·¯è¿æ¥çš„æ‘åº„å·ï¼Œé“è·¯çš„æ–¹å‘ä¸ºä»v1è‡³v2ï¼Œnä¸ªæ‘åº„ç¼–å·ä¸º[1, n]ã€‚&lt;/p&gt;

&lt;p&gt;1 â‰¤ n â‰¤ 1,000,000&lt;/p&gt;

&lt;p&gt;0 â‰¤ m â‰¤ 1,000,000&lt;/p&gt;

&lt;p&gt;è¾“å…¥ä¿è¯é“è·¯ä¹‹é—´æ²¡æœ‰å½¢æˆç¯&lt;/p&gt;

&lt;h3 id=&#34;è¾“å‡º&#34;&gt;è¾“å‡º&lt;/h3&gt;

&lt;p&gt;è¾“å‡ºä¸€ä¸ªæ•°å­—ï¼Œè¡¨ç¤ºç¬¦åˆæ¡ä»¶çš„æœ€é•¿é“è·¯ç»è¿‡çš„æ‘åº„æ•°ã€‚&lt;/p&gt;

&lt;h3 id=&#34;è¾“å…¥æ ·ä¾‹-1&#34;&gt;è¾“å…¥æ ·ä¾‹ 1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;4 3
1 4
2 4
4 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;è¾“å‡ºæ ·ä¾‹-1&#34;&gt;è¾“å‡ºæ ·ä¾‹ 1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ä»£ç &#34;&gt;ä»£ç &lt;/h2&gt;

&lt;p&gt;å…ˆè¿›æ€§æ‹“æ‰‘æ’åºï¼Œä¹‹ådpæ‰¾åˆ°æœ€å¤§å€¼ã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;
#define myMax(x,y) ((x) &amp;gt; (y) ? (x) : (y))
int inDeg[1000005] = {0};   //å…¥åº¦ ç”¨äºæ‹“æ‰‘æ’åº
int tpSorted[1000005] = {0};    //æ‹“æ‰‘æ’åºçš„é¡ºåº

//å•ä¸ªæ‘åº„
struct village{
    int id;
    village * next_village;
    village(int _id, village* next = NULL):id(_id),next_village(next){}
};

struct villages{
    village* _next;
    int dp; //ç›´æ¥å†™å…¥å±æ€§
    villages():_next(NULL), dp(1){}
    void add(int next_id);
}Villages[1000005];

void villages::add(int next_id){
    inDeg[next_id] ++;
    if(!_next){
        _next = new village(next_id);
    }
    else{
        _next = new village(next_id, _next);
    }
}

//å…¨å±€å˜é‡çœŸå¥½ç”¨...
int topologicalSort(int n){
    int res = 0;    //è®°å½•æœ€å¤§å€¼
    int size = 0;   //æ‹“æ‰‘æ•°ç»„é•¿åº¦
    for(int i = 1; i &amp;lt;= n; i++)
        if(!inDeg[i])
            tpSorted[size++] = i;
    
    //å¯¹æ•°ç»„è¿›è¡Œæ“ä½œ
    for(int i = 0; i &amp;lt; size; i++){
        village* cur = Villages[tpSorted[i]]._next;
        while(cur){
            Villages[cur-&amp;gt;id].dp = myMax(Villages[tpSorted[i]].dp+1, Villages[cur-&amp;gt;id].dp);
            res = myMax(Villages[cur-&amp;gt;id].dp, res);

            inDeg[cur-&amp;gt;id]--;
            if(!inDeg[cur-&amp;gt;id])
                tpSorted[size++] = cur-&amp;gt;id;
            cur = cur-&amp;gt;next_village;
        }
    }
    return res;
}
int main(){
    int n, m, v1, v2;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while(m--){
        cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;
        Villages[v1].add(v2);        
    }
    cout &amp;lt;&amp;lt; topologicalSort(n) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>æ•°æ®ç»“æ„ä½œä¸šå›› è¡¨è¾¾å¼æ ‘</title>
      <link>https://wanakiki.github.io/2019/bin-tree/</link>
      <pubDate>Fri, 03 May 2019 18:56:50 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/bin-tree/</guid>
      <description>

&lt;p&gt;ä»ä¸­ç¼€è¡¨è¾¾å¼æ„å»ºäºŒå‰æ ‘
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190146.jpg&#34; alt=&#34;é¢˜ç›®è¦æ±‚&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;é—®é¢˜åˆ†æ-è§£å†³æ–¹æ¡ˆ&#34;&gt;é—®é¢˜åˆ†æ &amp;amp; è§£å†³æ–¹æ¡ˆ&lt;/h2&gt;

&lt;p&gt;é¢˜ç›®è¦æ±‚è¾“å…¥ä¸€ä¸ªä¸­ç¼€è¡¨è¾¾å¼ï¼Œæ„å»ºå…¶ç›¸åº”çš„è¡¨è¾¾å¼æ ‘ï¼Œå¹¶è¾“å‡ºéªŒè¯ã€‚&lt;/p&gt;

&lt;p&gt;è¡¨è¾¾å¼æ ‘çš„ç‰¹ç‚¹æ˜¯æ“ä½œç¬¦æ‰€å¯¹åº”çš„ä¸¤ä¸ªæ“ä½œæ•°åˆ†åˆ«å¯¹åº”äºæ“ä½œç¬¦çš„å·¦å­©å­å’Œå³å­©å­ã€‚ç›´æ¥ä»ä¸­ç¼€è¡¨è¾¾å¼æ„å»ºç›¸å¯¹å›°éš¾ï¼Œè€ƒè™‘æ­¤å‰å·²ç»æœ‰è¿‡ä»ä¸­ç¼€è¡¨è¾¾å¼æ„å»ºåç¼€è¡¨è¾¾å¼çš„ç»éªŒï¼Œä»¥åŠåç¼€è¡¨è¾¾å¼è¿ç®—ç¬¦ä½äºæ“ä½œæ•°ä¹‹åçš„ç‰¹ç‚¹ï¼Œå¯ä»¥ä»åç¼€è¡¨è¾¾å¼å…¥æ‰‹è§£å†³è¯¥é—®é¢˜ã€‚&lt;/p&gt;

&lt;p&gt;é€šè¿‡å¯¹è¡¨è¾¾å¼æ ‘å’Œåç¼€è¡¨è¾¾å¼çš„è§‚å¯Ÿä¸éš¾å¾—å‡ºå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹æ³•ä»åç¼€è¡¨è¾¾å¼å¾—åˆ°è¡¨è¾¾å¼æ ‘ï¼šåç¼€è¡¨è¾¾å¼è‡ªåå‘å‰éå†ï¼Œåœ¨å³èŠ‚ç‚¹ä¼˜å…ˆçº§é«˜äºå·¦èŠ‚ç‚¹çš„å‰æä¸‹æ ¹æ®å½“å‰éå†å…ƒç´ ç±»å‹è¿›è¡Œä»¥ä¸‹ä¸¤ç§æ“ä½œï¼š&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;å½“å‰å…ƒç´ ä¸ºè¿ç®—ç¬¦ï¼Œå°†è¿ç®—ç¬¦æ„å»ºä¸ºæ ‘çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè‹¥ä¸ºå³å­©å­åˆ™å°†æ“ä½œèŠ‚ç‚¹å‹æ ˆã€‚æ— è®ºæ˜¯å·¦å­©å­è¿˜æ˜¯å³å­©å­ï¼Œä¹‹åæ“ä½œèŠ‚ç‚¹è½¬ç§»åˆ°æ–°å»ºèŠ‚ç‚¹ã€‚&lt;/li&gt;
&lt;li&gt;å½“å‰å…ƒç´ ä¸ºæ“ä½œæ•°ï¼Œå°†è¿ç®—ç¬¦æ„å»ºä¸ºæ ‘çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè‹¥ä¸ºå·¦å­©å­åˆ™æ“ä½œèŠ‚ç‚¹è½¬ç§»åˆ°æ ˆé¡¶èŠ‚ç‚¹ï¼Œæ ˆå¼¹å‡ºã€‚&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;æœ€ç»ˆè§£å†³æ–¹æ¡ˆä¸ºï¼šå°†è¾“å…¥çš„ä¸­ç¼€è¡¨è¾¾å¼è½¬åŒ–ä¸ºåç¼€è¡¨è¾¾å¼ï¼Œå†æŒ‰ç…§ä¸Šè¿°è§„åˆ™æ„å»ºæ•´ä¸ªè¡¨è¾¾å¼æ ‘ã€‚åŒæ—¶è¿˜è¦æ³¨æ„æœ€ç»ˆæ ‘å½¢çš„è¾“å‡ºã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç®—æ³•è®¾è®¡&#34;&gt;ç®—æ³•è®¾è®¡&lt;/h2&gt;

&lt;p&gt;å‚ç…§è¯¾æœ¬ï¼Œæ„å»ºèŠ‚ç‚¹ç±»ã€äºŒå‰æ ‘ç±»ï¼Œå¹¶å¯¹å…¶ä¸­çš„ç›¸å…³å‡½æ•°è¿›è¡Œå®ç°ï¼Œå¦å¤–å‡†å¤‡ä¸€ä¸ªå‡½æ•°å°†ä¸­ç¼€è¡¨è¾¾å¼æ„å»ºä¸ºåç¼€è¡¨è¾¾å¼ï¼Œå¹¶è¿›è¡Œæ ‘çš„æ„å»ºã€‚&lt;/p&gt;

&lt;p&gt;è¯¾æœ¬ä¸­å¹¶æ²¡æœ‰èŠ‚ç‚¹æ·±åº¦è¿™ä¸ªå±æ€§ï¼Œä½†ç»ˆç«¯è¾“å‡ºæ—¶èŠ‚ç‚¹å¦‚æœå…·æœ‰æ·±åº¦å±æ€§ä¼šéå¸¸æ–¹ä¾¿ï¼Œäºæ˜¯å¯¹å…¶è¿›è¡Œäº†è¡¥å……ï¼Œå¹¶æ·»åŠ äº†ç›¸å…³çš„å‡½æ•°å¯¹èŠ‚ç‚¹çš„æ·±åº¦è¿›è¡Œæ›´æ–°ï¼Œä¸é«˜åº¦æ›´æ–°ä¸€è‡´è°ƒç”¨ã€‚è¿™é‡Œéœ€è¦æ³¨æ„ï¼Œé«˜åº¦çš„æ›´æ–°æ˜¯è‡ªä¸‹å‘ä¸Šï¼Œæ·±åº¦çš„æ›´æ–°åˆ™æ˜¯è‡ªä¸Šè€Œä¸‹ï¼Œéœ€è¦ä¸€ä¸ªéå†çš„è¿‡ç¨‹ï¼Œæˆ‘åœ¨å…·ä½“å®ç°çš„è¿‡ç¨‹ä¸­é‡‡ç”¨äº†å±‚éå†çš„æ–¹å¼ã€‚&lt;/p&gt;

&lt;h3 id=&#34;ç»ˆç«¯è¾“å‡ºçš„æ€è€ƒ&#34;&gt;ç»ˆç«¯è¾“å‡ºçš„æ€è€ƒ&lt;/h3&gt;

&lt;p&gt;å¦‚ä½•åœ¨ç»ˆç«¯ä¸­è¾“å‡ºæ˜¯ä¸€ä¸ªæ¯”è¾ƒå›°éš¾çš„é—®é¢˜ã€‚å› ä¸ºç»ˆç«¯è¾“å‡ºä¸€è¡Œåä¸èƒ½å›é€€åˆ°ä¸Šä¸€è¡Œï¼Œå¦‚æœä¸å¯¹å„ä¸ªå…ƒç´ æå‰ä¿å­˜ï¼Œå°±è¦åœ¨éå†çš„æ—¶å€™è¿›è¡Œä¸€äº›å°æ“ä½œã€‚åŒæ—¶è¾“å‡ºæ—¶ç©ºæ ¼çš„æ§åˆ¶ä¹Ÿéœ€è¦ç»†èŠ‚å¤„ç†ã€‚åœ¨è¿™é‡Œç®€å•ä»‹ç»ä¸€ä¸‹æˆ‘çš„åšæ³•ã€‚&lt;/p&gt;

&lt;p&gt;æˆ‘é‡‡ç”¨çš„æ–¹æ³•æ˜¯ä½¿ç”¨å±‚éå†çš„æ–¹æ³•ï¼ŒåŒæ—¶ä¸ºæ¯ä¸€ä¸ªèŠ‚ç‚¹å¢åŠ æ¨ªåæ ‡ï¼Œéå†èŠ‚ç‚¹çš„åŒæ—¶æ›´æ–°èŠ‚ç‚¹çš„æ¨ªåæ ‡ï¼Œæ ¹æ®æ¨ªåæ ‡å’Œæ·±åº¦çš„æƒ…å†µåˆ¤æ–­æ˜¯å¦éœ€è¦æ¢è¡Œå’Œéœ€è¦è¾“å‡ºç©ºæ ¼çš„æ•°é‡ã€‚ä¼´éšç€äºŒå‰æ ‘æ·±åº¦çš„å¢åŠ ï¼Œæ¯å±‚çš„èŠ‚ç‚¹å‘ˆæŒ‡æ•°çº§å¢é•¿ï¼Œå¦‚æœä¸€å¼€å§‹è¾“å‡ºçš„èŠ‚ç‚¹ä¹‹é—´çš„é—´éš”æ§åˆ¶çš„ä¸å¥½ï¼Œåç»­çš„è¾“å‡ºå°±ä¼šå˜å¾—å›°éš¾ã€‚&lt;/p&gt;

&lt;p&gt;é«˜åº¦ä¸ºnçš„æ»¡äºŒå‰æ ‘ï¼Œæœ€åº•å±‚æœ‰2^nä¸ªèŠ‚ç‚¹ï¼Œè€ƒè™‘åˆ°åº•å±‚èŠ‚ç‚¹ä¸èƒ½ç›´æ¥ç›¸é‚»ï¼ˆè‡³å°‘éš”ä¸€ä¸ªç©ºæ ¼ï¼‰ï¼Œæ‰€ä»¥æœ€åº•å±‚æ‰€å å­—ç¬¦æ€»é•¿ä¸º2^(n+1)ä¸ªã€‚ç°å‡è®¾æˆ‘ä»¬æŒ‰ç…§æ»¡äºŒå‰æ ‘çš„å½¢å¼å¯¹æ•´ä¸ªæ ‘è¿›è¡Œè¾“å‡ºï¼Œè¾“å‡ºåŒºåŸŸä¸ºé•¿ä¸º2^(n+1)ä¸ªå­—ç¬¦ï¼Œé«˜ä¸ºnè¡Œçš„çŸ©å½¢ï¼Œæ ¹èŠ‚ç‚¹ä½äºæ•´ä¸ªå›¾å½¢çš„å¯¹ç§°è½´ä¸Šï¼Œæ•…æ ¹èŠ‚ç‚¹çš„æ¨ªåæ ‡ä¸º2^nï¼ŒåŒç†å¯æ¨å¾—æ ¹èŠ‚ç‚¹çš„å·¦å­©å­çš„æ¨ªåæ ‡ä¸º2^(n-1)ã€‚è€ƒè™‘åˆ°åœ¨æ»¡äºŒå‰æ ‘çš„æƒ…å†µä¸‹æ¯å±‚èŠ‚ç‚¹ä¹‹é—´çš„é—´éš”æ˜¯ä¸€å®šå€¼ï¼Œä¸”ä¸ºè¯¥å±‚æœ€å·¦ä¾§èŠ‚ç‚¹çš„æ¨ªåæ ‡ï¼Œæ•…åœ¨å·²çŸ¥ä¸€ä¸ªèŠ‚ç‚¹çš„æ¨ªåæ ‡åŠä¸‹ä¸€å±‚çš„å›ºå®šèŠ‚ç‚¹é—´éš”çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥æ›´æ–°å‡ºè¯¥èŠ‚ç‚¹ä¸¤ä¸ªå­©å­çš„æ¨ªåæ ‡ã€‚&lt;/p&gt;

&lt;p&gt;æŒ‰ç…§ä¸Šè¿°æ–¹æ³•åœ¨è¿›è¡Œå±‚éå†çš„åŒæ—¶å¯¹èŠ‚ç‚¹æ¨ªåæ ‡è¿›è¡Œæ›´æ–°ï¼Œè®°å½•ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„æ¨ªåæ ‡ï¼Œå³ä½¿äºŒå‰æ ‘ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘ä¹Ÿèƒ½å¤Ÿæ­£å¸¸è¾“å‡ºå½¢çŠ¶ã€‚å½“ç„¶ï¼Œå› ä¸ºç»ˆç«¯çš„å®½åº¦ä¸€å®šï¼Œå½“å±‚æ•°å¤§åˆ°æœ€åä¸€æ’æ— æ³•æ˜¾ç¤ºçš„æ—¶å€™å½¢çŠ¶ä¸€å®šä¼šå‘ç”Ÿæ”¹å˜ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190620.png&#34; alt=&#34;ç»“æ„ç¤ºæ„&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;æµç¨‹å›¾&#34;&gt;æµç¨‹å›¾&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190145.jpg&#34; alt=&#34;ä¸­ç¼€è¡¨è¾¾å¼å˜ä¸ºé€†æ³¢å…°è¡¨è¾¾å¼&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190144.jpg&#34; alt=&#34;ä»é€†æ³¢å…°è¡¨è¾¾å¼æ„å»ºæ ‘&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ç¼–ç¨‹å®ç°&#34;&gt;ç¼–ç¨‹å®ç°&lt;/h2&gt;

&lt;p&gt;å…±ç¼–å†™äº†ä¸‰ä¸ªæ–‡ä»¶ï¼šnode.hã€Bintree.hã€main.cpp&lt;/p&gt;

&lt;p&gt;1.node.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define stature(p) ((p) ? (p)-&amp;gt;height : -1)

//èŠ‚ç‚¹æŒ‡é’ˆçš„åˆ¤æ–­
#define IsLc(x) ((x)-&amp;gt;parent &amp;amp;&amp;amp; ((x) == (x)-&amp;gt;parent-&amp;gt;l_c))
#define IsRc(x) ((x)-&amp;gt;parent &amp;amp;&amp;amp; ((x) == (x)-&amp;gt;parent-&amp;gt;r_c))

#include &amp;lt;iostream&amp;gt;
using namespace std;
//NULL åœ¨ä½•å¤„å®šä¹‰ï¼Ÿ

template &amp;lt;typename T&amp;gt;
struct node{
    T data;
    node&amp;lt;T&amp;gt;* parent;
    node&amp;lt;T&amp;gt;* l_c;
    node&amp;lt;T&amp;gt;* r_c;
    int height;
    int axis;  //æ‰“å°æ—¶ç©ºæ ¼
    int depth;  //æ·±åº¦éå¸¸é‡è¦ï¼
    
    //æ„é€ å‡½æ•°
    node():parent(NULL), l_c(NULL), r_c(NULL), height(0), axis(0), depth(0){}
    node(T e, node&amp;lt;T&amp;gt;* p=NULL, node&amp;lt;T&amp;gt;* lc=NULL, node&amp;lt;T&amp;gt;* rc = NULL, int h=0):data(e),parent(p),l_c(lc),r_c(rc),height(h),axis(0),depth(0){}

    node&amp;lt;T&amp;gt;* insertLc(T const&amp;amp;);
    node&amp;lt;T&amp;gt;* insertRc(T const&amp;amp;);
};

//ä¸¤ä¸ªæ’å…¥çš„å®ç°
template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* node&amp;lt;T&amp;gt;::insertLc(T const&amp;amp; e){
    return l_c = new node(e, this);
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* node&amp;lt;T&amp;gt;::insertRc(T const&amp;amp; e){
    return r_c = new node(e, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.bintree.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;node.h&amp;quot;
#include &amp;lt;queue&amp;gt;

template &amp;lt;typename T&amp;gt;
class Bintree{
    node&amp;lt;T&amp;gt;* _root;
    int _size;

public:
    //æ„é€ 
    Bintree():_root(NULL),_size(0){}

    //æ›´æ–°é«˜åº¦ã€æ·±åº¦
    void updateHight(node&amp;lt;T&amp;gt; *x);
    void updateDepth(node&amp;lt;T&amp;gt;* x);
    void updateHD(node&amp;lt;T&amp;gt; *x);

    //èŠ‚ç‚¹æ’å…¥e
    node&amp;lt;T&amp;gt;* insertAsRoot (T const&amp;amp; e);
    node&amp;lt;T&amp;gt;* insertAsLc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e);
    node&amp;lt;T&amp;gt;* insertAsRc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e); 

    //è·å¾—èŠ‚ç‚¹æŒ‡é’ˆ
    node&amp;lt;T&amp;gt;* getRoot();
    // node&amp;lt;T&amp;gt;* getLc(node&amp;lt;T&amp;gt;* x);
    // node&amp;lt;T&amp;gt;* getRc(node&amp;lt;T&amp;gt;* x);
    //ä¸Šé¢è¿™ä¸¤ä¸ªæ²¡æœ‰ç”¨äº†....

    //å¤§å°
    int size(){ return _size;}

    //è¡¨è¾¾
    void treeShow();

    // void createBlank(int n);
};



template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::updateHight(node&amp;lt;T&amp;gt;* x){
    x-&amp;gt;height = 1 + (stature(x-&amp;gt;l_c) &amp;gt; stature(x-&amp;gt;r_c) ? stature(x-&amp;gt;l_c) : stature(x-&amp;gt;r_c));
}

template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::updateDepth(node&amp;lt;T&amp;gt;* x){
    if(x == _root)  return;
    x-&amp;gt;depth = 1 + x-&amp;gt;parent-&amp;gt;depth;
    
}
template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::updateHD(node&amp;lt;T&amp;gt;* x){
    node&amp;lt;T&amp;gt;* y = x;
    while(x){
        updateHight(x);
        x = x-&amp;gt;parent;
    }
    queue&amp;lt; node&amp;lt;T&amp;gt;* &amp;gt; tmp;
    if(y){
        tmp.push(y);
        while(!tmp.empty()){
            updateDepth(tmp.front());
            if(tmp.front()-&amp;gt;l_c)
                tmp.push(tmp.front()-&amp;gt;l_c);
            if(tmp.front()-&amp;gt;r_c)
                tmp.push(tmp.front()-&amp;gt;r_c);
            tmp.pop();
        }
    }
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::insertAsRoot(T const&amp;amp; e){
    _size = 1;
    return _root = new node&amp;lt;T&amp;gt;(e);
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::insertAsLc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e){
    _size++;
    x-&amp;gt;insertLc(e);
    updateHD(x);
    return x-&amp;gt;l_c;
}   

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::insertAsRc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e){
    _size++;
    x-&amp;gt;insertRc(e);
    updateHD(x);
    return x-&amp;gt;r_c;
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::getRoot(){
    return _root;
}

template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::treeShow(){
    int num = 1;
    int  n = _root-&amp;gt;height;  //è·å¾—é«˜åº¦
    while(n--){ num *= 2;}

    //å±‚éå†
    queue&amp;lt; node&amp;lt;T&amp;gt;* &amp;gt; tmp;
    node&amp;lt;T&amp;gt;* curr;
    int last_axis = 0, last_depth = 0;
    if(_root)
        tmp.push(_root);
    while(!tmp.empty()){
        // if(last != tmp.front()-&amp;gt;parent){
        //     num /=2;
        //     cout &amp;lt;&amp;lt; endl;
        //     for(int i = 0; i &amp;lt; num; i++)
        //         cout &amp;lt;&amp;lt; &#39; &#39;;
        // }
        // else
        //     for(int i = 0; i &amp;lt; 2*num-1; i++)
        //         cout &amp;lt;&amp;lt; &#39; &#39;;
        //æ”¹ä¸ºä»çˆ¶äº²é‚£é‡Œå¾—åˆ°æ¨ªåæ ‡

        //æ–°çš„ä¸€å±‚ æ”¹å˜num åŒæ—¶last_axisæ¸…é›¶  (é€šè¿‡æ¯”è¾ƒæ·±åº¦)
        curr = tmp.front();
        if(last_depth != curr-&amp;gt;depth){
            num/=2;
            last_axis = 0;
            cout &amp;lt;&amp;lt; endl;
        }
            
        if(curr == _root)
            _root-&amp;gt;axis = num;
        else{
            if(IsLc(curr))
                curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis - num;
            else
                curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis + num; 
        }


        //è¾“å‡ºç©ºæ ¼ éœ€è¦å‡ä¸€
        for(int i = 0; i &amp;lt; curr-&amp;gt;axis - last_axis - 1; i++) 
            cout &amp;lt;&amp;lt; &#39; &#39;;
        cout &amp;lt;&amp;lt; curr-&amp;gt;data;
        last_depth = curr-&amp;gt;depth;
        last_axis = curr-&amp;gt;axis;

        if(curr -&amp;gt; l_c)
            tmp.push(curr-&amp;gt;l_c);
        if(curr -&amp;gt; r_c)
            tmp.push(curr-&amp;gt;r_c);
        tmp.pop();
    }

    return ;
}

// template &amp;lt;typename T&amp;gt;
// void Bintree&amp;lt;T&amp;gt;::createBlank(int n){
//     while(n--)
//         cout &amp;lt;&amp;lt; &#39; &#39;;
//     return ;
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.main.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;bintree.h&amp;quot;
#include &amp;lt;string&amp;gt;
#include &amp;lt;stack&amp;gt;


//ä»ä¸­ç¼€è¡¨è¾¾å¼æ„å»º
void create_from_infix(Bintree&amp;lt;char&amp;gt;&amp;amp; my_tree){
    string strs, res;
    stack&amp;lt;char&amp;gt; tmp;    //è¿ç®—ç¬¦
    
    cout &amp;lt;&amp;lt; &amp;quot;Input infix expression :&amp;quot; &amp;lt;&amp;lt; endl;
    cin &amp;gt;&amp;gt; strs;
    

    for(int i = 0; i &amp;lt; strs.size(); i++){
        if(strs[i] &amp;gt;= &#39;0&#39;)
            res += strs[i];
        else if(strs[i] == &#39;(&#39;)
            tmp.push(strs[i]);
        else if(strs[i] == &#39;)&#39;){
            while(tmp.top() != &#39;(&#39;){
                res += tmp.top();
                tmp.pop();
            }
            tmp.pop();  //æ¸…é™¤å¤šä½™çš„&#39;(&#39;
        }
        else if(strs[i] == &#39;+&#39; || strs[i] == &#39;-&#39;){
            while(!tmp.empty()){
                if(tmp.top() == &#39;(&#39;)
                    break;  //å·¦æ‹¬å·é¢å¤–æ³¨æ„
                res += tmp.top();
                tmp.pop();
            }
            tmp.push(strs[i]);     //å½“å‰æ“ä½œçš„è¿ç®—ç¬¦å…¥æ ˆ
        }
        else if(strs[i] == &#39;*&#39; || strs[i] == &#39;/&#39;){
            while(!tmp.empty()){
                if(tmp.top() == &#39;(&#39; || tmp.top()  == &#39;+&#39; || tmp.top()  == &#39;-&#39;)
                    break;  //ä¸èƒ½å…¨éƒ¨è¾“å‡º
                res += tmp.top();
                tmp.pop();
            }
            tmp.push(strs[i]);     //å…¥æ ˆå½“å‰è¿ç®—ç¬¦
        }
    }

    //æ ˆä¸­å¤šä½™è¿ç®—ç¬¦
    while(!tmp.empty()){
        res += tmp.top();
        tmp.pop();
    }

    cout &amp;lt;&amp;lt; &amp;quot;Postfix expression is :&amp;quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;

    //å¼€å§‹é€ æ ‘
    my_tree.insertAsRoot(res[res.size()-1]);
    node&amp;lt;char&amp;gt;* x = my_tree.getRoot();
    stack&amp;lt;node&amp;lt;char&amp;gt;*&amp;gt; nodes;
    nodes.push(x);  //é˜²æ­¢æœ€åä¸€ä¸ªæ“ä½œæ•°è®¿é—®é”™è¯¯
    for(int i = res.size()-2; i &amp;gt;= 0; i--){
        if(res[i] &amp;gt;= &#39;0&#39;){
            //æ•°å­—æˆ–è€…å­—æ¯ä½œä¸ºå·¦å­©å­æ’å…¥æ—¶éœ€è¦å‘ä¸Šè¿”å›
            if(x-&amp;gt;r_c){
                my_tree.insertAsLc(x, res[i]);
                x = nodes.top();
                nodes.pop();
            }
            else
                my_tree.insertAsRc(x, res[i]);
        }
        else{
            //å­—ç¬¦ä¸€å®šä¼šç§»åŠ¨
            
            if(x-&amp;gt;r_c)
                x = my_tree.insertAsLc(x, res[i]);
            else{
                nodes.push(x);
                x = my_tree.insertAsRc(x, res[i]);
            }
        }
    }
}


int main(){
    Bintree&amp;lt;char&amp;gt; my_tree;
    create_from_infix(my_tree);
    cout &amp;lt;&amp;lt; &amp;quot;Tree is:&amp;quot;&amp;lt;&amp;lt;endl;
    my_tree.treeShow();
}

//å°è£…çš„æ„ä¹‰åªæ˜¯ä¸ºäº†è‡ªåŠ¨æ›´æ–°é«˜åº¦ï¼Ÿåˆ é™¤æ›´åŠ æ–¹ä¾¿ï¼Ÿ
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;qtå›¾å½¢åŒ–ç•Œé¢&#34;&gt;QTå›¾å½¢åŒ–ç•Œé¢&lt;/h2&gt;

&lt;p&gt;åˆæ¬¡æ¥è§¦QTï¼ŒèŠ±è´¹äº†è¾ƒå¤šçš„æ—¶é—´æ¥äº†è§£Qtçš„ä½¿ç”¨ã€‚å¯¹QpaintEventç†è§£çš„ä¸æ˜¯å¾ˆé€å½»ï¼Œå®ç°çš„æ—¶å€™å‚è€ƒäº†ç½‘ä¸Šçš„ä¸€äº›ä»£ç ã€‚ç¨‹åºä½¿ç”¨äº†æ­¤å‰ç¼–å†™çš„äºŒå‰æ ‘ç±»ï¼Œä¸­ç¼€è¡¨è¾¾å¼è½¬åŒ–ä¸ºäºŒå‰æ ‘éƒ¨åˆ†ä¹Ÿä¸æ§åˆ¶å°ç¨‹åºä¸€è‡´ã€‚&lt;/p&gt;

&lt;h3 id=&#34;ç¨‹åºå®ç°&#34;&gt;ç¨‹åºå®ç°&lt;/h3&gt;

&lt;p&gt;Qté¡¹ç›®ä½¿ç”¨äº†æ­¤å‰ç¼–å†™çš„äºŒå‰æ ‘å¤´æ–‡ä»¶ï¼Œdraw.cppã€main.cppã€draw.hå®ç°å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;p&gt;1.draw.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#ifndef DRAW_H
#define DRAW_H

#include &amp;lt;QMainWindow&amp;gt;
#include &amp;lt;QPaintEvent&amp;gt;
#include &amp;quot;bintree.h&amp;quot;

namespace Ui {
class draw;
}

class draw : public QMainWindow
{
    Q_OBJECT

public:
    Bintree&amp;lt;char&amp;gt; my_tree;
    QPaintEvent * tmp;
    explicit draw(QWidget *parent = nullptr);
    ~draw();
    void createTree();
    void paintEvent(QPaintEvent *);

private:
    Ui::draw *ui;
signals:

public slots:
//    void paintEvent(QPaintEvent *);
//    void createTree();
    //void showTree(bool checked);
    void createClicked();

};

#endif // DRAW_H
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.draw.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;draw.h&amp;quot;
#include &amp;quot;ui_draw.h&amp;quot;
#include &amp;lt;QPainter&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;QString&amp;gt;
#include &amp;lt;QtDebug&amp;gt;
#include &amp;lt;QChar&amp;gt;
#include &amp;lt;QtCore&amp;gt;

draw::draw(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::draw)
{

    ui-&amp;gt;setupUi(this);
    //this-&amp;gt;connect(ui-&amp;gt;pushButton, SIGNAL(clicked(bool)), this, SLOT(createTree()));
    this-&amp;gt;connect(ui-&amp;gt;huizhi, SIGNAL(clicked(bool)), this, SLOT(createClicked()));
}

draw::~draw()
{
    delete ui;
}

void draw::createClicked(){
    createTree();
    paintEvent(tmp);
    update();

}
void draw::paintEvent(QPaintEvent *)
{
    QPainter painter(this);
    node&amp;lt;char&amp;gt;* x = my_tree.getRoot();
    node&amp;lt;char&amp;gt;* curr;
    if(x){
        //å±‚éå†ç¬¬ä¸€é
        int last_axis = 0, last_depth = 0;
        int num = 1, n = x-&amp;gt;height;
        while(n--)  num *= 2;

        queue&amp;lt;node&amp;lt;char&amp;gt;* &amp;gt; tmp;

        //ç”»çº¿
        tmp.push(x);
        while(!tmp.empty()){
            curr = tmp.front();
            if(last_depth != curr-&amp;gt;depth){
                        num/=2;
                        last_axis = 0;
             }
            if(curr == x)
                        curr-&amp;gt;axis = num;
             else{
                        if(IsLc(curr))
                            curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis - num;
                        else
                            curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis + num;
             }

            last_depth = curr-&amp;gt;depth;
            last_axis = curr-&amp;gt;axis;
            if(curr-&amp;gt;l_c)
                tmp.push(curr-&amp;gt;l_c);
            if(curr-&amp;gt;r_c)
                tmp.push(curr-&amp;gt;r_c);
            tmp.pop();

            if(x == curr)
                continue;   //æ ¹èŠ‚ç‚¹ä¸ç”¨ç”»çº¿
            painter.drawLine(30*curr-&amp;gt;axis+30, 130+100*curr-&amp;gt;depth, 30*curr-&amp;gt;parent-&amp;gt;axis+30, 130+100*curr-&amp;gt;parent-&amp;gt;depth);

       }

        //å±‚éå†ç¬¬äºŒé ç”»èŠ‚ç‚¹
        tmp.push(x);
        while(!tmp.empty()){
            curr = tmp.front();
            painter.setBrush(Qt::green);
            painter.drawEllipse(30*curr-&amp;gt;axis, 100+100*curr-&amp;gt;depth,60,60);
            painter.drawText(30*curr-&amp;gt;axis+25, 100*curr-&amp;gt;depth+135, QChar(curr-&amp;gt;data));
            qDebug()&amp;lt;&amp;lt;QChar(curr-&amp;gt;data)&amp;lt;&amp;lt;endl;

            if(curr-&amp;gt;l_c)
                tmp.push(curr-&amp;gt;l_c);
            if(curr-&amp;gt;r_c)
                tmp.push(curr-&amp;gt;r_c);
            tmp.pop();
        }
    }
}

void draw::createTree()
{
    //QString str = ui-&amp;gt;line-&amp;gt;toPlainText().toStdString().data();    //æˆ‘ä½›äº†
      QString str = ui-&amp;gt;line-&amp;gt;text();
//    QString res;
    std::string res;
    std::string strs = str.toStdString();
    stack&amp;lt;char&amp;gt; tmp;

    for(int i = 0; i &amp;lt; strs.size(); i++){
            if(strs[i] &amp;gt;= &#39;0&#39;)
                res += strs[i];
            else if(strs[i] == &#39;(&#39;)
                tmp.push( strs[i]);
            else if(strs[i] == &#39;)&#39;){
                while(tmp.top() != &#39;(&#39;){
                    res += tmp.top();
                    tmp.pop();
                }
                tmp.pop();  //æ¸…é™¤å¤šä½™çš„&#39;(&#39;
            }
            else if(strs[i] == &#39;+&#39; || strs[i] == &#39;-&#39;){
                while(!tmp.empty()){
                    if(tmp.top() == &#39;(&#39;)
                        break;  //å·¦æ‹¬å·é¢å¤–æ³¨æ„
                    res += tmp.top();
                    tmp.pop();
                }
                tmp.push(strs[i]);     //å½“å‰æ“ä½œçš„è¿ç®—ç¬¦å…¥æ ˆ
            }
            else if(strs[i] == &#39;*&#39; || strs[i] == &#39;/&#39;){
                while(!tmp.empty()){
                    if(tmp.top() == &#39;(&#39; || tmp.top()  == &#39;+&#39; || tmp.top()  == &#39;-&#39;)
                        break;  //ä¸èƒ½å…¨éƒ¨è¾“å‡º
                    res += tmp.top();
                    tmp.pop();
                }
                tmp.push(strs[i]);     //å…¥æ ˆå½“å‰è¿ç®—ç¬¦
            }
        }

        //æ ˆä¸­å¤šä½™è¿ç®—ç¬¦
        while(!tmp.empty()){
            res += tmp.top();
            tmp.pop();
        }

        //å¼€å§‹é€ æ ‘
        my_tree.insertAsRoot(res[res.size()-1]);
            node&amp;lt;char&amp;gt;* x = my_tree.getRoot();
            stack&amp;lt;node&amp;lt;char&amp;gt;*&amp;gt; nodes;
            nodes.push(x);
            for(int i = res.size()-2; i &amp;gt;= 0; i--){
                if(res[i] &amp;gt;= &#39;0&#39;){
                    //æ•°å­—æˆ–è€…å­—æ¯ä½œä¸ºå·¦å­©å­æ’å…¥æ—¶éœ€è¦å‘ä¸Šè¿”å›
                    if(x-&amp;gt;r_c){
                        my_tree.insertAsLc(x, res[i]);
                        x = nodes.top();
                        nodes.pop();
                    }
                    else
                        my_tree.insertAsRc(x, res[i]);
                }
                else{
                    //å­—ç¬¦ä¸€å®šä¼šç§»åŠ¨

                    if(x-&amp;gt;r_c)
                        x = my_tree.insertAsLc(x, res[i]);
                    else{
                        nodes.push(x);
                        x = my_tree.insertAsRc(x, res[i]);
                    }
                }
            }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.main.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;draw.h&amp;quot;
#include &amp;lt;QApplication&amp;gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    draw w;
    w.show();

    return a.exec();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;è¿è¡Œæ•ˆæœ&#34;&gt;è¿è¡Œæ•ˆæœ&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190211.jpg&#34; alt=&#34;æ ·ä¾‹&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190213.jpg&#34; alt=&#34;éå¯¹ç§°æ ‘&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190212.jpg&#34; alt=&#34;ä¸€èˆ¬æƒ…å†µ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ä¸¤ä¸ªå‚è€ƒé“¾æ¥ï¼š&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.itread01.com/content/1541521344.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.itread01.com/content/1541521344.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.yalewoo.com/2016/01/14/binary_tree_graphical_display/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.yalewoo.com/2016/01/14/binary_tree_graphical_display/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;æ€»ç»“ä½“ä¼š&#34;&gt;æ€»ç»“ä½“ä¼š&lt;/h2&gt;

&lt;p&gt;è¿™æ¬¡ä½œä¸šå› ä¸ºäº‹å…ˆæ²¡æœ‰è€ƒè™‘åˆ°æ¨ªåæ ‡çš„é—®é¢˜ï¼Œéå†æ›´æ–°æ¨ªåæ ‡çš„ä»£ç å†™äº†ä¸¤éï¼Œå…¶å®è¿™ä¸ªéƒ¨åˆ†å®Œå…¨å¯ä»¥ä½œä¸ºä¸€ä¸ªæˆå‘˜å‡½æ•°å†™åœ¨ç±»ä¸­ï¼Œä¸è¿‡å½“æˆ‘å‘ç°è¿™ä¸ªé—®é¢˜çš„æ—¶å€™ç¬¬äºŒéå·²ç»å†™äº†ä¸€åŠå¤šäº†ï¼Œæ‰€ä»¥å°±æ²¡æœ‰æ”¹ã€‚å¤§éƒ¨åˆ†æ—¶é—´éƒ½å»ç ”ç©¶Qtäº†ï¼Œæ‰€ä»¥æ„å»ºæ ‘çš„éƒ¨åˆ†å¯èƒ½ä¼šæœ‰æ¼æ´ã€‚ç”±äºæ—¶é—´ç´§è¿«Qtç¨‹åºå°±æ²¡æœ‰å¤šåšç»†èŠ‚å¤„ç†ï¼Œå¦å¤–æŠ¥å‘Šæ’°å†™çš„è´¨é‡ä¹Ÿè¾ƒä½ã€‚&lt;/p&gt;

&lt;p&gt;Qtç¨‹åºä¸æ˜¯ç”Ÿæˆå›¾ç‰‡ï¼Œè€Œæ˜¯è°ƒç”¨ç”»ç¬”ï¼Œæ‰€ä»¥å½“æ·±åº¦è¿‡å¤§ä¹‹åä¼šæœ‰å¾ˆå¤§éƒ¨åˆ†çœ‹ä¸åˆ°ï¼Œè€Œä¸”ç»æŸäººæµ‹è¯•ï¼Œå±‚æ•°è¾¾åˆ°åå‡ å±‚ä¹‹åç¨‹åºä¼šç›´æ¥bugï¼Œå…·ä½“æ˜¯é‚£ä¸ªåœ°æ–¹è¶Šç•Œè¿˜æ²¡æœ‰æ—¶é—´åˆ¤æ–­ã€‚ç°åœ¨æœ‰ä¸€ä¸ªæ— é™ç”»å¸ƒçš„æƒ³æ³•ä½†æ˜¯è¿˜æ²¡æœ‰å°è¯•å»å®ç°ã€‚æ€»ä¹‹æ”¶è·è¿˜æ˜¯è›®å¤§çš„ã€‚&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;æœ‰æ—¶å€™å…ˆç”»å‡ºæ¥æµç¨‹å›¾ç®€åŒ–è¿‡ç¨‹ä¹‹åå†å†™ä»£ç æ•ˆç‡ä¼šæ›´é«˜ã€‚&lt;/li&gt;
&lt;li&gt;é¢å¯¹æ–°é¢†åŸŸè€Œåˆä¸éœ€è¦å®ç°ç‰¹åˆ«å›°éš¾çš„åŠŸèƒ½æ—¶ï¼šçŠ¹è±«ï¼Œå°±ä¼šè´¥åŒ—ï¼Œå¤´é“ï¼Œå°±ä¼šç™½ç»™ã€‚&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>æ•°æ®ç»“æ„ä½œä¸šäº” Compression</title>
      <link>https://wanakiki.github.io/2019/compression/</link>
      <pubDate>Fri, 03 May 2019 14:00:51 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/compression/</guid>
      <description>

&lt;p&gt;å›¾ç‰‡æœ‰æŸå‹ç¼©å¤§ä½œä¸š&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;é—®é¢˜åˆ†æ-è§£å†³æ–¹æ¡ˆ&#34;&gt;é—®é¢˜åˆ†æ &amp;amp; è§£å†³æ–¹æ¡ˆ&lt;/h2&gt;

&lt;p&gt;æœ¬æ¬¡ç¼–ç¨‹ä»»åŠ¡ç»™å‡ºäº†ä¸€ä¸ªçº¯è‹±æ–‡çš„PDFæ–‡ä»¶ï¼Œè¾ƒä¸ºè¯¦ç»†åœ°ä»‹ç»äº†å›¾åƒæœ‰æŸå‹ç¼©ç®—æ³•çš„å®ç°æ–¹å¼ï¼Œé€šè¿‡äºŒå‰æ ‘çš„æ ‘å‰ªæè¾¾åˆ°ä¿ç•™å›¾ç‰‡ç»†èŠ‚çš„ç›®çš„ã€‚ä»»åŠ¡è¦æ±‚è¾¾åˆ°çš„æ•ˆæœå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå¯ä»¥çœ‹å‡ºè¾ƒä¸ºå¤æ‚çš„å›¾è…¾éƒ¨åˆ†å¾—åˆ°äº†å¾ˆå¥½çš„ä¿ç•™ï¼Œè€Œæ ‘å¶å’Œè¿œå¤„çš„èƒŒæ™¯åˆ™è¢«æ˜æ˜¾åœ°å‹ç¼©æˆäº†åƒç´ åŒºå—ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134525.jpg&#34; alt=&#34;ç¤ºä¾‹&#34; /&gt;&lt;/p&gt;

&lt;p&gt;å’Œç¼–ç¨‹ä»»åŠ¡ä¸€åŒç»™å‡ºçš„æºç åŒ…ä¸­å·²ç»å®ç°äº†ç»å¤§éƒ¨åˆ†ä»£ç ï¼Œæˆ‘ä»¬éœ€è¦æŒ‰ç…§ç»™å‡ºçš„æ–¹æ³•å¯¹ç¼ºå¤±çš„ä»£ç è¿›è¡Œè¡¥å……ï¼Œä»è¿™æ–¹é¢æ¥è®²ï¼Œæ•´ä¸ªç¼–ç¨‹ä»»åŠ¡ç›¸å½“äºä¸€ä¸ªç¨å¾®å¤æ‚çš„ç¨‹åºå¡«ç©ºé¢˜ã€‚å¦å¤–ä¸å¾—ä¸æçš„ä¸€ç‚¹æ˜¯ï¼Œæ‰€ç»™çš„æºç æ ¼å¼è¾ƒä¸ºè§„èŒƒï¼Œä»”ç»†ç ”ç©¶ä»£ç çš„æ•´ä½“æ¡†æ¶å¯¹æ—¥åçš„ç¼–ç¨‹ä¹Ÿæœ‰ä¸€å®šçš„å¥½å¤„ï¼Œä¹Ÿæ­£å› å…¶è§„èŒƒæ€§ï¼Œä»£ç æ•´ä½“é˜…è¯»éš¾åº¦è¾ƒä½ã€‚&lt;/p&gt;

&lt;p&gt;æ€»ä½“æ¥çœ‹ï¼Œæ•´ä¸ªå·¥ç¨‹ç”±äº”ä¸ªéƒ¨åˆ†ç»„æˆï¼Œå…¶ä»å±å…³ç³»ä¸ºï¼šPNGç±»åŒ…å«RGBAPixelç±»ï¼Œå¹¶ä¸”é€šè¿‡loadpngä¸­çš„å‡½æ•°å¯¹å›¾ç‰‡è¿›è¡Œæœ€åº•å±‚çš„è¯»å†™ã€‚twoDtreeé€šè¿‡ä¸€ä¸ªPNGç±»è¿›è¡Œæ„å»ºï¼Œstatsåœ¨æ„å»ºçš„è¿‡ç¨‹ä¸­èµ·åˆ°è¾…åŠ©ä½œç”¨ï¼ŒåŠ å¿«æ•´ä¸ªæ„å»ºè¿‡ç¨‹ã€‚ç¨‹åºçš„å®è§‚æ¡†æ¶å¤§è‡´å¦‚æ­¤ï¼Œstatsä¸­çš„æ‰€æœ‰å‡½æ•°éƒ½è¦æˆ‘ä»¬å¯¹å…¶è¿›è¡Œå…·ä½“å®ç°ï¼ŒtwoDtreeä¸­çš„å¤§éƒ¨åˆ†å…³é”®ä»£ç éƒ½è¦æˆ‘ä»¬å¯¹å…¶è¿›è¡Œè¡¥å……ï¼Œè€Œå…¶ä½™çš„ä¸‰ä¸ªæ–‡ä»¶åœ¨äº†è§£äº†ç±»çš„å®šä¹‰æ–¹å¼åŠå¤§è‡´çš„æˆå‘˜å‡½æ•°çš„ç”¨æ³•ä¹‹åä¾¿å¯ä¸å¿…æ·±ç©¶ã€‚&lt;/p&gt;

&lt;p&gt;ä¸éš¾çœ‹å‡ºï¼Œä»»åŠ¡åªè¦æ±‚å¯¹twoDtreeå’Œstatsä¸¤ä¸ªéƒ¨åˆ†è¿›è¡Œè¡¥å……ï¼Œåˆšå¥½å°†æ•´ä¸ªä»»åŠ¡åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œç”±äºtwoDtreeå¯¹statsæœ‰ä¸€å®šä¾èµ–æ€§ï¼Œé¦–å…ˆå¤„ç†statsçš„éƒ¨åˆ†ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç®—æ³•è®¾è®¡&#34;&gt;ç®—æ³•è®¾è®¡&lt;/h2&gt;

&lt;p&gt;æ­¤å‰å·²ç»å™è¿°æ¸…æ¥šï¼Œä»»åŠ¡å¯ä»¥è¢«åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ†ï¼Œæ¥ä¸‹æ¥å¯¹ä¸¤ä¸ªéƒ¨åˆ†ç®—æ³•çš„è®¾è®¡è¿›è¡Œè¯´æ˜ã€‚&lt;/p&gt;

&lt;h3 id=&#34;statsç±»å‡½æ•°çš„å®ç°&#34;&gt;statsç±»å‡½æ•°çš„å®ç°&lt;/h3&gt;

&lt;p&gt;ä»ä»»åŠ¡è¯´æ˜ä¸­å¯ä»¥äº†è§£åˆ°ï¼Œstatsç±»æ˜¯é€šè¿‡å¯¹å›¾ç‰‡å„ä¸ªé€šé“çš„åƒç´ å€¼è¿›è¡Œé¢„è®¡ç®—ï¼Œä½¿ç”ŸæˆäºŒå‰æ ‘æ—¶æ¯ç§åˆ†å‰²æƒ…å†µä¸‹è®¡ç®—variability measurement çš„å¤æ‚åº¦é™åˆ°å¸¸æ•°æ—¶é—´ï¼Œå¹¶èƒ½å¤Ÿè¿”å›æŒ‡å®šå°çŸ©é˜µçš„å¤šç§ä¿¡æ¯ã€‚å…¶ä¸­æœ€å¤§çš„éš¾ç‚¹ä¾¿æ˜¯å¦‚ä½•è¿›è¡Œé¢„è®¡ç®—ä½¿ä¸‹é¢çš„å…¬å¼é™ä½åˆ°å¸¸æ•°æ—¶é—´ã€‚è¿™é‡Œï¼Œä¸ºäº†è®¡ç®—æ–¹ä¾¿æˆ‘ä»¬ä½¿ç”¨ç­‰å¼å³è¾¹çš„å…¬å¼ã€‚&lt;/p&gt;

&lt;p&gt;$$\sum(x-\bar x)^{2}=\sum x^{2}-\frac{(\sum x)^{2}}{\left| R \right|}$$&lt;/p&gt;

&lt;p&gt;ç»“åˆstatsä¸­å·²ç»å®šä¹‰çš„å…­ä¸ªäºŒç»´çŸ©é˜µä¸éš¾æƒ³åˆ°å¯¹æ•´ä¸ªå›¾ç‰‡å„ä¸ªé€šé“çš„é¢œè‰²å€¼åŠå…¶å¹³æ–¹è¿›è¡Œç´¯åŠ ï¼Œå¦‚æœæˆ‘ä»¬é‡‡ç”¨å½“å‰ç‚¹çš„å€¼ç­‰äºä½äºè¯¥ç‚¹ä¸Šæ–¹å’Œå·¦ä¾§çš„ä¸¤ä¸ªå€¼åŠè‡ªèº«ä¸‰ä¸ªå€¼ç´¯åŠ çš„æ–¹å¼å¯¹æ•´ä¸ªå›¾ç‰‡è¿›è¡Œé€’æ¨è®¡ç®—çš„è¯ï¼Œç®—åˆ°æœ€ç»ˆç»“æœä¹‹åä¼šå‘ç°å¾ˆéš¾å¯¹è¿™ä¸ªç”Ÿæˆçš„äºŒç»´å‘é‡è¿›è¡Œé«˜æ•ˆçš„åˆ©ç”¨ï¼Œå› ä¸ºå¤šæ¬¡ç´¯äº†é‡å¤å€¼ï¼Œèµ·åˆä¸æ˜æ˜¾ï¼Œç­‰åˆ°é¢ç§¯å¢å¤§ä¹‹åå°±ä¼šå˜æˆå¾ˆéš¾å¤„ç†çš„é—®é¢˜ã€‚&lt;/p&gt;

&lt;p&gt;ç¨åŠ æ€è€ƒï¼ˆhhhï¼ŒèŠ±äº†å°†è¿‘ä¸€ä¸ªå°æ—¶ï¼‰ä¹‹åæˆ‘ä»¬å¾—åˆ°äº†å¦å¤–çš„ä¸€ç§æ–¹æ³•ï¼Œæ—¢ç„¶æˆ‘ä»¬ä¹‹å‰çš„é—®é¢˜æ˜¯æ¯è®¡ç®—ä¸€ä¸ªç‚¹çš„å€¼éƒ½ä¼šå¯¼è‡´ä¹‹å‰çš„å€¼è¢«é‡å¤è®¡ç®—ï¼Œä¸ºäº†è§£å†³å®ƒï¼Œæˆ‘ä»¬åœ¨è®¡ç®—çš„æ—¶å€™ç›´æ¥å‡å»ä¼šè¢«é‡å¤è®¡ç®—çš„ç‚¹ï¼Œè¿™æ ·ï¼Œæœ€ç»ˆç”Ÿæˆçš„äºŒç»´å‘é‡ä¸­çš„æ¯ä¸ªå€¼éƒ½ç­‰äºä»¥åŸç‚¹å’Œå½“å‰ç‚¹ç¡®å®šçš„çŸ©å½¢ä¸­çš„æ‰€æœ‰ç‚¹çš„ç´¯åŠ ã€‚&lt;/p&gt;

&lt;p&gt;å…·ä½“å®ç°ä¸ºï¼šåœ¨è®¡ç®—ä¸€ä¸ªç‚¹çš„å€¼çš„æ—¶å€™ï¼Œé™¤äº†åŠ ä¸Šå…¶ä¸Šæ–¹å’Œå·¦ä¾§çš„ä¸¤ä¸ªç‚¹ï¼Œè¿˜è¦å‡å»å·¦ä¸Šæ–¹çš„ç‚¹ï¼ŒæŒ‰ç…§è¿™ä¸ªè§„åˆ™è¿›è¡Œé€’æ¨è®¡ç®—ï¼Œæœ€ç»ˆçš„ç»“æœå°±æ˜¯æˆ‘ä»¬æƒ³è¦çš„æƒ…å†µã€‚&lt;/p&gt;

&lt;p&gt;å¯¹äºç”ŸæˆçŸ©é˜µçš„åˆ©ç”¨æˆ‘ä»¬ç”¨å›¾å½¢è¿›è¡Œè§£é‡Šï¼šå¦‚å›¾æ‰€ç¤ºï¼Œæˆ‘ä»¬å·²ç»å¾—åˆ°äº†æˆ‘ä»¬æ‰€éœ€çš„ç´¯åŠ å’ŒçŸ©é˜µï¼ŒçŸ©é˜µä¸­çš„æ¯ä¸ªç‚¹çš„å€¼éƒ½ç­‰äºè¯¥ç‚¹ä¸åŸç‚¹ç¡®å®šçš„çŸ©å½¢ä¸­æ‰€æœ‰ç‚¹çš„ç´¯åŠ å’Œã€‚ç°åœ¨æˆ‘ä»¬æƒ³è¦è®¡ç®—å‡ºå›¾ä¸­ç»¿è‰²çŸ©å½¢æ‰€å¯¹åº”çš„ç´¯åŠ å’Œã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/compression/20190503135249.png&#34; alt=&#34;ç¤ºä¾‹å›¾&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;ç›´è§‚æ¥çœ‹ï¼Œsum = æ•´ä½“ - è“è‰² - æ©™è‰² - çº¢è‰²
å·²çŸ¥: æ•´ä½“ = D, è“è‰² = B - Aï¼Œæ©™è‰² = C - Aï¼Œçº¢è‰² = A
åˆ™ä¸éš¾æ¨å‡ºï¼Œsum = D - B - C + A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;æŒ‰ç…§ä¸Šè¿°å…¬å¼æˆ‘ä»¬ä¾¿å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…è®¡ç®—å‡ºä»»ä½•å­çŸ©é˜µå¯¹åº”çš„ç´¯åŠ å’Œã€‚ä¸ºäº†æ–¹ä¾¿åç»­çš„è®¡ç®—ï¼Œæˆ‘åœ¨å¤„ç†çŸ©é˜µçš„æ—¶å€™å¤šå¼€è¾Ÿäº†é¢å¤–çš„ç©ºé—´å¹¶å­˜ä¸Šé›¶ï¼Œç®€åŒ–äº†ä»£ç ã€‚&lt;/p&gt;

&lt;h3 id=&#34;twodtreeçš„æ¢ç´¢&#34;&gt;twoDtreeçš„æ¢ç´¢&lt;/h3&gt;

&lt;p&gt;twoDtreeä¸­ä¸»è¦è®©æˆ‘ä»¬å®ç°çš„åŠŸèƒ½æœ‰ä¸¤ä¸ªï¼Œå»ºæ ‘å’Œå‰ªæï¼Œè‡³äºä»æ ‘è¿˜åŸåˆ°å›¾ç‰‡å’Œæ ‘çš„åŸºç¡€æ“ä½œå‡½æ•°æ˜¯ç›¸å¯¹åŸºæœ¬çš„å†…å®¹ï¼Œé€šè¿‡è¯¾ä¸Šçš„å­¦ä¹ ä»¥åŠå¯¹ç¨‹åºæ¡†æ¶çš„ç†è§£åº”è¯¥å¯ä»¥å¾ˆè½»æ¾åœ°å†™å‡ºæ¥ï¼Œåœ¨è¿™é‡Œä¸æµªè´¹ç¬”å¢¨ä¸€ä¸ªä¸ªè¿›è¡Œé˜è¿°ã€‚&lt;/p&gt;

&lt;h4 id=&#34;å»ºæ ‘å‡½æ•°buildtree&#34;&gt;å»ºæ ‘å‡½æ•°buildTree&lt;/h4&gt;

&lt;p&gt;é€šè¿‡å¯¹ç¨‹åºçš„é˜…è¯»æˆ‘ä»¬å¯ä»¥äº†è§£åˆ°ï¼ŒäºŒå‰æ ‘æ˜¯ä»å›¾ç‰‡æ„å»ºæ¥çš„ï¼Œè€ŒbuildTreeä¾¿æ˜¯æ„é€ æ ‘çš„å…³é”®å‡½æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠæ ‘çš„ä¸€èˆ¬åˆå§‹åŒ–å…ˆåœ¨æ„é€ å‡½æ•°å†…å†™å‡ºæ¥ï¼Œæå‰å‡†å¤‡å¥½è¯¥å‡½æ•°éœ€è¦çš„å‚æ•°ï¼Œä¹‹ååœ¨æ„é€ å‡½æ•°ä¸­å¯¹å…¶è¿›è¡Œè°ƒç”¨ï¼Œç”Ÿæˆæ•´ä¸ªæ ‘çš„æ¡†æ¶ã€‚&lt;/p&gt;

&lt;p&gt;é¦–å…ˆå®¡è§†ä¸€ä¸‹ä½œä¸šPDFä¸­å¯¹æ ‘çš„æ„é€ æ–¹æ³•çš„è§£é‡Šï¼Œæˆ‘ç†è§£çš„æ–¹æ³•æ˜¯ï¼šçˆ¶èŠ‚ç‚¹å¯¹åº”äºä¸€ä¸ªå¤§çŸ©å½¢ï¼Œå¦‚æœè¿™ä¸ªå¤§çŸ©å½¢å†…æœ‰å¤§äºä¸¤ä¸ªçš„åƒç´ å€¼ï¼Œæˆ‘ä»¬å°±è¦å¯¹å®ƒè¿›è¡Œåˆ†å‰²ï¼Œåˆ’ä¸ºä¸¤ä¸ªçŸ©å½¢ï¼Œä½¿ä¸¤ä¸ªå­çŸ©é˜µçš„è‰²å½©å¤šæ ·æ€§ï¼ˆæˆ‘åæ­£è¿™ä¹ˆå«ï¼‰ä¹‹å’Œè¾¾åˆ°æœ€å°ï¼Œè¿™ä¸¤ä¸ªçŸ©å½¢å°±åˆ†åˆ«å¯¹åº”äºå·¦å³å­©å­ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„å·¦å³å­©å­çš„é¡ºåºã€‚è¿™ä¸ªè¿‡ç¨‹éœ€è¦ä¸€ç›´æ‰§è¡Œä¸‹å»ï¼Œç›´åˆ°å›¾ç‰‡ä¸­çš„æ¯ä¸ªåƒç´ éƒ½å¯¹åº”äºæ ‘çš„å¶å­èŠ‚ç‚¹ã€‚&lt;strong&gt;éœ€è¦æ³¨æ„ï¼Œç”±äºæˆ‘ä»¬ä¸æ˜¯å¯¹ç§°åˆ‡åˆ†ï¼Œæ‰€ä»¥æœ€ç»ˆç”Ÿæˆçš„æ ‘å¹¶ä¸ä¼šæ˜¯ç†æƒ³ç»“æ„ï¼Œæˆ‘ä»¬åªèƒ½ä¿è¯çš„ä¸€ç‚¹æ˜¯ï¼Œè¿™ä¸ªæ ‘æ˜¯ä¸€ä¸ªçœŸäºŒå‰æ ‘ã€‚&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;è¿™æ ·æˆ‘ä»¬è¦åšçš„äº‹æƒ…å°±å¾ˆæ¸…æ¥šäº†ï¼Œæ— éå°±æ˜¯ä»æ ¹èŠ‚ç‚¹å¼€å§‹è¿™ä¸ªè¿‡ç¨‹ï¼Œæ¯åˆ°ä¸€ä¸ªèŠ‚ç‚¹éƒ½å‡è®¾ä¸€æ¡è™šæ‹Ÿçš„çº¿ï¼Œå¯¹è¿™ä¸ªçŸ©å½¢è¿›è¡Œåˆ‡å‰²ï¼Œåˆ†åˆ«è®¡ç®—ä¸¤ä¸ªçŸ©å½¢çš„è‰²å½©å¤šæ ·æ€§ä¹‹å’Œï¼Œè€ƒè™‘å®Œæ‰€æœ‰çš„æ¨ªçºµæƒ…å†µåé€‰æ‹©æœ€å¥½çš„é‚£ç§ã€‚æŒ‰ç€è¿™æ¡çº¿åˆ‡å‰²åç»§ç»­è¿›è¡Œè¿™ä¸ªè¿‡ç¨‹ï¼Œç›´åˆ°åˆ†ä¸ºå•ä¸ªåƒç´ ç‚¹ã€‚å…³äºå¦‚ä½•åœ¨å¸¸æ•°æ—¶é—´å†…è®¡ç®—å‡ºä¸€ä¸ªçŸ©å½¢çš„è‰²å½©å¤šæ ·æ€§ï¼Œæˆ‘ä»¬åœ¨statsç›¸å…³å†…å®¹ä¸­å·²ç»è¿›è¡Œäº†è¯´æ˜ã€‚&lt;/p&gt;

&lt;h4 id=&#34;å‰ªæå‡½æ•°prune&#34;&gt;å‰ªæå‡½æ•°prune&lt;/h4&gt;

&lt;p&gt;åœ¨æˆ‘çœ‹æ¥ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯æ•´ä¸ªé—®é¢˜æœ€éš¾çš„ç‚¹ï¼Œå› ä¸ºæˆ‘æƒ³ä¸åˆ°ä¸€ä¸ªé«˜æ•ˆçš„ç®—æ³•åªéå†ä¸€éå¶å­èŠ‚ç‚¹ã€‚&lt;/p&gt;

&lt;p&gt;å¦‚ä½•å‰ªæï¼Ÿä¸€ä¸ªå­æ ‘çš„æ ¹èŠ‚ç‚¹åƒç´ å€¼ä¾¿æ˜¯è¿™ä¸ªå­æ ‘å¯¹åº”çŸ©å½¢æ‰€æœ‰åƒç´ å€¼çš„å¹³å‡ï¼Œæˆ‘ä»¬è¦åšçš„äº‹æƒ…æ˜¯è®¡ç®—å‡ºè¿™ä¸ªçŸ©å½¢ä¸­å’Œå„é€šé“è‰²å€¼ä¸å¹³å‡å€¼å·®çš„å¹³æ–¹çš„å’Œå°äºç­‰äºtoleranceçš„ä¸ªæ•°ï¼Œç„¶åè®¡ç®—è¿™ä¸€éƒ¨åˆ†åƒç´ å åƒç´ æ€»ä¸ªæ•°çš„æ¯”ä¾‹ï¼Œå¦‚æœå¤§äºç»™å®šå€¼ï¼Œå°±ä»£è¡¨è¿™ä¸ªçŸ©å½¢ä¸­åƒç´ ä¹‹é—´çš„å·®å¼‚ä¸å¤§ï¼Œæˆ‘ä»¬å°±å¯ä»¥å°†è¿™ä¸ªå­æ ‘çš„æå¶å‰ªæ‰ï¼Œåªç•™ä¸‹æ ¹èŠ‚ç‚¹ã€‚åæ˜ åˆ°å›¾å½¢ä¸Šæ¥ï¼Œå°±æ˜¯å°†è¿™ä¸ªçŸ©å½¢çš„é¢œè‰²æ¶‚æˆäº†å¹³å‡å€¼ã€‚&lt;/p&gt;

&lt;p&gt;æœ€ç»ˆçš„å®ç°æ–¹æ³•å¾ˆç®€å•ï¼Œå…ˆè¿›è¡Œå±‚åºéå†ï¼Œå¯¹éå†åˆ°çš„æ¯ä¸ªèŠ‚ç‚¹å†è¿›è¡Œä¸€æ¬¡éå†ï¼Œç»Ÿè®¡æ»¡è¶³æ¡ä»¶å¶å­çš„ä¸ªæ•°ï¼Œæœ€åè®¡ç®—æ¯”ä¾‹ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦åˆ é™¤ã€‚ä½†æ˜¯è¿™ä¸ªç¨‹åºä¸­æœ‰è¿™ä¹ˆä¸€å¥è¯ï¼Œè®©æˆ‘ä»¥ä¸ºæœ‰è¶…çº§ç®€å•çš„ç®—æ³•å¯ä»¥å®ç°è¿™ä¸ªè¿‡ç¨‹ã€‚ä½†æ˜¯å¾ˆä¸å¹¸ï¼Œæœ€ç»ˆè¿˜æ˜¯æ²¡æœ‰æ‰¾åˆ°ã€‚&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pruning criteria should be evaluated on the original tree, not on a pruned subtree. (we only expect that trees would be pruned once.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;æµç¨‹å›¾&#34;&gt;æµç¨‹å›¾&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134502.png&#34; alt=&#34;stats&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134518.png&#34; alt=&#34;å»ºæ ‘&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ç¼–ç¨‹å®ç°&#34;&gt;ç¼–ç¨‹å®ç°&lt;/h2&gt;

&lt;p&gt;stats.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;stats.h&amp;quot;
using namespace std;
using namespace cs221util;

stats::stats(PNG &amp;amp;im){
    //resize
    unsigned width = im.width();
    unsigned height = im.height();
    sumRed.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumGreen.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumBlue.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumsqRed.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumsqGreen.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumsqBlue.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));

    RGBAPixel *tmp ;
    // sumRed[0][0] = int(tmp-&amp;gt;r);
    // sumGreen[0][0] = int(tmp-&amp;gt;g);
    // sumBlue[0][0] = int(tmp-&amp;gt;b);
    // sumsqRed[0][0] = int(tmp-&amp;gt;r)*int(tmp-&amp;gt;r);
    // sumsqBlue[0][0] = int(tmp-&amp;gt;b)*int(tmp-&amp;gt;b);
    // sumsqGreen[0][0] = int(tmp-&amp;gt;g)*int(tmp-&amp;gt;g);

    // for(int i = 1; i &amp;lt; im.width; i++){
    //     tmp = im.getPixel(i,0);    
    //     sumRed[i][0] = int(tmp-&amp;gt;r);
    //     sumGreen[i][0] = int(tmp-&amp;gt;g);
    //     sumBlue[i][0] = int(tmp-&amp;gt;b);
    //     sumsqRed[i][0] = int(tmp-&amp;gt;r)*int(tmp-&amp;gt;r);
    //     sumsqBlue[i][0] = int(tmp-&amp;gt;b)*int(tmp-&amp;gt;b);
    //     sumsqGreen[i][0] = int(tmp-&amp;gt;g)*int(tmp-&amp;gt;g);
    // }
    // for(int i = 1; i &amp;lt; im.height; i++){
    //     tmp = im.getPixel(0, i);
    //     sumRed[0][i] = int(tmp-&amp;gt;r);
    //     sumGreen[0][i] = int(tmp-&amp;gt;g);
    //     sumBlue[0][i] = int(tmp-&amp;gt;b);
    //     sumsqRed[0][i] = int(tmp-&amp;gt;r)*int(tmp-&amp;gt;r);
    //     sumsqBlue[0][i] = int(tmp-&amp;gt;b)*int(tmp-&amp;gt;b);
    //     sumsqGreen[0][i] = int(tmp-&amp;gt;g)*int(tmp-&amp;gt;g);
    // }

    for(unsigned int i = 1; i &amp;lt;= width; i++)
    for(unsigned int j = 1; j &amp;lt;= height; j++){
        tmp = im.getPixel(i-1, j-1);
        sumRed[i][j] = (int)(tmp-&amp;gt;r) + sumRed[i-1][j] + sumRed[i][j-1] - sumRed[i-1][j-1];
        sumGreen[i][j] = (int)(tmp-&amp;gt;g) + sumGreen[i-1][j] + sumGreen[i][j-1] - sumGreen[i-1][j-1];
        sumBlue[i][j] = (int)(tmp-&amp;gt;b) + sumBlue[i-1][j] + sumBlue[i][j-1] - sumBlue[i-1][j-1];
        sumsqRed[i][j] = (int)(tmp-&amp;gt;r)*(int)(tmp-&amp;gt;r) + sumsqRed[i-1][j] + sumsqRed[i][j-1] - sumsqRed[i-1][j-1];
        sumsqBlue[i][j] = (int)(tmp-&amp;gt;b)*(int)(tmp-&amp;gt;b) + sumsqBlue[i-1][j] + sumsqBlue[i][j-1] - sumsqBlue[i-1][j-1];
        sumsqGreen[i][j] = (int)(tmp-&amp;gt;g)*(int)(tmp-&amp;gt;g) + sumsqGreen[i-1][j] + sumsqGreen[i][j-1] - sumsqGreen[i-1][j-1];
    }
    //æ²¡æœ‰å¿…è¦å¼ºè½¬ä¸ºint...
}

long stats::getSum(char channel, pair&amp;lt;int, int&amp;gt; ul, pair&amp;lt;int, int&amp;gt; lr){
    long ans = 0;
    switch (channel)
    {
    case &#39;r&#39;:
        /* code */
        ans = sumRed[lr.first+1][lr.second+1];
        ans -= sumRed[ul.first][lr.second+1];
        ans -= sumRed[lr.first+1][ul.second];
        ans += sumRed[ul.first][ul.second];
        break;
    case &#39;g&#39;:
        ans = sumGreen[lr.first+1][lr.second+1];
        ans -= sumGreen[ul.first][lr.second+1];
        ans -= sumGreen[lr.first+1][ul.second];
        ans += sumGreen[ul.first][ul.second];
        break;
    case &#39;b&#39;:
        ans = sumBlue[lr.first+1][lr.second+1];
        ans -= sumBlue[ul.first][lr.second+1];
        ans -= sumBlue[lr.first+1][ul.second];
        ans += sumBlue[ul.first][ul.second];
        break;
    default:
        break;
    }
    return ans;
}

long stats::getSumSq(char channel, pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    long ans = 0;
    switch (channel)
    {
    case &#39;r&#39;:
        /* code */
        ans = sumsqRed[lr.first+1][lr.second+1];
        ans -= sumsqRed[ul.first][lr.second+1];
        ans -= sumsqRed[lr.first+1][ul.second];
        ans += sumsqRed[ul.first][ul.second];
        break;
    case &#39;g&#39;:
        ans = sumsqGreen[lr.first+1][lr.second+1];
        ans -= sumsqGreen[ul.first][lr.second+1];
        ans -= sumsqGreen[lr.first+1][ul.second];
        ans += sumsqGreen[ul.first][ul.second];
        break;
    case &#39;b&#39;:
        ans = sumsqBlue[lr.first+1][lr.second+1];
        ans -= sumsqBlue[ul.first][lr.second+1];
        ans -= sumsqBlue[lr.first+1][ul.second];
        ans += sumsqBlue[ul.first][ul.second];
        break;
    default:
        break;
    }
    return ans;
}

long stats::rectArea(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    return (lr.first-ul.first+1)*(lr.second-ul.second+1);
}

RGBAPixel stats::getAvg(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    long sum = rectArea(ul, lr);
    long sum_r, sum_g, sum_b;
    sum_r = getSum(&#39;r&#39;, ul, lr) / sum;
    sum_g = getSum(&#39;g&#39;, ul, lr) / sum;
    sum_b = getSum(&#39;b&#39;, ul, lr) / sum;
    return RGBAPixel(sum_r, sum_g, sum_b);
}

long stats::getScore(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    long sum = rectArea(ul, lr);
    long sum_r, sum_g, sum_b;
    long sumsq_r, sumsq_g, sumsq_b;
    sum_r = getSum(&#39;r&#39;, ul, lr);
    sum_g = getSum(&#39;g&#39;, ul, lr);
    sum_b = getSum(&#39;b&#39;, ul, lr);
    sumsq_r = getSumSq(&#39;r&#39;, ul, lr);
    sumsq_g = getSumSq(&#39;g&#39;, ul, lr);
    sumsq_b = getSumSq(&#39;b&#39;, ul, lr);

    //alphaç½®ä¸€ï¼Ÿ
    //æ˜¯å¦è€ƒè™‘æº¢å‡ºï¼Ÿ
    sum_r = sum_r * sum_r / sum;
    sum_g = sum_g * sum_g / sum;
    sum_b = sum_b * sum_b / sum;
    sumsq_r -= sum_r;
    sumsq_g -= sum_g;
    sumsq_b -= sum_b;
    return sumsq_r + sumsq_g + sumsq_b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;twoDtree.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
 *
 * twoDtree (pa3)
 * slight modification of a Kd tree of dimension 2.
 * twoDtree.cpp
 * This file will be used for grading.
 *
 */

#include &amp;quot;twoDtree.h&amp;quot;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;queue&amp;gt;

/* given */
twoDtree::Node::Node(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr, RGBAPixel a)
    :upLeft(ul),lowRight(lr),avg(a),left(NULL),right(NULL)
    {}

/* given */
twoDtree::~twoDtree(){
    clear();
}

/* given */
twoDtree::twoDtree(const twoDtree &amp;amp; other) {
    copy(other);
}

/* given */
twoDtree &amp;amp; twoDtree::operator=(const twoDtree &amp;amp; rhs){
    if (this != &amp;amp;rhs) {
        clear();
        copy(rhs);
    }
    return *this;
}

twoDtree::twoDtree(PNG &amp;amp; imIn){ 
    /* your code here */
    height = imIn.height();
    width = imIn.width();
    stats my_stat(imIn);
    pair&amp;lt;int, int&amp;gt; cur_ul, cur_lr;
    cur_ul = make_pair(0,0);
    cur_lr = make_pair(width-1, height-1);  
    //æ³¨æ„åæ ‡ä»é›¶å¼€å§‹
    
    root = buildTree(my_stat, cur_ul, cur_lr);
}

twoDtree::Node * twoDtree::buildTree(stats &amp;amp; s, pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr) {
    /* your code here */
    Node *cur = new Node(ul, lr, s.getAvg(ul, lr));

    //éå†æ‰€æœ‰æƒ…å†µ
    //if(s.rectArea(ul,lr) &amp;gt; 1){    æ¡ä»¶å¯¼è‡´æ­»å¾ªç¯
    if(ul != lr){
        bool flag = 1;  //1 means horizontal 0 means vertical
        int line = 0;
        long tmp;
        long Min = 9999999999;
        for(int i = ul.second; i &amp;lt; lr.second; i++){
            tmp = s.getScore(ul, pair&amp;lt;int,int&amp;gt; (lr.first, i)) + s.getScore(pair&amp;lt;int,int&amp;gt; (ul.first, i+1),lr);
            if(tmp &amp;lt; Min){
                Min = tmp;
                line = i;
            }
        }

        for(int i = ul.first; i &amp;lt; lr.first; i++){
            tmp = s.getScore(ul, pair&amp;lt;int,int&amp;gt; (i,lr.second)) + s.getScore(pair&amp;lt;int,int&amp;gt;(i+1, ul.second), lr);
            if((i == ul.first &amp;amp;&amp;amp; ul.second == ul.first) || tmp &amp;lt; Min){
                flag = 0;
                Min = tmp;
                line = i;
            }
        }
        
        if(flag){
            cur-&amp;gt;left = buildTree(s, ul, pair&amp;lt;int,int&amp;gt;(lr.first, line));
            cur-&amp;gt;right = buildTree(s, pair&amp;lt;int,int&amp;gt;(ul.first, line+1), lr);
        }
        else{
            cur-&amp;gt;left = buildTree(s, ul, pair&amp;lt;int,int&amp;gt;(line, lr.second));
            cur-&amp;gt;right = buildTree(s, pair&amp;lt;int,int&amp;gt;(line+1,ul.second), lr);
        }
    }
    else{
        cur-&amp;gt;left = NULL;
        cur-&amp;gt;right = NULL;
    }
    return cur;
}

PNG twoDtree::render(){
    /* your code here */
    PNG res(width, height);
    renderHelper(res, root);
    return res;
}

void twoDtree::renderHelper(PNG&amp;amp; res, Node* cur_node){
    if(!cur_node) return;   //ç¨å¾®å¤šä½™

    if(cur_node-&amp;gt;left == cur_node-&amp;gt;right){
        //åªæœ‰ä¸¤ä¸ªéƒ½æ˜¯ç©ºä¹Ÿå°±æ˜¯å¶å­èŠ‚ç‚¹æ‰ä¼šè¿›è¡Œæ“ä½œ
        for(int i = cur_node-&amp;gt;upLeft.first; i &amp;lt;= cur_node-&amp;gt;lowRight.first; i++)
        for(int j = cur_node-&amp;gt;upLeft.second; j &amp;lt;= cur_node-&amp;gt;lowRight.second; j++){
            *res.getPixel(i, j) = cur_node-&amp;gt;avg;
        }
        return ;
    }
    else{
        renderHelper(res, cur_node-&amp;gt;left);
        renderHelper(res, cur_node-&amp;gt;right);
    }
}




void twoDtree::prune(double pct, int tol){
    /* your code here */
    //å…ˆé€å±‚éå†ï¼Œå¯¹æ¯ä¸ªèŠ‚ç‚¹åˆ¤æ–­æ˜¯å¦éœ€è¦å‰ªæ
    queue&amp;lt;Node*&amp;gt; traverse_save;
    Node* cur;
    int sum, total; //å°äºtolä¸ªæ•°ï¼ŒçŸ©å½¢åƒç´ æ•°
    double rate;
    traverse_save.push(root);
    while(!traverse_save.empty()){
        cur = traverse_save.front();
        traverse_save.pop();

        if(cur == NULL)
            continue;
        sum = pruneHelper(cur, tol, cur-&amp;gt;avg);
        total = (cur-&amp;gt;lowRight.first-cur-&amp;gt;upLeft.first+1)*(cur-&amp;gt;lowRight.second-cur-&amp;gt;upLeft.second+1);
        rate = sum / total;

        if(rate &amp;gt;= pct){
            removeNode(cur-&amp;gt;left);
            cur-&amp;gt;left = NULL;
            removeNode(cur-&amp;gt;right);
            cur-&amp;gt;right = NULL;
        }
        else{
            traverse_save.push(cur-&amp;gt;left);
            traverse_save.push(cur-&amp;gt;right);
        }
    }
}

int twoDtree::pruneHelper(Node* cur, int tol, RGBAPixel avg){
    if(!cur)
        return 0;
    
    //åªè®¡ç®—å¶å­
    if(cur-&amp;gt;left == NULL &amp;amp;&amp;amp; cur-&amp;gt;right == NULL){
        long diff = (avg.r - cur-&amp;gt;avg.r)*(avg.r - cur-&amp;gt;avg.r) + (avg.g - cur-&amp;gt;avg.g)*(avg.g - cur-&amp;gt;avg.g) + (avg.b - cur-&amp;gt;avg.b);
        if(diff &amp;lt;= tol)
            return 1;
        else return 0;
    }
    return pruneHelper(cur-&amp;gt;left, tol, avg) + pruneHelper(cur-&amp;gt;right, tol, avg);
}
void twoDtree::clear() {
    /* your code here */
    removeNode(root);
    root = NULL;
}

void twoDtree::removeNode(Node * x){
    if(!x) return ;
    removeNode(x-&amp;gt;left);
    removeNode(x-&amp;gt;right);
    delete x;
    return ;
}

void twoDtree::copy(const twoDtree &amp;amp; orig){
    /* your code here */
    //å·²ç»å¯¹copyè¿›è¡Œäº†è¯´æ˜ï¼Œä¸éœ€è¦è¿›è¡Œç©ºé—´é‡Šæ”¾
    //æœ¬ç¨‹åºä¸­ä»…æœ‰ä¸¤æ¬¡è°ƒç”¨ï¼Œè°ƒç”¨ä¹‹å‰éƒ½ä¿è¯ç©ºé—´å·²ç»è¢«åˆå§‹åŒ–
    height = orig.height;
    width = orig.width;
    root = copyNode(orig.root);
}

twoDtree::Node*  twoDtree::copyNode(const Node* x){
    if(!x) return NULL;
    Node *tmp = new Node(x-&amp;gt;upLeft, x-&amp;gt;lowRight, x-&amp;gt;avg);
    tmp-&amp;gt;left = copyNode(x-&amp;gt;left);
    tmp-&amp;gt;right = copyNode(x-&amp;gt;right);
    return tmp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ç»“æœåˆ†æ&#34;&gt;ç»“æœåˆ†æ&lt;/h2&gt;

&lt;p&gt;ç¨‹åºåœ¨wslä¸‹ç¼–è¯‘å®Œæˆï¼Œåœ¨mainå‡½æ•°ä¸­æ·»åŠ äº†æ˜¾ç¤ºæ—¶é—´çš„éƒ¨åˆ†ä»£ç ï¼Œä»ç¼–è¯‘åˆ°ç¨‹åºç»“æŸçš„æ•´ä¸ªè¿‡ç¨‹å¦‚ä¸‹å›¾ï¼Œå¯¹wslç”¨æˆ·åè¿›è¡Œäº†ä¸€ä¸‹å¤„ç†ï¼Œä¸è¿‡ä¸å½±å“è§‚å¯Ÿã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134416.png&#34; alt=&#34;ç¼–è¯‘è¿è¡Œ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ä¸‹é¢ç®€å•è¯´ä¸€ä¸‹å›¾ç‰‡çš„ç”Ÿæˆæƒ…å†µï¼Œè‡ªå·±ç¨‹åºç”Ÿæˆçš„å›¾ç‰‡å’Œç¤ºä¾‹å›¾ç‰‡å–å¾—äº†å¤§ä½“ä¸€è‡´çš„æ•ˆæœï¼Œä½†åœ¨ç»†èŠ‚ä¿ç•™æ–¹é¢ä»¥åŠå›¾ç‰‡ç¾è§‚ç¨‹åº¦ä¸Šç¨é€Šä¸€ç­¹ã€‚ä¸¤ä¸ªäººåƒç”»éƒ½èƒ½åšåˆ°è¿‘ä¹ä¸€è‡´çš„ä¿ç•™ï¼Œä½†ç¨åŠ è§‚å¯Ÿä¾¿å¯å‘ç°ç»†èŠ‚ä¿ç•™ä¸Šçš„å·®è·ï¼Œä¸‹å›¾å³ä¾§å˜´å”‡éƒ¨åˆ†å¤„ç†è¿œä¸å¦‚å·¦ä¾§ï¼ˆæ•ˆæœç¤ºä¾‹ï¼‰ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134507.png&#34; alt=&#34;äººåƒå¯¹æ¯”&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ä¸¤ç»„å›¾è…¾çš„å›¾ç‰‡ï¼Œç»†èŠ‚è¾ƒå¤šçš„å›¾ç‰‡æ•ˆæœç›´åœ¨å‡ å¤„å¾®å°å¤„å‡ºç°äº†ä¸åŒï¼Œå› ä¸ºå¤§å¤šæ•°åƒç´ éƒ½è¢«ä¿ç•™ä¸å…·å¤‡è¾ƒå¤§çš„å¯¹æ¯”ä»·å€¼ï¼Œåœ¨è¿™é‡Œä¸è¿›è¡Œè¯¦ç»†å¯¹æ¯”ã€‚è€Œå¦ä¸€å¼ åˆ™è¡¨ç°å‡ºäº†æå¤§çš„å·®åˆ«ã€‚å¾ˆå®¹æ˜“çœ‹å‡ºï¼Œæ ‘ä¸›çš„ç»†èŠ‚åœ¨æˆ‘çš„ç¨‹åºä¸­åˆ é™¤çš„ç¨‹åº¦è¾ƒé‡ï¼Œè¯¯å·®æœ€å¤§çš„ä¸€éƒ¨åˆ†ç”šè‡³ç›´æ¥å‡ºç°äº†è¾ƒå¤§çš„å•è‰²çŸ©å½¢å—ã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/compression/20190503142116.png&#34; alt=&#34;å›¾è…¾å¯¹æ¯”&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;ç®€å•åˆ†æ&#34;&gt;ç®€å•åˆ†æ&lt;/h3&gt;

&lt;p&gt;æˆ‘ä¸ªäººè®¤ä¸ºæˆ‘çš„ä»£ç å®ç°æ²¡æœ‰å¤ªå¤§çš„é—®é¢˜ï¼Œéƒ½æ»¡è¶³äº†é¢˜ç›®çš„è¦æ±‚ã€‚æ‰€ç»™ä»£ç ä¸­ç»™å®šçš„pctå’Œtolå€¼å¯èƒ½é€‚åˆäºè·‘å‡ºç¤ºä¾‹å›¾ç‰‡çš„ä»£ç ï¼Œå¯¹æˆ‘çš„ä»£ç è¾¾åˆ°ä¸äº†è¾ƒå¥½çš„ä¿å­˜ç¨‹åº¦ã€‚è¿™ç‚¹æ˜¯å¯ä»¥ç†è§£çš„ã€‚&lt;/p&gt;

&lt;p&gt;ä¸åŒäººæœ‰ä¸åŒçš„å®ç°æ–¹å¼ï¼Œä¸åŒçš„å®ç°ä¼šå¸¦æ¥ä¸åŒçš„æ•ˆæœï¼Œæ¨ªåˆ‡è¿˜æ˜¯ç«–åˆ‡çš„é€‰æ‹©ï¼Œæ•°æ®çš„è®¡ç®—è¡¨è¾¾å¼çš„ä¹¦å†™æ–¹å¼ç­‰å› ç´ éƒ½ä¼šå¸¦æ¥å½±å“ï¼Œæ¶‰åŠåˆ°æµ®ç‚¹æ•°ï¼Œè®¡ç®—æœºå†…éƒ¨é‡‡ç”¨çš„æ˜¯è¿‘ä¼¼è®¡ç®—ï¼Œèµ·åˆå¾®å°çš„è¯¯å·®ç»å†åç»­è®¡ç®—ä¹‹åå¯èƒ½ä¼šæ”¾å¤§å¾ˆå¤šå€ã€‚æ‰€ä»¥æ•ˆæœæœ‰åå·®æ˜¯æƒ…ç†ä¹‹ä¸­çš„äº‹æƒ…ã€‚&lt;/p&gt;

&lt;p&gt;å¯¹äºæœ€åå›¾è…¾å›¾ç‰‡çš„è¾ƒå¤§è‰²å—é—®é¢˜ï¼Œå‡å¦‚å‚æ•°çœŸçš„ä¸€è‡´ï¼Œé‚£å°±åº”è¯¥æ˜¯æˆ‘çš„ç®—æ³•æœ‰ä¸€äº›æ¼æ´ï¼Œç»†èŠ‚å¤„ç†æ—¶æœ‰ä¸€å®šçš„é—®é¢˜ã€‚&lt;/p&gt;

&lt;h2 id=&#34;æ€»ç»“ä½“ä¼š&#34;&gt;æ€»ç»“ä½“ä¼š&lt;/h2&gt;

&lt;p&gt;æˆ‘ç”¨äº†ä¸€å‘¨çš„æ—¶é—´å»æƒ³é«˜æ•ˆçš„å‰ªæéå†è§£å†³æ–¹å¼ï¼Œå¤±è´¥ä¹‹åé‡‡ç”¨æˆ‘èµ·åˆè®¤ä¸ºæœ€ç¬¨æœ€éº»çƒ¦çš„æ–¹å¼å®ç°äº†å‰ªæå‡½æ•°ï¼Œæœ€ç»ˆçš„è¿è¡Œæ—¶é—´å¦æˆ‘å¾ˆæ„å¤–ï¼Œæˆ‘æ„Ÿè§‰æˆ‘ä¸€ç›´éƒ½åœ¨ä½ä¼°è‡ªå·±ç”µè„‘çš„è¿ç®—èƒ½åŠ›ï¼Œå¤§å¤šæ•°æƒ…å†µéƒ½åªåœç•™äºæ„Ÿè§‰ï¼Œæ²¡æœ‰è¿›è¡Œè¾ƒä¸ºç§‘å­¦çš„åˆ¤æ–­å’Œæ¨ç†ï¼Œä»Šååº”è¯¥åŠ å¼ºè‡ªå·±è¿™æ–¹é¢çš„ä¼°ç®—èƒ½åŠ›ã€‚å¦å¤–å¦‚æœå¯ä»¥çš„è¯ï¼Œæˆ‘æƒ³çŸ¥é“æœ‰æ²¡æœ‰æ›´é«˜æ•ˆçš„ç®—æ³•ï¼Œå› ä¸ºå››å¼ å›¾ç‰‡17ç§’çš„é€Ÿåº¦è¿˜æ˜¯å¾ˆæ…¢ã€‚ğŸ˜•&lt;/p&gt;

&lt;p&gt;å¦å¤–åœ¨å¸®åˆ«äººè°ƒè¯•ä»£ç çš„æ—¶å€™å‘ç°äº†winå’Œlinuxä¸‹longå‹æ‰€å å†…å­˜çš„ä¸åŒï¼Œè¿™å¯¼è‡´ä¸¤ç§ç¯å¢ƒä¸‹longå‹å¯¹åº”çš„æœ€å¤§å€¼ä¹Ÿä¸åŒï¼Œåœ¨winä¸‹ç¼–è¯‘å‡ºæ¥çš„ç¨‹åºåœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¼šç›´æ¥è¶Šç•Œï¼Œéœ€è¦æ¢ç”¨long long ç±»å‹ã€‚è¿™æ¬¡ç¼–ç¨‹å› ä¸ºä¹‹å‰æ²¡æœ‰ç”¨vscodeå»ºè¿‡å·¥ç¨‹æ‰€ä»¥ä½¿ç”¨wslè¿›è¡Œçš„ç¼–è¯‘ã€‚ç¨‹åºä¸­æœ‰éƒ¨åˆ†ä»£ç ç›´æ¥åœ¨winä¸‹ç¼–è¯‘ä¹Ÿä¼šæœ‰ä¸€ç‚¹ç‚¹å°é—®é¢˜ï¼Œè¿™éš¾é“ä¹Ÿæ˜¯linuxçš„ä¼˜åŠ¿ğŸï¼Ÿ&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>æ•°æ®ç»“æ„ä½œä¸šä¸‰ åˆ—è½¦è°ƒåº¦</title>
      <link>https://wanakiki.github.io/2019/train/</link>
      <pubDate>Sun, 21 Apr 2019 10:41:45 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/train/</guid>
      <description>

&lt;p&gt;æœ¬æ¬¡ä½œä¸šä¸éœ€æäº¤æŠ¥å‘Šã€‚
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2 id=&#34;é¢˜ç›®æè¿°&#34;&gt;é¢˜ç›®æè¿°&lt;/h2&gt;

&lt;p&gt;Input&lt;/p&gt;

&lt;p&gt;å…±ä¸¤è¡Œã€‚&lt;/p&gt;

&lt;p&gt;ç¬¬ä¸€è¡Œä¸ºä¸¤ä¸ªæ•´æ•°nï¼Œmã€‚&lt;/p&gt;

&lt;p&gt;ç¬¬äºŒè¡Œä¸ºä»¥ç©ºæ ¼åˆ†éš”çš„nä¸ªæ•´æ•°ï¼Œä¿è¯ä¸º{1, 2, &amp;hellip;, n}çš„ä¸€ä¸ªæ’åˆ—ï¼Œè¡¨ç¤ºå¾…åˆ¤æ–­å¯è¡Œæ€§çš„é©¶å‡ºåºåˆ—{a1ï¼Œa2ï¼Œ&amp;hellip;ï¼Œan}ã€‚&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;p&gt;è‹¥é©¶å‡ºåºåˆ—å¯è¡Œï¼Œåˆ™è¾“å‡ºæ“ä½œåºåˆ—ï¼Œå…¶ä¸­pushè¡¨ç¤ºè½¦å¢ä»Aè¿›å…¥Sï¼Œpopè¡¨ç¤ºè½¦å¢ä»Sè¿›å…¥Bï¼Œæ¯ä¸ªæ“ä½œå ä¸€è¡Œã€‚&lt;/p&gt;

&lt;p&gt;è‹¥ä¸å¯è¡Œï¼Œåˆ™è¾“å‡ºNoã€‚&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;Sample Input 1 

5 2
1 2 3 5 4
Sample Output 1

push
pop
push
pop
push
pop
push
push
pop
pop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ä»£ç &#34;&gt;ä»£ç &lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

int main(){
    int n, m;
    int B[10000];   //Bé˜Ÿåˆ—
    bool step[20005];   //è®°å½•æ“ä½œ 0å‹å…¥ 1å¼¹å‡º
    bool flag = false;  //æ ‡è®°æ˜¯å¦å‡ºç°é”™è¯¯
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    stack&amp;lt;int&amp;gt; s;   //ä»£è¡¨ä¸­è½¬ç«¯
    
    for(int i = 0; i &amp;lt; n; i++){
        cin &amp;gt;&amp;gt; B[i];
    }

    int i = 1, j = 0, k = 0;  //å½“å‰æ•°å­—i æ“ä½œæ­¥éª¤æ ‡è®°j Bé˜Ÿåˆ—ç´¢å¼•k
    while(i &amp;lt;= n){
        if(s.empty()){
            s.push(i++);
            step[j++] = 0;
        }
        else{
            if(s.top() == B[k]){
                s.pop();
                step[j++] = 1;
                k++;
            }
            else{
                s.push(i++);
                step[j++] = 0;
                if(s.size() &amp;gt; m){
                    flag = 1;
                    break;
                }
            }
        }
    }

    //å‰©ä½™å…ƒç´ çš„å¼¹å‡ºè®¨è®º
    while(!s.empty()){
        if(s.top() != B[k]){
            flag = 1;
            break;
        }
        else{
            s.pop();
            step[j++] = 1;
            k++;
        }
    }

    if(flag)
        cout &amp;lt;&amp;lt; &amp;quot;no&amp;quot;;
    else{
        for(int l = 0; l &amp;lt; j; l++){
            if(step[l])
                cout &amp;lt;&amp;lt; &amp;quot;pop&amp;quot;;
            else
                cout &amp;lt;&amp;lt; &amp;quot;push&amp;quot;;
            cout &amp;lt;&amp;lt; endl;
        }
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb39a396b3.png&#34; alt=&#34;æµ‹è¯•&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>æ•°æ®ç»“æ„ä½œä¸šäºŒ List ADT</title>
      <link>https://wanakiki.github.io/2019/list-adt/</link>
      <pubDate>Sat, 20 Apr 2019 20:22:40 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/list-adt/</guid>
      <description>

&lt;h2 id=&#34;é—®é¢˜åˆ†æ&#34;&gt;é—®é¢˜åˆ†æ&lt;/h2&gt;

&lt;p&gt;é¢˜ç›®è¦æ±‚è‡ªè¡Œå®ç°list ADTï¼Œå¹¶åœ¨æ­¤åŸºç¡€ä¸Šå®ç°PrintLotså‡½æ•°å¹¶ä¸”å®ç°æ‡’æƒ°åˆ é™¤åŠŸèƒ½ã€‚å¯¹äºPrintLotså‡½æ•°ï¼Œé¢˜ç›®è¦æ±‚åˆ†æè¿è¡Œæ—¶é—´ï¼›å¯¹äºæ‡’æƒ°åˆ é™¤åŠŸèƒ½ï¼Œé™¤ç¼–å†™å®ç°å¤–ï¼Œé¢˜ç›®è¿˜è¦æ±‚åˆ—å‡ºæ‡’æƒ°åˆ é™¤çš„ä¼˜ç‚¹å’Œç¼ºç‚¹ã€‚&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PrintLots(L,P)&lt;/strong&gt;ï¼šæœ‰ä¸¤ä¸ªé“¾è¡¨Lå’ŒP, ä»–ä»¬åŒ…å«ä»¥å‡åºæ’åˆ—çš„æ•´æ•°ï¼Œæ“ä½œPrintLots(L,P)å°†æ‰“å°Lä¸­é‚£äº›ç”±Pæ‰€æŒ‡å®šä½ç½®ä¸Šçš„å…ƒç´ ã€‚&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;æ‡’æƒ°åˆ é™¤ï¼ˆlazy deletionï¼‰&lt;/strong&gt;ï¼šä¸ºäº†åˆ é™¤ä¸€ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬åªæ ‡è®°ä¸Šè¯¥å…ƒç´ è¢«åˆ é™¤ã€‚è¡¨ä¸­è¢«åˆ é™¤å’Œéè¢«åˆ é™¤å…ƒç´ çš„ä¸ªæ•°ä½œä¸ºæ•°æ®ç»“æ„çš„ä¸€éƒ¨åˆ†è¢«ä¿ç•™ã€‚å¦‚æœè¢«åˆ é™¤å…ƒç´ å’Œéè¢«åˆ é™¤å…ƒç´ ä¸€æ ·å¤šï¼Œæˆ‘ä»¬éå†æ•´ä¸ªè¡¨ï¼Œå¯¹æ‰€æœ‰è¢«æ ‡è®°çš„èŠ‚ç‚¹æ‰§è¡Œæ ‡å‡†çš„åˆ é™¤ç®—æ³•ã€‚&lt;/p&gt;

&lt;h2 id=&#34;è§£å†³æ–¹æ¡ˆ&#34;&gt;è§£å†³æ–¹æ¡ˆ&lt;/h2&gt;

&lt;p&gt;è®¾è®¡list ADTï¼Œå‡†å¤‡å¥½PrintLotså‡½æ•°æ‰€éœ€è¦çš„æ¥å£ã€‚ä¸»æ–‡ä»¶å¼•ç”¨è‡ªå·±ç¼–å†™çš„list ADTï¼Œå¹¶åœ¨ä¸»æ–‡ä»¶ä¸­å®Œæˆå¯¹PrintLotså‡½æ•°çš„å®ç°ï¼Œæ‡’æƒ°åˆ é™¤åˆ™å¯ä»¥ç›´æ¥å°è£…åœ¨ADTä¸­ã€‚ç”±äºæœ¬æ¬¡å®éªŒç¼ºä¹ç¤ºä¾‹è¾“å…¥è¾“å‡ºï¼Œå› æ­¤è¿˜è¦å¯¹è¾“å…¥è¾“å‡ºéƒ¨åˆ†ç¨å¾®åŠ ä»¥è®¾è®¡ï¼Œåœ¨æ­¤ä¸å¤šèµ˜è¿°ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç®—æ³•è®¾è®¡&#34;&gt;ç®—æ³•è®¾è®¡&lt;/h2&gt;

&lt;p&gt;list ADTçš„å®ç°å¤§ä½“å¯ä»¥æŒ‰ç…§è¯¾æœ¬æ‰€ç»™çš„æ¡†æ¶æ¥åˆæ­¥æ„å»ºï¼Œä¹‹åå¯¹å…¶è¿›è¡Œä¸°å¯Œï¼Œé¦–å…ˆå®ç°èŠ‚ç‚¹ç±»ï¼Œå†è¿›ä¸€æ­¥å®ç°Listç±»ã€‚è€ƒè™‘åˆ°æ‡’æƒ°åˆ é™¤çš„éœ€è¦ï¼Œåœ¨å®ç°èŠ‚ç‚¹ç±»çš„æ—¶å€™æˆ‘åœ¨å…¶ä¸­åŠ å…¥äº†æ˜¯å¦åˆ é™¤çš„æ ‡å¿—ï¼Œå®ç°Listç±»æ—¶å¢åŠ äº†ç”¨äºç»Ÿè®¡ä¼ªåˆ é™¤å…ƒç´ ä¸ªæ•°çš„å˜é‡ã€‚ä¸ºäº†æ›´è¿›ä¸€æ­¥è´´åˆæ ‡å‡†æ¨¡æ¿åº“çš„æ“ä½œï¼Œç›¸å¯¹å¤šæ­¤ä¸€ä¸¾åœ°åŠ å…¥äº†è¿­ä»£å™¨å­ç±»ã€‚ï¼ˆå®è·µè¯æ˜ï¼Œæˆ‘å¯¹è¿­ä»£å™¨ç›¸å…³çŸ¥è¯†çš„äº†è§£å¹¶ä¸å……åˆ†&amp;hellip;ğŸ˜•ï¼‰&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb39389ad9.jpg&#34; alt=&#34;ç»“æ„ç¤ºæ„&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;printlotså‡½æ•°&#34;&gt;PrintLotså‡½æ•°&lt;/h3&gt;

&lt;p&gt;å› ä¸ºä¸¤ä¸ªé“¾è¡¨çš„å…ƒç´ éƒ½æ˜¯å‡åºæ’åˆ—çš„ï¼Œæ‰€ä»¥Lçš„è¿­ä»£å™¨å¯ä»¥ä¸€ç›´å‘ä¸€ä¸ªæ–¹å‘ç§»åŠ¨ï¼Œæ•´ä¸ªå‡½æ•°çš„å®ç°é™ä½äº†ä¸€äº›éš¾åº¦ã€‚å®šä¹‰ä¸€ä¸ªæ•´å½¢å˜é‡ç”¨æ¥è®°å½•å½“å‰Lçš„è¿­ä»£å™¨æŒ‡å‘ä½ç½®çš„ç¼–å·ï¼Œç¼–å·è‹¥ä¸Pçš„è¿­ä»£å™¨æŒ‡å‘çš„å…ƒç´ ç›¸åŒåˆ™è¿›è¡Œè¾“å‡ºï¼ŒåŒæ—¶ä¸¤ä¸ªè¿­ä»£å™¨å‘åç§»åŠ¨ã€‚è‹¥ç¼–å·ä¸På½“å‰å…ƒç´ ä¸åŒï¼Œåˆ™æŒ‡å‘Lçš„è¿­ä»£å™¨å‘åç§»åŠ¨ã€‚å‡½æ•°çš„ç»ˆæ­¢æ¡ä»¶ä¸ºé“¾è¡¨Péå†ç»“æŸã€‚&lt;/p&gt;

&lt;h4 id=&#34;å¤æ‚åº¦åˆ†æ&#34;&gt;å¤æ‚åº¦åˆ†æ&lt;/h4&gt;

&lt;p&gt;ä»æ•´ä½“ä¸Šæ¥çœ‹ï¼ŒPrintLotså‡½æ•°åªæ˜¯ä¸¤ä¸ªé“¾è¡¨çš„å•å‘éå†è¾“å‡ºï¼Œåªæ˜¯ç»†èŠ‚æ–¹é¢ç¨å¾®å¤æ‚ï¼Œä½†å¼•å…¥çš„å‡ä¸ºå¸¸æ•°æ—¶é—´å¯ä»¥å®Œæˆçš„æ“ä½œã€‚å› ä¸ºPçš„å…ƒç´ ä¸ªæ•°ä¸å¯èƒ½è¶…è¿‡Lçš„å…ƒç´ ä¸ªæ•°ï¼Œæ‰€ä»¥æœ€åæƒ…å†µä¾¿æ˜¯è¾“å‡ºäº†Lçš„æ‰€æœ‰å…ƒç´ ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚&lt;/p&gt;

&lt;h3 id=&#34;æ‡’æƒ°åˆ é™¤&#34;&gt;æ‡’æƒ°åˆ é™¤&lt;/h3&gt;

&lt;p&gt;å‡½æ•°å‚æ•°ä¸ºæŒ‡å‘è¦åˆ é™¤å…ƒç´ çš„è¿­ä»£å™¨ï¼Œå‡½æ•°é€šè¿‡è¿­ä»£å™¨è®¿é—®è¯¥å…ƒç´ å†…éƒ¨çš„åˆ é™¤æ ‡å¿—ï¼Œå¹¶å¯¹å…¶è¿›è¡Œä¿®æ”¹ã€‚ä¿®æ”¹ä¹‹åæ£€æŸ¥å½“å‰ä¼ªåˆ é™¤å…ƒç´ çš„æ€»æ•°ï¼Œå¤§äºæ€»å…ƒç´ ä¸€èˆ¬å¯¹æ•´ä¸ªé“¾è¡¨è¿›è¡Œéå†åˆ é™¤ã€‚æ€»ä½“å®ç°ç›¸å¯¹ç®€å•ã€‚&lt;/p&gt;

&lt;h4 id=&#34;æ‡’æƒ°åˆ é™¤ä¼˜ç¼ºç‚¹åˆ†æ&#34;&gt;æ‡’æƒ°åˆ é™¤ä¼˜ç¼ºç‚¹åˆ†æ&lt;/h4&gt;

&lt;p&gt;ä¼˜ç‚¹ï¼šè¯¯åˆ æ•°æ®æœ‰æ¢å¤çš„ç©ºé—´ï¼Œæœªè¢«é‡Šæ”¾çš„ç©ºé—´å¯ä»¥è¿›è¡ŒäºŒæ¬¡åˆ©ç”¨ï¼Œå‡å°‘äº†èµ„æºæ¶ˆè€—è¾ƒå¤§çš„åˆ é™¤è¿‡ç¨‹çš„éœ€æ±‚æ¬¡æ•°ï¼ˆé“¾è¡¨ä¸­ä½“ç°ä¸æ˜æ˜¾ï¼‰ã€‚
ç¼ºç‚¹ï¼šè®°å½•å…ƒç´ ä¼ªåˆ é™¤éœ€è¦é¢å¤–çš„æ“ä½œå’Œç©ºé—´ï¼Œè¢«åˆ é™¤çš„èŠ‚ç‚¹ä¸åŠæ—¶é‡Šæ”¾å¢åŠ äº†ç©ºé—´çš„å ç”¨ï¼Œä¹Ÿæé«˜äº†éƒ¨åˆ†æ“ä½œæ‰€éœ€çš„æ—¶é—´ã€‚&lt;/p&gt;

&lt;h2 id=&#34;æµç¨‹å›¾&#34;&gt;æµç¨‹å›¾&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb3959aa95.jpg&#34; alt=&#34;lazy deletion&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ç¼–ç¨‹å®ç°&#34;&gt;ç¼–ç¨‹å®ç°&lt;/h2&gt;

&lt;p&gt;å…±ç¼–å†™äº†ä¸‰ä¸ªæ–‡ä»¶ï¼šlistnode.hã€my_list.hã€main.cpp&lt;/p&gt;

&lt;p&gt;1.listnode.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    #include&amp;lt;iostream&amp;gt;
    using namespace std;

    //å®šä¹‰åˆ—è¡¨çš„èŠ‚ç‚¹
    template &amp;lt;typename T&amp;gt; struct ListNode
    {
        T data;
        ListNode&amp;lt;T&amp;gt;* pred;
        ListNode&amp;lt;T&amp;gt;* succ;
        bool need_remove;   //need_removeä¸ºäº†æ–¹ä¾¿æ‡’æƒ°æ¶ˆé™¤

        ListNode() : need_remove(false) {}
        ListNode(T e, ListNode&amp;lt;T&amp;gt;* p = NULL, ListNode&amp;lt;T&amp;gt;* s = NULL)
            : data(e), pred(p), succ(s), need_remove(false) {}

        ListNode&amp;lt;T&amp;gt;* insertAsPred(T const&amp;amp; e);
        ListNode&amp;lt;T&amp;gt;* insertAsSucc(T const&amp;amp; e);
    };

    //å‰æ’å…¥
    template &amp;lt;typename T&amp;gt;
    ListNode&amp;lt;T&amp;gt;* ListNode&amp;lt;T&amp;gt;::insertAsPred(T const&amp;amp; e){
        ListNode&amp;lt;T&amp;gt;* x = new ListNode(e, pred, this);
        pred-&amp;gt;succ = x;
        pred = x;
        return x;
    }

    //åæ’å…¥
    template &amp;lt;typename T&amp;gt;
    ListNode&amp;lt;T&amp;gt;* ListNode&amp;lt;T&amp;gt;::insertAsSucc(T const&amp;amp; e){
        ListNode&amp;lt;T&amp;gt;* x = new ListNode(e, this, succ);
        succ-&amp;gt;pred = x;
        succ = x;
        return x;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.my_list.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;listnode.h&amp;quot;

template &amp;lt;typename T&amp;gt;
class List
{
  private:
    int _size;
    int _num;
    ListNode&amp;lt;T&amp;gt; *header;
    ListNode&amp;lt;T&amp;gt; *trailer;

  protected:
    void init();
    void copyNodes(ListNode&amp;lt;T&amp;gt; *, int);
    //åªå†™å‡ºäº†æœ‰å¯èƒ½ç”¨åˆ°çš„å‡½æ•°

  public:
    List() { init(); } //é»˜è®¤æ„é€ 
    List(List&amp;lt;T&amp;gt; const &amp;amp;L);
    List(List&amp;lt;T&amp;gt; const &amp;amp;L, int r, int n);
    List(ListNode&amp;lt;T&amp;gt; *p, int n);
    int clear();

    ~List(); //ææ„

    class Iterator{
      public:
        ListNode&amp;lt;T&amp;gt; *ptr;

        Iterator() : ptr(NULL) {}
        Iterator(ListNode&amp;lt;T&amp;gt; *tmp) : ptr(tmp) {}

        T operator*(){
            return ptr-&amp;gt;data;
            //ä¸ºç©ºæ—¶å¦‚ä½•æŠ›å‡ºé”™è¯¯ï¼Ÿ
        }

        bool operator==(Iterator const &amp;amp;x) { return ptr == x.ptr; }
        bool operator!=(Iterator const &amp;amp;x) { return ptr != x.ptr; }
        Iterator operator++(int){
            //ä¸èƒ½åœ¨è¿™é‡Œè®¿é—®trailerï¼Œé‚£ä¹ˆæ ‡å‡†çš„è¿­ä»£å™¨æ˜¯æ€ä¹ˆæ“ä½œçš„å‘¢
            Iterator tmp(ptr);
            while(1){
                if(ptr-&amp;gt;succ != NULL)
                    ptr = ptr-&amp;gt;succ;
                if(!ptr-&amp;gt;need_remove)   //ä¸éœ€è¦ç»§ç»­è®¿é—®ï¼Œè·³å‡ºå¾ªç¯
                    break;
            }
            return tmp;
        }
        Iterator operator--(int){
            Iterator tmp(ptr);
            while(1){
                if (ptr-&amp;gt;pred != NULL)
                    ptr = ptr-&amp;gt;pred;
                if(!ptr-&amp;gt;need_remove)
                    break;
            }
            return tmp;
        }
        Iterator&amp;amp; operator++(){
            while(1){
                if(ptr-&amp;gt;succ != NULL)
                    ptr = ptr-&amp;gt;succ;
                if(!ptr-&amp;gt;need_remove)   //ä¸éœ€è¦ç»§ç»­è®¿é—®ï¼Œè·³å‡ºå¾ªç¯
                    break;
            }
            return *this;
        }
        Iterator&amp;amp; operator--(){
            while(1){
                if (ptr-&amp;gt;pred != NULL)
                    ptr = ptr-&amp;gt;pred;
                if(!ptr-&amp;gt;need_remove)
                    break;
            }
            return *this;
        }
    };

    bool empty() const { return _size &amp;lt;= 0; }
    int size() const { return _size-_num; }
    ListNode&amp;lt;T&amp;gt; *insertAsFirst(T const &amp;amp;e);
    ListNode&amp;lt;T&amp;gt; *insertAsLast(T const &amp;amp;e);
    Iterator begin() { return ++Iterator(header); }
    Iterator end() { return Iterator(trailer); }
    ListNode&amp;lt;T&amp;gt; *first() const { return header-&amp;gt;succ; } //firstå’Œbeginå®Œå…¨æ²¡å¿…è¦
    ListNode&amp;lt;T&amp;gt; *last() const { return trailer-&amp;gt;pred; }
    T remove(ListNode&amp;lt;T&amp;gt; *p);
    void lazy_deletion(Iterator i);
    void show();
    void Advance(Iterator &amp;amp;i, int n);
};

template &amp;lt;typename T&amp;gt; //åˆ—è¡¨åˆå§‹åŒ–
void List&amp;lt;T&amp;gt;::init()
{
    header = new ListNode&amp;lt;T&amp;gt;;
    trailer = new ListNode&amp;lt;T&amp;gt;;
    header-&amp;gt;succ = trailer;
    header-&amp;gt;pred = NULL;
    trailer-&amp;gt;pred = header;
    trailer-&amp;gt;succ = NULL;
    _size = 0;
    _num = 0;
}

//å¤åˆ¶è‡ªpå¼€å§‹çš„né¡¹
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::copyNodes(ListNode&amp;lt;T&amp;gt; *p, int n)
{
    init();
    while (n--)
    {
        insertASLast(p-&amp;gt;data);
        p = p-&amp;gt;succ;
    }
}

//Clear()
template &amp;lt;typename T&amp;gt;
int List&amp;lt;T&amp;gt;::clear()
{
    int num = _size;
    if (_size)
    {
        ListNode&amp;lt;T&amp;gt; *p = header-&amp;gt;succ;
        ListNode&amp;lt;T&amp;gt; *tmp;
        while (p != trailer)
        {
            tmp = p-&amp;gt;succ;
            delete p;
            p = tmp;
        }
    }
    _size = 0;
    _num = 0;
    return num;
}

//æ„é€ å‡½æ•°
template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(List&amp;lt;T&amp;gt; const &amp;amp;L) { copyNodes(L.first(), L.size()); }

template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(List&amp;lt;T&amp;gt; const &amp;amp;L, int r, int n)
{
    ListNode&amp;lt;T&amp;gt; *tmp = L.first();
    while (--r)
        tmp = tmp-&amp;gt;succ;
    copyNodes(tmp, n);
}

template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(ListNode&amp;lt;T&amp;gt; *p, int n) { copyNodes(p, n); }

//ææ„å‡½æ•°
template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::~List()
{
    clear();
    delete trailer;
    delete header;
}

template &amp;lt;typename T&amp;gt;
ListNode&amp;lt;T&amp;gt; *List&amp;lt;T&amp;gt;::insertAsFirst(T const &amp;amp;e)
{
    _size++;
    return header-&amp;gt;insertAsSucc(e);
}

template &amp;lt;typename T&amp;gt;
ListNode&amp;lt;T&amp;gt; *List&amp;lt;T&amp;gt;::insertAsLast(T const &amp;amp;e)
{
    _size++;
    return trailer-&amp;gt;insertAsPred(e);
}

//åˆ é™¤
template &amp;lt;typename T&amp;gt;
T List&amp;lt;T&amp;gt;::remove(ListNode&amp;lt;T&amp;gt; *p)
{
    T tmp= p-&amp;gt;data;
    _size--;
    p-&amp;gt;pred-&amp;gt;succ = p-&amp;gt;succ;
    p-&amp;gt;succ-&amp;gt;pred = p-&amp;gt;pred;
    delete p;
    return tmp;
}

template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::lazy_deletion(Iterator i){
    _num++;
    ListNode&amp;lt;T&amp;gt;* tmp = i.ptr;
    tmp-&amp;gt;need_remove = true;

    //æ•°é‡å¤§äºä¸€åŠå¼€å§‹å…¨éƒ¨åˆ é™¤
    if(_num &amp;gt;= _size/2){
        _num = 0;
        ListNode&amp;lt;T&amp;gt; *p = header-&amp;gt;succ;
        while(trailer != p){
            if(!p-&amp;gt;need_remove){
                p = p-&amp;gt;succ;
                continue;
            }
                
            tmp = p-&amp;gt;succ;
            remove(p);
            p = tmp;       
        }
    }
    return ;
}

//è¾“å‡ºæ ¼å¼åŒ–
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::show(){
    if(_size == 0){
        cout &amp;lt;&amp;lt; &amp;quot;None&amp;quot; &amp;lt;&amp;lt; endl;
        return ;
    }
    ListNode&amp;lt;T&amp;gt;* p = header;
    while(trailer != (p = p-&amp;gt;succ)){
        if(p == header-&amp;gt;succ){
            cout &amp;lt;&amp;lt; p-&amp;gt;data;
            continue;
        }
        if(p-&amp;gt;pred-&amp;gt;need_remove &amp;amp;&amp;amp; p-&amp;gt;need_remove)    cout &amp;lt;&amp;lt; &amp;quot;____&amp;quot;;
        else if(p-&amp;gt;need_remove)     cout &amp;lt;&amp;lt; &amp;quot;--__&amp;quot;;
        else if(p-&amp;gt;pred-&amp;gt;need_remove)   cout &amp;lt;&amp;lt; &amp;quot;__-&amp;gt;&amp;quot;;
        else    cout &amp;lt;&amp;lt; &amp;quot;---&amp;gt;&amp;quot;;
        cout &amp;lt;&amp;lt; p-&amp;gt;data;
    }
    return ;
}

//ç”¨äºè¿­ä»£å™¨çš„ç§»åŠ¨
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::Advance(Iterator &amp;amp; i, int n){
    if(n &amp;gt;= 0){
        while(n--)
            i.ptr = i.ptr-&amp;gt;succ;
    }
    else{
        while(n++)
            i.ptr = i.ptr-&amp;gt;pred;
    }
}
//å¦‚æœå‘å®¹å™¨é‡Œé¢æ”¾ä¸ªpairï¼Ÿ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.main.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;my_list.h&amp;quot;


void PrintLots(List&amp;lt;int&amp;gt;&amp;amp; L, List&amp;lt;int&amp;gt;&amp;amp; P){
    int current = 1;

    //æ˜¯å¦å­˜åœ¨ç©ºåºåˆ—
    if(L.empty() || P.empty())  {   cout&amp;lt;&amp;lt;&amp;quot;Error, input is empty&amp;quot;&amp;lt;&amp;lt;endl; return ;}

    List&amp;lt;int&amp;gt;::Iterator l = L.begin();
    List&amp;lt;int&amp;gt;::Iterator p = P.begin();
    while(1){
        if(L.size() &amp;lt; *p){  
            cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;quot;Error, the number of P is bigger than the size of L&amp;quot; &amp;lt;&amp;lt; endl;  
            break;
        }

        if(current++ == *p){
            cout &amp;lt;&amp;lt; *l &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            p++;
        }

        //è¾“å‡ºç»“æŸ
        if(p == P.end()){  
                cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;quot;Finished!&amp;quot; &amp;lt;&amp;lt; endl;
                break;
        }
        l++;
    }
    return ;
}

int main(){
    int m, n, tmp, last;
    int select = 0;
    while(1){
        cout &amp;lt;&amp;lt; &amp;quot;Choose function(0 means lazy_deletion, 1 means PrintLots):&amp;quot;;
        cin &amp;gt;&amp;gt; select;
        if(select){
            List&amp;lt;int&amp;gt; L, P;
            cout &amp;lt;&amp;lt; &amp;quot;Input the size of L and P: &amp;quot;;
            cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of L: &amp;quot; &amp;lt;&amp;lt; endl;
            while (m--){
                cin &amp;gt;&amp;gt; tmp;
                L.insertAsLast(tmp);
            }
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of P: &amp;quot; &amp;lt;&amp;lt; endl;
            while (n--){
                cin &amp;gt;&amp;gt; tmp;
                P.insertAsLast(tmp);
            }
            PrintLots(L, P);
        }
        else{
            List&amp;lt;int&amp;gt; L;
            cout &amp;lt;&amp;lt; &amp;quot;Input the size of L: &amp;quot;;
            cin &amp;gt;&amp;gt; m;
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of L:&amp;quot; &amp;lt;&amp;lt; endl;
            for(int j = 0; j &amp;lt; m; j++){
                cin &amp;gt;&amp;gt; tmp;
                L.insertAsLast(tmp);
            }
            cout &amp;lt;&amp;lt; &amp;quot;L is: &amp;quot;;
            L.show();
            cout&amp;lt;&amp;lt;endl;


            List&amp;lt;int&amp;gt;::Iterator i = L.begin();
            last = 1;
            cout &amp;lt;&amp;lt; &amp;quot;How many elements do you want to delete? &amp;quot;;
            cin &amp;gt;&amp;gt; n;
            cout &amp;lt;&amp;lt; &amp;quot;Input them(from 1 to &amp;quot; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;quot;)&amp;quot; &amp;lt;&amp;lt; endl;
            while(n--){
                cin &amp;gt;&amp;gt; tmp;
                L.Advance(i, tmp-last);
                last = tmp;
                L.lazy_deletion(i);
            }
            cout &amp;lt;&amp;lt; &amp;quot;Now L is: &amp;quot;;
            L.show();
            cout &amp;lt;&amp;lt; endl;
        } 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ç»“æœåˆ†æ&#34;&gt;ç»“æœåˆ†æ&lt;/h2&gt;

&lt;p&gt;PrintLotsè¿›è¡Œäº†å››ç»„æµ‹è¯•ï¼Œä»æµ‹è¯•ç»“æœå¯ä»¥çœ‹å‡ºå¯¹é”™è¯¯æƒ…å†µè¿›è¡Œäº†æœ‰æ•ˆçš„åˆ¤æ–­ï¼Œå¹¶ä¸”èƒ½å¤Ÿå¤„ç†ä¸€èˆ¬æƒ…å†µã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb396983b0.jpg&#34; alt=&#34;PrintLotsæµ‹è¯•&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ä¸ºäº†æ–¹ä¾¿æ‡’æƒ°åˆ é™¤çš„æŸ¥çœ‹ï¼Œè®¾ç½®äº†ä¸€ä¸ªå‡½æ•°ç”¨æ¥è¡¨ç°é“¾è¡¨å½“å‰çš„æƒ…å†µï¼ŒåŒæ—¶è¿›è¡Œäº†ä¸‰ç§æ ·ä¾‹çš„æµ‹è¯•ï¼Œèƒ½å¤Ÿä»£è¡¨æ‰€æœ‰ç±»å‹çš„æ»¡è¶³è¦æ±‚çš„è¾“å…¥æƒ…å†µã€‚å¯ä»¥å¾ˆå®¹æ˜“çš„çœ‹å‡ºå½“åˆ é™¤å…ƒç´ è¿‡åŠæ—¶æŒ‰è¦æ±‚å®Œæˆäº†æ“ä½œã€‚&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb3979a5b2.jpg&#34; alt=&#34;æ‡’æƒ°åˆ é™¤æµ‹è¯•&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;æ€»ç»“ä½“ä¼š&#34;&gt;æ€»ç»“ä½“ä¼š&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;æ·±åˆ»æ„Ÿè§‰åˆ°è‡ªå·±çš„å®è§‚æ€ç»´æœ‰æå¤§çš„æ¬ ç¼ºï¼Œè‡ªå·±è®¾è®¡å‡ºçš„ç±»ä¸­çš„å‡½æ•°ä¸èƒ½å¾ˆå¥½åœ°è¡”æ¥ï¼Œç¼–ç¨‹æ€ç»´æœ‰é—®é¢˜ã€‚&lt;/li&gt;
&lt;li&gt;è‡ªå·±å†™çš„è¿­ä»£å™¨å¯èƒ½ç§°ä¸ä¸Šæ˜¯è¿­ä»£å™¨ï¼Œåªæ˜¯ç¨å¾®åŒ…è£…äº†ä¸€ä¸‹æŒ‡é’ˆã€‚è‡ªå·±æµ‹è¯•çš„æ—¶å€™å‘ç°åœ¨iteratorå·²ç»è¢«å®šä¹‰ï¼Œæ„è¯†åˆ°å¹³æ—¶æ‰€ç”¨çš„è¿­ä»£å™¨å¹¶ä¸æ˜¯å®šä¹‰åœ¨å®¹å™¨çš„å¤´æ–‡ä»¶ä¸­ã€‚&lt;/li&gt;
&lt;li&gt;è¾¹ç•Œç­‰ç‰¹æ®Šæƒ…å†µæ²¡æœ‰å¾—åˆ°å¾ˆå¥½çš„å¤„ç†ï¼Œä¸è¿‡èƒ½å¤Ÿä¿è¯åœ¨è¾“å…¥è§„èŒƒçš„æƒ…å†µä¸‹å¾—åˆ°è‰¯å¥½çš„ç»“æœï¼Œä»£ç æ€»ä½“æœ‰å¾…å®Œå–„ã€‚ï¼ˆæ€»ä¹‹è¿˜æ˜¯å¯¹æ ‡å‡†æ¨¡æ¿åº“ç‰¹æ®Šæƒ…å†µå¤„ç†æ–¹å¼ä¸å¤Ÿäº†è§£ğŸ“Œ&lt;/li&gt;
&lt;li&gt;å¾ˆå¤šç”¨ä¸åˆ°çš„ä¸œè¥¿ä¹Ÿè¿›è¡Œäº†å®ç°ï¼Œå¯¼è‡´ä»£ç é‡ç›¸å¯¹è¾ƒå¤§ğŸ˜“&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>æ•°æ®ç»“æ„ä½œä¸šä¸€ Zuma List</title>
      <link>https://wanakiki.github.io/2019/zuma-list/</link>
      <pubDate>Sat, 20 Apr 2019 19:41:55 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/zuma-list/</guid>
      <description>

&lt;p&gt;æ•°æ®ç»“æ„ç¬¬ä¸€æ¬¡ä½œä¸šã€‚&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;é—®é¢˜åˆ†æ&#34;&gt;é—®é¢˜åˆ†æ&lt;/h2&gt;

&lt;p&gt;é¢˜ç›®è¦æ±‚ä¹¦å†™ç¨‹åºå¯¹ç¥–ç›æ¶ˆé™¤è¿‡ç¨‹è¿›è¡Œå›æ”¾ï¼Œè¾“å…¥ä¸ºåŸå§‹ç å­åºåˆ—ä»¥åŠç©å®¶æ‰€åšçš„ä¸€ç³»åˆ—æ“ä½œï¼Œè¦æ±‚æˆ‘ä»¬æŒ‰ç…§æ¸¸æˆè§„åˆ™è®¡ç®—å‡ºæ¯æ¬¡æ“ä½œåçš„ç å­åºåˆ—å¹¶è¿›è¡Œè¾“å‡ºã€‚&lt;/p&gt;

&lt;p&gt;ç¥–ç›æ¸¸æˆè§„åˆ™ï¼šæœ‰ä¸‰ä¸ªæˆ–æ›´å¤šåŒè‰²ç å­å˜æˆç›¸é‚»å°±ä¼šç«‹å³æ¶ˆå¤±ï¼Œå¹¶ä¸”å¯èƒ½ä¼šå‘ç”Ÿè¿é”ååº”ã€‚&lt;strong&gt;éœ€è¦æ³¨æ„ï¼ŒåŸå§‹æƒ…å†µä¸­å‡ºç°çš„ä¸‰ä¸ªæˆ–æ›´å¤šç›¸é‚»åŒè‰²ç å­ï¼Œåœ¨æ²¡æœ‰æ–°ç å­æˆ–è€…è¿é”ååº”å½±å“æ—¶æ˜¯ä¸ä¼šæ¶ˆé™¤çš„ã€‚&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;è§£å†³æ–¹æ¡ˆ&#34;&gt;è§£å†³æ–¹æ¡ˆ&lt;/h2&gt;

&lt;p&gt;å°†æ–°çš„ç å­æ’å…¥åˆ°åŸæœ‰åºåˆ—ï¼Œåœ¨æ’å…¥ä½ç½®å‘ä¸¤ä¾§åˆ¤æ–­åŒè‰²ç å­ä¸ªæ•°ï¼Œæ»¡è¶³æ¡ä»¶åˆ™è¿›è¡Œåˆ é™¤ã€‚è€ƒè™‘åˆ°åˆ é™¤åçš„è¿é”ååº”ï¼Œéœ€è¦å°†åˆ¤æ–­çš„è¿‡ç¨‹å¾ªç¯æ‰§è¡Œåˆ°æ— æ³•ç»§ç»­åˆ é™¤ã€‚&lt;/p&gt;

&lt;h2 id=&#34;ç®—æ³•è®¾è®¡&#34;&gt;ç®—æ³•è®¾è®¡&lt;/h2&gt;

&lt;p&gt;è€ƒè™‘åˆ°æ•´ä¸ªè¿‡ç¨‹éœ€è¦å¤šæ¬¡æ’å…¥åˆ é™¤çš„æ“ä½œï¼Œå¹¶ä¸”æŸ¥æ‰¾è¿‡ç¨‹åªéœ€è¦ä»æ’å…¥çš„å…·ä½“ä½ç½®å‘ä¸¤ä¾§è¿›è¡Œåˆ¤æ–­ï¼Œæ‰€ä»¥ä½¿ç”¨listå¯¹ç å­åºåˆ—è¿›è¡Œå­˜å‚¨ã€‚&lt;/p&gt;

&lt;p&gt;æ’å…¥è¿‡ç¨‹åªéœ€è¦ç®€å•çš„insertå‡½æ•°ä¸advanceå‡½æ•°ç›¸é…åˆå°±å¯ä»¥äº†ï¼Œä½¿ç”¨advanceå‡½æ•°ä½¿è¿­ä»£å™¨æŒ‡åˆ°æ’å…¥ä½ç½®ï¼Œä¹‹åå†ç”¨insertå‡½æ•°è¿›è¡Œæ’å…¥ã€‚&lt;/p&gt;

&lt;p&gt;æ¯”è¾ƒéš¾çš„åœ°æ–¹åœ¨äºæ˜¯å¦æ¶ˆé™¤çš„åˆ¤æ–­ä¸Šï¼Œè€ƒè™‘åˆ°è¿­ä»£å™¨çš„ç‰¹æ®Šæ€§ï¼Œä¸ºäº†é¿å…ä¸å¿…è¦çš„éº»çƒ¦ï¼Œå½“listä¸­çš„å…ƒç´ å°‘äºä¸‰ä¸ªçš„æ—¶å€™ç›´æ¥ä¸è¿›è¡Œåˆ¤æ–­ã€‚å¯¹ä¸‰ä¸ªä»¥ä¸Šçš„å…ƒç´ åˆ¤æ–­æ—¶ï¼Œéœ€è¦ä»æ’å…¥å…ƒç´ çš„ä½ç½®å‘ä¸¤ä¾§æŸ¥æ‰¾ç›¸åŒé¢œè‰²ï¼Œå¯ä»¥ç”¨&lt;code&gt;end()&lt;/code&gt;å’Œ&lt;code&gt;begin()&lt;/code&gt;æ¥åˆ¤æ–­æ˜¯å¦åˆ°è¾¾äº†æŸ¥æ‰¾çš„ä¸¤ç«¯ï¼Œå½“ç„¶ï¼Œå¦‚æœåœ¨æŸ¥æ‰¾è¿‡ç¨‹ä¸­å°±å‘ç°äº†ä¸åŒçš„ç å­å°±å¯ä»¥ç›´æ¥åœæ­¢æŸ¥æ‰¾è¿‡ç¨‹ã€‚æŸ¥æ‰¾ç»“æŸä¹‹åç›´æ¥å¯¹æŸ¥æ‰¾åˆ°çš„åŒºé—´è¿›è¡Œåˆ é™¤ï¼ŒåŒæ—¶ä¿ç•™å·¦å¼€å³é—­åŒºé—´çš„å³ç«¯ç‚¹ä½œä¸ºä¸‹æ¬¡æŸ¥æ‰¾è¿‡ç¨‹çš„èµ·å§‹ä½ç½®ã€‚&lt;/p&gt;

&lt;p&gt;æ•°æ®çš„è¾“å…¥å’Œç»“æœè¾“å‡ºè¿‡ç¨‹æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚è¿›è¡Œç¼–å†™å³å¯ã€‚&lt;/p&gt;

&lt;h2 id=&#34;æµç¨‹å›¾&#34;&gt;æµç¨‹å›¾&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb38e8cb30.jpg&#34; alt=&#34;æµç¨‹å›¾&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ç¼–ç¨‹å®ç°&#34;&gt;ç¼–ç¨‹å®ç°&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

void bang(list&amp;lt;char&amp;gt; &amp;amp; beads, int id, char bead){
    list&amp;lt;char&amp;gt;::iterator i, r, l;
    int num = 0;    /*è®¡æ•°*/
    i = beads.begin();
    advance(i, id);
    beads.insert(i, bead);  /*æ’å…¥å…ƒç´ */

    /*è€ƒè™‘åˆ°å¤šæ¬¡æ¶ˆé™¤çš„å¯èƒ½ï¼Œä½¿ç”¨whileå¾ªç¯è¿›è¡Œæ¶ˆé™¤*/
    while(1){
        if(beads.size() &amp;lt; 3)
            break;
        
        num = 0;
        r = i--;    
        /*è¿™æ­¥æ“ä½œä¹‹åræŒ‡å‘è¢«æ’å…¥å…ƒç´ ä»¥åï¼ŒiæŒ‡å‘è¢«æ’å…¥å…ƒç´ */
        
        for(; r != beads.end(); r++){
            if(*r == *i)    num ++;
            else    break;
        }           /*å‘å³åˆ¤æ–­*/

        l = i;          
        /*if(i != beads.begin()){
            l--;
            while (1){
                if(*l != *i){   l++;break;} //léœ€è¦åŠ åŠ 
                else    num ++;
                
                if(l == beads.begin())  break;
                else    l--;    
            }
        }   //å‘å·¦åˆ¤æ–­*/

        /*ç”±æµç¨‹å›¾å‘ç°çš„ç®€åŒ–æ–¹æ³•*/
        while(l != beads.begin()){
            l--;
            if(*l != *i){   l++; break;}
            else    num++;
        }


        /*åˆ é™¤éƒ¨åˆ†*/
        if(num &amp;gt; 1){
            beads.erase(l, r);
            i = r;
        }
        else
            break;
    }


    /*è¾“å‡º*/
    if(beads.empty())
        cout &amp;lt;&amp;lt; &#39;-&#39; &amp;lt;&amp;lt; endl;
    else{
        for(i = beads.begin(); i != beads.end(); i++)
            cout &amp;lt;&amp;lt; *i;
        cout &amp;lt;&amp;lt; endl;
    }
    return ;
}
int main(){
    int n, id;
    char bead;
    string initial_beads;
    list&amp;lt;char&amp;gt; beads;

    getline(cin, initial_beads);
    for(int i = 0; i &amp;lt; initial_beads.size(); i++){
        beads.push_back(initial_beads[i]);
    }
    /*æ„é€ åˆå§‹çŠ¶æ€*/

    cin &amp;gt;&amp;gt; n;
    while(n--){
        cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; bead;
        bang(beads, id, bead);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ç»“æœåˆ†æ&#34;&gt;ç»“æœåˆ†æ&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb38f267db.jpg&#34; alt=&#34;æµ‹è¯•1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb39060e21.jpg&#34; alt=&#34;æµ‹è¯•2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;å¦‚ä¸Šï¼Œç»è¿‡æµ‹è¯•ï¼Œç¨‹åºå®Œæˆè¦æ±‚ï¼Œå¹¶ä¸”èƒ½å¤Ÿå¤„ç†åˆå§‹åºåˆ—ä¸ºç©ºçš„æƒ…å†µã€‚ğŸ‘&lt;/p&gt;

&lt;h2 id=&#34;æ€»ç»“ä½“ä¼š&#34;&gt;æ€»ç»“ä½“ä¼š&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;å¢åŠ äº†å¯¹eraseå‡½æ•°çš„äº†è§£ï¼š

&lt;ol&gt;
&lt;li&gt;å½“å‚æ•°åªæœ‰ä¸€ä¸ªçš„æ—¶å€™ï¼ŒåŸè¿­ä»£å™¨æŒ‡å‘çš„ä½ç½®è¢«åˆ é™¤ï¼Œè¿­ä»£å™¨æ— æ•ˆåŒ–ï¼Œä¸èƒ½å¯¹å…¶ç»§ç»­è¿›è¡Œæ“ä½œï¼Œå¦åˆ™ä¼šé€ æˆé”™è¯¯ï¼Œä½†å‡½æ•°ä¼šè¿”å›åŸä½ç½®ä¹‹åçš„è¿­ä»£å™¨ï¼Œæ‰€ä»¥å¯ä»¥åˆ©ç”¨è¿™ä¸ªç‰¹æ€§è¿›è¡ŒåŒºé—´åˆ é™¤ï¼ˆçœç•¥++æ­¥éª¤ï¼‰ã€‚&lt;/li&gt;
&lt;li&gt;å½“æœ‰ä¸¤ä¸ªå‚æ•°çš„æ—¶å€™ï¼Œå‡½æ•°ç»“æŸä¹‹åå‰ä¸€ä¸ªè¿­ä»£å™¨ä¼šæ— æ•ˆåŒ–ï¼Œè€Œåä¸€ä¸ªè¿­ä»£å™¨å› ä¸ºåˆ é™¤åŒºé—´ä¸ºå·¦é—­å³å¼€çš„ç‰¹ç‚¹ï¼Œå…¶æŒ‡å‘çš„ä½ç½®ä¸ä¼šè¢«åˆ é™¤ã€‚&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;è¿­ä»£å™¨æ˜¯ä¸€ä¸ªå¾ˆç„å­¦çš„ä¸œè¥¿ï¼Œä½¿ç”¨ä¸è§„èŒƒå¾ˆå®¹æ˜“å¸¦æ¥é”™è¯¯ï¼ŒæŸ¥é”™çš„æ—¶å€™å¯ä»¥ä¼˜å…ˆè€ƒè™‘ã€‚&lt;/li&gt;
&lt;li&gt;æµç¨‹å›¾å¯ä»¥å¸®å¿™ç†æ¸…é€»è¾‘ç»“æ„ï¼ï¼ï¼ğŸ˜€&lt;/li&gt;
&lt;li&gt;å†™ç¨‹åºå°½é‡ä¸€æ¬¡æ€§å†™å®Œ&amp;hellip;&amp;hellip;ğŸ¤§&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>æ‹¬å·åŒ¹é…</title>
      <link>https://wanakiki.github.io/2019/kuohao/</link>
      <pubDate>Sat, 20 Apr 2019 14:36:43 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/kuohao/</guid>
      <description>

&lt;p&gt;è¿™ä¸ªå­¦æœŸå¼€å§‹å­¦æ•°æ®ç»“æ„ï¼Œç¬¬ä¸€èŠ‚è¯¾è€å¸ˆåˆæå‡ºäº†è¿™ä¸ªç»å…¸çš„é—®é¢˜ã€‚&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;é—®é¢˜æè¿°&#34;&gt;é—®é¢˜æè¿°&lt;/h2&gt;

&lt;p&gt;ç»™å‡ºä¸€ä¸ªåªåŒ…å«&amp;rsquo;(&amp;lsquo;å’Œ&amp;rsquo;)&amp;lsquo;çš„å­—ç¬¦ä¸²ï¼Œåˆ¤æ–­è¯¥å­—ç¬¦ä¸²ä¸­çš„æ‹¬å·æ˜¯å¦åŒ¹é…ã€‚å¹¶å°†åŒ¹é…çš„æ‹¬å·ç”¨&amp;rsquo;_&amp;lsquo;ä»£æ›¿ï¼Œä¸åŒ¹é…çš„æ‹¬å·ç”¨&amp;rsquo;$&amp;lsquo;æ ‡å‡ºã€‚
ä¾‹å¦‚ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;è¾“å…¥ï¼š
(())()))
è¾“å‡ºï¼š
(())()))
______$$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ç®€å•è§£æ³•&#34;&gt;ç®€å•è§£æ³•&lt;/h2&gt;

&lt;p&gt;æ‹¬å·åŒ¹é…é—®é¢˜æ˜¯åˆšå¼€å§‹å­¦ä¹ Cè¯­è¨€çš„æ—¶å€™å°±æ¥è§¦çš„é—®é¢˜ï¼Œå½“æ—¶è€å¸ˆå¼•å…¥è¿™ä¸ªé—®é¢˜çš„åŸå› å¯èƒ½æ˜¯ä¸ºäº†ä»‹ç»æ ˆçš„æ¦‚å¿µï¼Œä½†æ˜¯å½“æ—¶ç­ä¸Šå¤§å¤šæ•°äººéƒ½é‡‡å–äº†ç›´æ¥ç”¨æ•°ç»„æ¨¡æ‹Ÿçš„æ–¹æ³•ã€‚æŠŠæ•´ä¸ªå­—ç¬¦ä¸²å½•å…¥ï¼Œä¹‹åéå†æ•´ä¸ªå­—ç¬¦ä¸²ï¼Œé‡åˆ°å³æ‹¬å·å°±å‘å‰å¯»æ‰¾æ˜¯å¦å­˜åœ¨å¯¹åº”çš„å·¦æ‹¬å·ï¼Œè¿›è¡Œåˆ¤æ–­ã€‚C++ä»£ç å¦‚ä¸‹ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
using namespace std;
int main(){
    string str, tmp;    
    //tmpç”¨äºä¿ç•™åŸæ¥çš„å­—ç¬¦ä¸²ï¼Œä¸ºäº†æ–¹ä¾¿ç›´æ¥ç”¨stringè¾“å…¥
    cin &amp;gt;&amp;gt; str;
    tmp = str;
    for(int i = 0; i &amp;lt; str.length(); i++){
        if(str[i] == &#39;)&#39;){
            for(int j = i - 1; j &amp;gt;= 0; j--){
                if(str[j] == &#39;(&#39;){
                    str[i] = str[j] = &#39;_&#39;;
                    break;
                }
            }
        }
    }
    for(int i = 0; i &amp;lt; str.length(); i++){
        if(str[i] != &#39;_&#39;)
            str[i] = &#39;$&#39;;   //æ‰¾å‡ºä¸åŒ¹é…çš„æ‹¬å·
    }
    cout &amp;lt;&amp;lt; tmp &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; str;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ä½¿ç”¨æ ˆæ¥è§£å†³&#34;&gt;ä½¿ç”¨æ ˆæ¥è§£å†³&lt;/h2&gt;

&lt;p&gt;é¦–å…ˆå¿½ç•¥æ‰ä¸åŒ¹é…æ‹¬å·çš„æ ‡è®°é—®é¢˜ï¼Œèšç„¦äºåˆ¤æ–­æ•´ä¸ªå­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨ä¸åŒ¹é…çš„æ‹¬å·ã€‚è¦çœ‹å­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…ï¼Œåªè¦çœ‹å·¦æ‹¬å·æ˜¯å¦æœ‰å¯¹åº”çš„å³æ‹¬å·ï¼Œæˆ–è€…å³æ‹¬å·æ˜¯å¦æœ‰å¯¹åº”çš„å·¦æ‹¬å·ï¼Œé—®é¢˜è§£å†³æ–¹æ³•æ˜¯ç›¸åŒçš„ã€‚&lt;/p&gt;

&lt;p&gt;è¯»å…¥ä¸€ä¸ªå·¦æ‹¬å·æˆ‘ä»¬å°±å¯ä»¥æŠŠå®ƒå‹å…¥æ ˆä¸­ï¼Œé‡åˆ°å³æ‹¬å·å°±å¼¹å‡ºæ ˆä¸­çš„å·¦æ‹¬å·ã€‚å¦‚æœæ‰€æœ‰çš„å³æ‹¬å·éƒ½è¯»å–å®Œï¼Œæ ˆä¸­è¿˜æœ‰å·¦æ‹¬å·ï¼Œæˆ–è€…è¯»å…¥ä¸€ä¸ªå³æ‹¬å·æ ˆä¸­å·²ç»æ²¡æœ‰äº†æ‹¬å·ï¼Œå°±æ„å‘³ç€è¯¥å­—ç¬¦ä¸²ä¸­çš„æ‹¬å·ä¸åŒ¹é…ã€‚C++ä»£ç ï¼š&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;string&amp;gt;
using namespace std;
int main(){
    stack&amp;lt;char&amp;gt; s;
    string tmp;
    cin &amp;gt;&amp;gt; tmp;
    for(int i = 0; i &amp;lt; tmp.length(); i++){
        if(tmp[i] == &#39;(&#39;)
            s.push(tmp[i]);
        else
        {
            if(s.empty())
                cout &amp;lt;&amp;lt; &amp;quot;FALSE&amp;quot;;
            else
            {
                s.pop();
            }
            
        }
        
    }
    if(!s.empty())
        cout &amp;lt;&amp;lt; &amp;quot;FALSE&amp;quot;;
    else
    {
        cout &amp;lt;&amp;lt; &amp;quot;TRUE&amp;quot;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ä¸Šé¢è¿™æ®µä»£ç å®Œå…¨å¯ä»¥ä¸ç”¨æ ˆï¼Œè®¾ç½®ä¸€ä¸ªå˜é‡æ¥è®°å½•å½“å‰æ‹¥æœ‰çš„å·¦æ‹¬å·çš„æ•°é‡å°±å¯ä»¥å¤§å¤§ç®€åŒ–ä»£ç ã€‚&lt;/p&gt;

&lt;p&gt;å¦‚æœæˆ‘ä»¬æƒ³è¦çŸ¥é“æ˜¯å“ªå‡ ä¸ªå­—ç¬¦ä¸åŒ¹é…ï¼Œæˆ‘çš„æƒ³æ³•æ˜¯ç›´æ¥å°†å­—ç¬¦çš„ç´¢å¼•å‹å…¥æ ˆä¸­ï¼Œå› ä¸ºåªæœ‰ä¸€ç§æ‹¬å·ï¼ŒæŠŠå­—ç¬¦å‹å…¥æ ˆä¸­å®é™…ä¸Šæ˜¯ä¸å¿…è¦ä¹‹ä¸¾ã€‚å°†ä¸Šé¢çš„ä»£ç è¾“å‡ºé”™è¯¯çš„åœ°æ–¹æ”¹æˆè®°å½•é”™è¯¯çš„ä¸‹æ ‡ï¼Œå°±å¯ä»¥å°†å‡ºé”™å­—ç¬¦çš„ä¸‹æ ‡è®°å½•ä¸‹æ¥ï¼Œå½“æ‰€æœ‰çš„å³æ‹¬å·éƒ½åˆ¤æ–­å®Œä¹‹åï¼Œæ ˆä¸­å‰©ä½™çš„æ‰€æœ‰å·¦æ‹¬å·ä¸‹æ ‡ä¹ŸåŒæ ·è¦è®°å½•ä¸‹æ¥ã€‚&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://wanakiki.github.io/about/</link>
      <pubDate>Sat, 20 Apr 2019 13:54:01 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/about/</guid>
      <description>&lt;p&gt;è¶ç€è¿åŠ¨ä¼šçš„å‡æœŸæŠŠGitHubä¸Šé¢åšå®¢çš„ç”Ÿæˆæ–¹å¼ä»hexoæ¢åˆ°äº†hugoï¼Œå¸Œæœ›ä»Šåèƒ½å¤ŸåšæŒä¸‹å»ğŸ˜€ï¼Œå¦å¤–ä¹‹å‰æ²¡æœ‰å†™å¤šå°‘åšæ–‡ï¼Œè¿ç§»è¿‡æ¥å¹¶ä¸ä¼šé€ æˆå¤ªå¤šçš„éº»çƒ¦ã€‚&lt;/p&gt;

&lt;p&gt;æ–°æ–¹å¼çš„é…ç½®ä¸»è¦å‚è€ƒäº†&lt;a href=&#34;https://mogeko.me/2018/018/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Mogekoçš„åšå®¢&lt;/a&gt;ï¼Œåœ¨æ­¤å¯¹ä»–è¡¨ç¤ºæ„Ÿè°¢ã€‚&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>