<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wanakiki`s Blog on Wanakiki`s Blog</title>
    <link>https://wanakiki.github.io/</link>
    <description>Recent content in Wanakiki`s Blog on Wanakiki`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 21 Apr 2019 10:41:45 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>数据结构作业三 列车调度</title>
      <link>https://wanakiki.github.io/2019/train/</link>
      <pubDate>Sun, 21 Apr 2019 10:41:45 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/train/</guid>
      <description>

&lt;p&gt;本次作业不需提交报告。
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;Input&lt;/p&gt;

&lt;p&gt;共两行。&lt;/p&gt;

&lt;p&gt;第一行为两个整数n，m。&lt;/p&gt;

&lt;p&gt;第二行为以空格分隔的n个整数，保证为{1, 2, &amp;hellip;, n}的一个排列，表示待判断可行性的驶出序列{a1，a2，&amp;hellip;，an}。&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;p&gt;若驶出序列可行，则输出操作序列，其中push表示车厢从A进入S，pop表示车厢从S进入B，每个操作占一行。&lt;/p&gt;

&lt;p&gt;若不可行，则输出No。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;Sample Input 1 

5 2
1 2 3 5 4
Sample Output 1

push
pop
push
pop
push
pop
push
push
pop
pop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

int main(){
    int n, m;
    int B[10000];   //B队列
    bool step[20005];   //记录操作 0压入 1弹出
    bool flag = false;  //标记是否出现错误
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    stack&amp;lt;int&amp;gt; s;   //代表中转端
    
    for(int i = 0; i &amp;lt; n; i++){
        cin &amp;gt;&amp;gt; B[i];
    }

    int i = 1, j = 0, k = 0;  //当前数字i 操作步骤标记j B队列索引k
    while(i &amp;lt;= n){
        if(s.empty()){
            s.push(i++);
            step[j++] = 0;
        }
        else{
            if(s.top() == B[k]){
                s.pop();
                step[j++] = 1;
                k++;
            }
            else{
                s.push(i++);
                step[j++] = 0;
                if(s.size() &amp;gt; m){
                    flag = 1;
                    break;
                }
            }
        }
    }

    //剩余元素的弹出讨论
    while(!s.empty()){
        if(s.top() != B[k]){
            flag = 1;
            break;
        }
        else{
            s.pop();
            step[j++] = 1;
            k++;
        }
    }

    if(flag)
        cout &amp;lt;&amp;lt; &amp;quot;no&amp;quot;;
    else{
        for(int l = 0; l &amp;lt; j; l++){
            if(step[l])
                cout &amp;lt;&amp;lt; &amp;quot;pop&amp;quot;;
            else
                cout &amp;lt;&amp;lt; &amp;quot;push&amp;quot;;
            cout &amp;lt;&amp;lt; endl;
        }
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业二 List ADT</title>
      <link>https://wanakiki.github.io/2019/list-adt/</link>
      <pubDate>Sat, 20 Apr 2019 20:22:40 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/list-adt/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;

&lt;p&gt;题目要求自行实现list ADT，并在此基础上实现PrintLots函数并且实现懒惰删除功能。对于PrintLots函数，题目要求分析运行时间；对于懒惰删除功能，除编写实现外，题目还要求列出懒惰删除的优点和缺点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PrintLots(L,P)&lt;/strong&gt;：有两个链表L和P, 他们包含以升序排列的整数，操作PrintLots(L,P)将打印L中那些由P所指定位置上的元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;懒惰删除（lazy deletion）&lt;/strong&gt;：为了删除一个元素，我们只标记上该元素被删除。表中被删除和非被删除元素的个数作为数据结构的一部分被保留。如果被删除元素和非被删除元素一样多，我们遍历整个表，对所有被标记的节点执行标准的删除算法。&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;设计list ADT，准备好PrintLots函数所需要的接口。主文件引用自己编写的list ADT，并在主文件中完成对PrintLots函数的实现，懒惰删除则可以直接封装在ADT中。由于本次实验缺乏示例输入输出，因此还要对输入输出部分稍微加以设计，在此不多赘述。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;list ADT的实现大体可以按照课本所给的框架来初步构建，之后对其进行丰富，首先实现节点类，再进一步实现List类。考虑到懒惰删除的需要，在实现节点类的时候我在其中加入了是否删除的标志，实现List类时增加了用于统计伪删除元素个数的变量。为了更进一步贴合标准模板库的操作，相对多此一举地加入了迭代器子类。（实践证明，我对迭代器相关知识的了解并不充分&amp;hellip;😕）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29dg1ljtgj30pg0gr4qq.jpg&#34; alt=&#34;结构示意&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;printlots函数&#34;&gt;PrintLots函数&lt;/h3&gt;

&lt;p&gt;因为两个链表的元素都是升序排列的，所以L的迭代器可以一直向一个方向移动，整个函数的实现降低了一些难度。定义一个整形变量用来记录当前L的迭代器指向位置的编号，编号若与P的迭代器指向的元素相同则进行输出，同时两个迭代器向后移动。若编号与P当前元素不同，则指向L的迭代器向后移动。函数的终止条件为链表P遍历结束。&lt;/p&gt;

&lt;h4 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h4&gt;

&lt;p&gt;从整体上来看，PrintLots函数只是两个链表的单向遍历输出，只是细节方面稍微复杂，但引入的均为常数时间可以完成的操作。因为P的元素个数不可能超过L的元素个数，所以最坏情况便是输出了L的所有元素。时间复杂度为O(n)。&lt;/p&gt;

&lt;h3 id=&#34;懒惰删除&#34;&gt;懒惰删除&lt;/h3&gt;

&lt;p&gt;函数参数为指向要删除元素的迭代器，函数通过迭代器访问该元素内部的删除标志，并对其进行修改。修改之后检查当前伪删除元素的总数，大于总元素一般对整个链表进行遍历删除。总体实现相对简单。&lt;/p&gt;

&lt;h4 id=&#34;懒惰删除优缺点分析&#34;&gt;懒惰删除优缺点分析&lt;/h4&gt;

&lt;p&gt;优点：误删数据有恢复的空间，未被释放的空间可以进行二次利用，减少了资源消耗较大的删除过程的需求次数（链表中体现不明显）。
缺点：记录元素伪删除需要额外的操作和空间，被删除的节点不及时释放增加了空间的占用，也提高了部分操作所需的时间。&lt;/p&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29d8m6wuhj30cp0jcq3n.jpg&#34; alt=&#34;printlots&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29d8mfr8sj30cr0oddgu.jpg&#34; alt=&#34;lazy deletion&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;p&gt;共编写了三个文件：listnode.h、my_list.h、main.cpp&lt;/p&gt;

&lt;p&gt;1.listnode.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    #include&amp;lt;iostream&amp;gt;
    using namespace std;

    //定义列表的节点
    template &amp;lt;typename T&amp;gt; struct ListNode
    {
        T data;
        ListNode&amp;lt;T&amp;gt;* pred;
        ListNode&amp;lt;T&amp;gt;* succ;
        bool need_remove;   //need_remove为了方便懒惰消除

        ListNode() : need_remove(false) {}
        ListNode(T e, ListNode&amp;lt;T&amp;gt;* p = NULL, ListNode&amp;lt;T&amp;gt;* s = NULL)
            : data(e), pred(p), succ(s), need_remove(false) {}

        ListNode&amp;lt;T&amp;gt;* insertAsPred(T const&amp;amp; e);
        ListNode&amp;lt;T&amp;gt;* insertAsSucc(T const&amp;amp; e);
    };

    //前插入
    template &amp;lt;typename T&amp;gt;
    ListNode&amp;lt;T&amp;gt;* ListNode&amp;lt;T&amp;gt;::insertAsPred(T const&amp;amp; e){
        ListNode&amp;lt;T&amp;gt;* x = new ListNode(e, pred, this);
        pred-&amp;gt;succ = x;
        pred = x;
        return x;
    }

    //后插入
    template &amp;lt;typename T&amp;gt;
    ListNode&amp;lt;T&amp;gt;* ListNode&amp;lt;T&amp;gt;::insertAsSucc(T const&amp;amp; e){
        ListNode&amp;lt;T&amp;gt;* x = new ListNode(e, this, succ);
        succ-&amp;gt;pred = x;
        succ = x;
        return x;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.my_list.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;listnode.h&amp;quot;

template &amp;lt;typename T&amp;gt;
class List
{
  private:
    int _size;
    int _num;
    ListNode&amp;lt;T&amp;gt; *header;
    ListNode&amp;lt;T&amp;gt; *trailer;

  protected:
    void init();
    void copyNodes(ListNode&amp;lt;T&amp;gt; *, int);
    //只写出了有可能用到的函数

  public:
    List() { init(); } //默认构造
    List(List&amp;lt;T&amp;gt; const &amp;amp;L);
    List(List&amp;lt;T&amp;gt; const &amp;amp;L, int r, int n);
    List(ListNode&amp;lt;T&amp;gt; *p, int n);
    int clear();

    ~List(); //析构

    class Iterator{
      public:
        ListNode&amp;lt;T&amp;gt; *ptr;

        Iterator() : ptr(NULL) {}
        Iterator(ListNode&amp;lt;T&amp;gt; *tmp) : ptr(tmp) {}

        T operator*(){
            return ptr-&amp;gt;data;
            //为空时如何抛出错误？
        }

        bool operator==(Iterator const &amp;amp;x) { return ptr == x.ptr; }
        bool operator!=(Iterator const &amp;amp;x) { return ptr != x.ptr; }
        Iterator operator++(int){
            //不能在这里访问trailer，那么标准的迭代器是怎么操作的呢
            Iterator tmp(ptr);
            while(1){
                if(ptr-&amp;gt;succ != NULL)
                    ptr = ptr-&amp;gt;succ;
                if(!ptr-&amp;gt;need_remove)   //不需要继续访问，跳出循环
                    break;
            }
            return tmp;
        }
        Iterator operator--(int){
            Iterator tmp(ptr);
            while(1){
                if (ptr-&amp;gt;pred != NULL)
                    ptr = ptr-&amp;gt;pred;
                if(!ptr-&amp;gt;need_remove)
                    break;
            }
            return tmp;
        }
        Iterator&amp;amp; operator++(){
            while(1){
                if(ptr-&amp;gt;succ != NULL)
                    ptr = ptr-&amp;gt;succ;
                if(!ptr-&amp;gt;need_remove)   //不需要继续访问，跳出循环
                    break;
            }
            return *this;
        }
        Iterator&amp;amp; operator--(){
            while(1){
                if (ptr-&amp;gt;pred != NULL)
                    ptr = ptr-&amp;gt;pred;
                if(!ptr-&amp;gt;need_remove)
                    break;
            }
            return *this;
        }
    };

    bool empty() const { return _size &amp;lt;= 0; }
    int size() const { return _size-_num; }
    ListNode&amp;lt;T&amp;gt; *insertAsFirst(T const &amp;amp;e);
    ListNode&amp;lt;T&amp;gt; *insertAsLast(T const &amp;amp;e);
    Iterator begin() { return ++Iterator(header); }
    Iterator end() { return Iterator(trailer); }
    ListNode&amp;lt;T&amp;gt; *first() const { return header-&amp;gt;succ; } //first和begin完全没必要
    ListNode&amp;lt;T&amp;gt; *last() const { return trailer-&amp;gt;pred; }
    T remove(ListNode&amp;lt;T&amp;gt; *p);
    void lazy_deletion(Iterator i);
    void show();
    void Advance(Iterator &amp;amp;i, int n);
};

template &amp;lt;typename T&amp;gt; //列表初始化
void List&amp;lt;T&amp;gt;::init()
{
    header = new ListNode&amp;lt;T&amp;gt;;
    trailer = new ListNode&amp;lt;T&amp;gt;;
    header-&amp;gt;succ = trailer;
    header-&amp;gt;pred = NULL;
    trailer-&amp;gt;pred = header;
    trailer-&amp;gt;succ = NULL;
    _size = 0;
    _num = 0;
}

//复制自p开始的n项
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::copyNodes(ListNode&amp;lt;T&amp;gt; *p, int n)
{
    init();
    while (n--)
    {
        insertASLast(p-&amp;gt;data);
        p = p-&amp;gt;succ;
    }
}

//Clear()
template &amp;lt;typename T&amp;gt;
int List&amp;lt;T&amp;gt;::clear()
{
    int num = _size;
    if (_size)
    {
        ListNode&amp;lt;T&amp;gt; *p = header-&amp;gt;succ;
        ListNode&amp;lt;T&amp;gt; *tmp;
        while (p != trailer)
        {
            tmp = p-&amp;gt;succ;
            delete p;
            p = tmp;
        }
    }
    _size = 0;
    _num = 0;
    return num;
}

//构造函数
template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(List&amp;lt;T&amp;gt; const &amp;amp;L) { copyNodes(L.first(), L.size()); }

template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(List&amp;lt;T&amp;gt; const &amp;amp;L, int r, int n)
{
    ListNode&amp;lt;T&amp;gt; *tmp = L.first();
    while (--r)
        tmp = tmp-&amp;gt;succ;
    copyNodes(tmp, n);
}

template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(ListNode&amp;lt;T&amp;gt; *p, int n) { copyNodes(p, n); }

//析构函数
template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::~List()
{
    clear();
    delete trailer;
    delete header;
}

template &amp;lt;typename T&amp;gt;
ListNode&amp;lt;T&amp;gt; *List&amp;lt;T&amp;gt;::insertAsFirst(T const &amp;amp;e)
{
    _size++;
    return header-&amp;gt;insertAsSucc(e);
}

template &amp;lt;typename T&amp;gt;
ListNode&amp;lt;T&amp;gt; *List&amp;lt;T&amp;gt;::insertAsLast(T const &amp;amp;e)
{
    _size++;
    return trailer-&amp;gt;insertAsPred(e);
}

//删除
template &amp;lt;typename T&amp;gt;
T List&amp;lt;T&amp;gt;::remove(ListNode&amp;lt;T&amp;gt; *p)
{
    T tmp= p-&amp;gt;data;
    _size--;
    p-&amp;gt;pred-&amp;gt;succ = p-&amp;gt;succ;
    p-&amp;gt;succ-&amp;gt;pred = p-&amp;gt;pred;
    delete p;
    return tmp;
}

template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::lazy_deletion(Iterator i){
    _num++;
    ListNode&amp;lt;T&amp;gt;* tmp = i.ptr;
    tmp-&amp;gt;need_remove = true;

    //数量大于一半开始全部删除
    if(_num &amp;gt;= _size/2){
        _num = 0;
        ListNode&amp;lt;T&amp;gt; *p = header-&amp;gt;succ;
        while(trailer != p){
            if(!p-&amp;gt;need_remove){
                p = p-&amp;gt;succ;
                continue;
            }
                
            tmp = p-&amp;gt;succ;
            remove(p);
            p = tmp;       
        }
    }
    return ;
}

//输出格式化
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::show(){
    if(_size == 0){
        cout &amp;lt;&amp;lt; &amp;quot;None&amp;quot; &amp;lt;&amp;lt; endl;
        return ;
    }
    ListNode&amp;lt;T&amp;gt;* p = header;
    while(trailer != (p = p-&amp;gt;succ)){
        if(p == header-&amp;gt;succ){
            cout &amp;lt;&amp;lt; p-&amp;gt;data;
            continue;
        }
        if(p-&amp;gt;pred-&amp;gt;need_remove &amp;amp;&amp;amp; p-&amp;gt;need_remove)    cout &amp;lt;&amp;lt; &amp;quot;____&amp;quot;;
        else if(p-&amp;gt;need_remove)     cout &amp;lt;&amp;lt; &amp;quot;--__&amp;quot;;
        else if(p-&amp;gt;pred-&amp;gt;need_remove)   cout &amp;lt;&amp;lt; &amp;quot;__-&amp;gt;&amp;quot;;
        else    cout &amp;lt;&amp;lt; &amp;quot;---&amp;gt;&amp;quot;;
        cout &amp;lt;&amp;lt; p-&amp;gt;data;
    }
    return ;
}

//用于迭代器的移动
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::Advance(Iterator &amp;amp; i, int n){
    if(n &amp;gt;= 0){
        while(n--)
            i.ptr = i.ptr-&amp;gt;succ;
    }
    else{
        while(n++)
            i.ptr = i.ptr-&amp;gt;pred;
    }
}
//如果向容器里面放个pair？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.main.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;my_list.h&amp;quot;


void PrintLots(List&amp;lt;int&amp;gt;&amp;amp; L, List&amp;lt;int&amp;gt;&amp;amp; P){
    int current = 1;

    //是否存在空序列
    if(L.empty() || P.empty())  {   cout&amp;lt;&amp;lt;&amp;quot;Error, input is empty&amp;quot;&amp;lt;&amp;lt;endl; return ;}

    List&amp;lt;int&amp;gt;::Iterator l = L.begin();
    List&amp;lt;int&amp;gt;::Iterator p = P.begin();
    while(1){
        if(L.size() &amp;lt; *p){  
            cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;quot;Error, the number of P is bigger than the size of L&amp;quot; &amp;lt;&amp;lt; endl;  
            break;
        }

        if(current++ == *p){
            cout &amp;lt;&amp;lt; *l &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            p++;
        }

        //输出结束
        if(p == P.end()){  
                cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;quot;Finished!&amp;quot; &amp;lt;&amp;lt; endl;
                break;
        }
        l++;
    }
    return ;
}

int main(){
    int m, n, tmp, last;
    int select = 0;
    while(1){
        cout &amp;lt;&amp;lt; &amp;quot;Choose function(0 means lazy_deletion, 1 means PrintLots):&amp;quot;;
        cin &amp;gt;&amp;gt; select;
        if(select){
            List&amp;lt;int&amp;gt; L, P;
            cout &amp;lt;&amp;lt; &amp;quot;Input the size of L and P: &amp;quot;;
            cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of L: &amp;quot; &amp;lt;&amp;lt; endl;
            while (m--){
                cin &amp;gt;&amp;gt; tmp;
                L.insertAsLast(tmp);
            }
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of P: &amp;quot; &amp;lt;&amp;lt; endl;
            while (n--){
                cin &amp;gt;&amp;gt; tmp;
                P.insertAsLast(tmp);
            }
            PrintLots(L, P);
        }
        else{
            List&amp;lt;int&amp;gt; L;
            cout &amp;lt;&amp;lt; &amp;quot;Input the size of L: &amp;quot;;
            cin &amp;gt;&amp;gt; m;
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of L:&amp;quot; &amp;lt;&amp;lt; endl;
            for(int j = 0; j &amp;lt; m; j++){
                cin &amp;gt;&amp;gt; tmp;
                L.insertAsLast(tmp);
            }
            cout &amp;lt;&amp;lt; &amp;quot;L is: &amp;quot;;
            L.show();
            cout&amp;lt;&amp;lt;endl;


            List&amp;lt;int&amp;gt;::Iterator i = L.begin();
            last = 1;
            cout &amp;lt;&amp;lt; &amp;quot;How many elements do you want to delete? &amp;quot;;
            cin &amp;gt;&amp;gt; n;
            cout &amp;lt;&amp;lt; &amp;quot;Input them(from 1 to &amp;quot; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;quot;)&amp;quot; &amp;lt;&amp;lt; endl;
            while(n--){
                cin &amp;gt;&amp;gt; tmp;
                L.Advance(i, tmp-last);
                last = tmp;
                L.lazy_deletion(i);
            }
            cout &amp;lt;&amp;lt; &amp;quot;Now L is: &amp;quot;;
            L.show();
            cout &amp;lt;&amp;lt; endl;
        } 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;p&gt;PrintLots进行了四组测试，从测试结果可以看出对错误情况进行了有效的判断，并且能够处理一般情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29d8mpjg5j30me0lfn4u.jpg&#34; alt=&#34;PrintLots测试&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了方便懒惰删除的查看，设置了一个函数用来表现链表当前的情况，同时进行了三种样例的测试，能够代表所有类型的满足要求的输入情况。可以很容易的看出当删除元素过半时按要求完成了操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29d8mxyvdj30mx0jbaiq.jpg&#34; alt=&#34;懒惰删除测试&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;深刻感觉到自己的宏观思维有极大的欠缺，自己设计出的类中的函数不能很好地衔接，编程思维有问题。&lt;/li&gt;
&lt;li&gt;自己写的迭代器可能称不上是迭代器，只是稍微包装了一下指针。自己测试的时候发现在iterator已经被定义，意识到平时所用的迭代器并不是定义在容器的头文件中。&lt;/li&gt;
&lt;li&gt;边界等特殊情况没有得到很好的处理，不过能够保证在输入规范的情况下得到良好的结果，代码总体有待完善。（总之还是对标准模板库特殊情况处理方式不够了解📌&lt;/li&gt;
&lt;li&gt;很多用不到的东西也进行了实现，导致代码量相对较大😓&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业一 Zuma List</title>
      <link>https://wanakiki.github.io/2019/zuma-list/</link>
      <pubDate>Sat, 20 Apr 2019 19:41:55 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/zuma-list/</guid>
      <description>

&lt;p&gt;数据结构第一次作业。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;

&lt;p&gt;题目要求书写程序对祖玛消除过程进行回放，输入为原始珠子序列以及玩家所做的一系列操作，要求我们按照游戏规则计算出每次操作后的珠子序列并进行输出。&lt;/p&gt;

&lt;p&gt;祖玛游戏规则：有三个或更多同色珠子变成相邻就会立即消失，并且可能会发生连锁反应。&lt;strong&gt;需要注意，原始情况中出现的三个或更多相邻同色珠子，在没有新珠子或者连锁反应影响时是不会消除的。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;将新的珠子插入到原有序列，在插入位置向两侧判断同色珠子个数，满足条件则进行删除。考虑到删除后的连锁反应，需要将判断的过程循环执行到无法继续删除。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;考虑到整个过程需要多次插入删除的操作，并且查找过程只需要从插入的具体位置向两侧进行判断，所以使用list对珠子序列进行存储。&lt;/p&gt;

&lt;p&gt;插入过程只需要简单的insert函数与advance函数相配合就可以了，使用advance函数使迭代器指到插入位置，之后再用insert函数进行插入。&lt;/p&gt;

&lt;p&gt;比较难的地方在于是否消除的判断上，考虑到迭代器的特殊性，为了避免不必要的麻烦，当list中的元素少于三个的时候直接不进行判断。对三个以上的元素判断时，需要从插入元素的位置向两侧查找相同颜色，可以用&lt;code&gt;end()&lt;/code&gt;和&lt;code&gt;begin()&lt;/code&gt;来判断是否到达了查找的两端，当然，如果在查找过程中就发现了不同的珠子就可以直接停止查找过程。查找结束之后直接对查找到的区间进行删除，同时保留左开右闭区间的右端点作为下次查找过程的起始位置。&lt;/p&gt;

&lt;p&gt;数据的输入和结果输出过程按照题目的要求进行编写即可。&lt;/p&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29c8oqxjoj30rv0zpn06.jpg&#34; alt=&#34;流程图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

void bang(list&amp;lt;char&amp;gt; &amp;amp; beads, int id, char bead){
    list&amp;lt;char&amp;gt;::iterator i, r, l;
    int num = 0;    /*计数*/
    i = beads.begin();
    advance(i, id);
    beads.insert(i, bead);  /*插入元素*/

    /*考虑到多次消除的可能，使用while循环进行消除*/
    while(1){
        if(beads.size() &amp;lt; 3)
            break;
        
        num = 0;
        r = i--;    
        /*这步操作之后r指向被插入元素以后，i指向被插入元素*/
        
        for(; r != beads.end(); r++){
            if(*r == *i)    num ++;
            else    break;
        }           /*向右判断*/

        l = i;          
        /*if(i != beads.begin()){
            l--;
            while (1){
                if(*l != *i){   l++;break;} //l需要加加
                else    num ++;
                
                if(l == beads.begin())  break;
                else    l--;    
            }
        }   //向左判断*/

        /*由流程图发现的简化方法*/
        while(l != beads.begin()){
            l--;
            if(*l != *i){   l++; break;}
            else    num++;
        }


        /*删除部分*/
        if(num &amp;gt; 1){
            beads.erase(l, r);
            i = r;
        }
        else
            break;
    }


    /*输出*/
    if(beads.empty())
        cout &amp;lt;&amp;lt; &#39;-&#39; &amp;lt;&amp;lt; endl;
    else{
        for(i = beads.begin(); i != beads.end(); i++)
            cout &amp;lt;&amp;lt; *i;
        cout &amp;lt;&amp;lt; endl;
    }
    return ;
}
int main(){
    int n, id;
    char bead;
    string initial_beads;
    list&amp;lt;char&amp;gt; beads;

    getline(cin, initial_beads);
    for(int i = 0; i &amp;lt; initial_beads.size(); i++){
        beads.push_back(initial_beads[i]);
    }
    /*构造初始状态*/

    cin &amp;gt;&amp;gt; n;
    while(n--){
        cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; bead;
        bang(beads, id, bead);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29c8i4jcrj30gi08o750.jpg&#34; alt=&#34;测试1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29c7vdgspj30hg061dg9.jpg&#34; alt=&#34;测试2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上，经过测试，程序完成要求，并且能够处理初始序列为空的情况。👍&lt;/p&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;增加了对erase函数的了解：

&lt;ol&gt;
&lt;li&gt;当参数只有一个的时候，原迭代器指向的位置被删除，迭代器无效化，不能对其继续进行操作，否则会造成错误，但函数会返回原位置之后的迭代器，所以可以利用这个特性进行区间删除（省略++步骤）。&lt;/li&gt;
&lt;li&gt;当有两个参数的时候，函数结束之后前一个迭代器会无效化，而后一个迭代器因为删除区间为左闭右开的特点，其指向的位置不会被删除。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;迭代器是一个很玄学的东西，使用不规范很容易带来错误，查错的时候可以优先考虑。&lt;/li&gt;
&lt;li&gt;流程图可以帮忙理清逻辑结构！！！😀&lt;/li&gt;
&lt;li&gt;写程序尽量一次性写完&amp;hellip;&amp;hellip;🤧&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>括号匹配</title>
      <link>https://wanakiki.github.io/2019/kuohao/</link>
      <pubDate>Sat, 20 Apr 2019 14:36:43 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/kuohao/</guid>
      <description>

&lt;p&gt;这个学期开始学数据结构，第一节课老师又提出了这个经典的问题。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;给出一个只包含&amp;rsquo;(&amp;lsquo;和&amp;rsquo;)&amp;lsquo;的字符串，判断该字符串中的括号是否匹配。并将匹配的括号用&amp;rsquo;_&amp;lsquo;代替，不匹配的括号用&amp;rsquo;$&amp;lsquo;标出。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;输入：
(())()))
输出：
(())()))
______$$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;简单解法&#34;&gt;简单解法&lt;/h2&gt;

&lt;p&gt;括号匹配问题是刚开始学习C语言的时候就接触的问题，当时老师引入这个问题的原因可能是为了介绍栈的概念，但是当时班上大多数人都采取了直接用数组模拟的方法。把整个字符串录入，之后遍历整个字符串，遇到右括号就向前寻找是否存在对应的左括号，进行判断。C++代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
using namespace std;
int main(){
    string str, tmp;    
    //tmp用于保留原来的字符串，为了方便直接用string输入
    cin &amp;gt;&amp;gt; str;
    tmp = str;
    for(int i = 0; i &amp;lt; str.length(); i++){
        if(str[i] == &#39;)&#39;){
            for(int j = i - 1; j &amp;gt;= 0; j--){
                if(str[j] == &#39;(&#39;){
                    str[i] = str[j] = &#39;_&#39;;
                    break;
                }
            }
        }
    }
    for(int i = 0; i &amp;lt; str.length(); i++){
        if(str[i] != &#39;_&#39;)
            str[i] = &#39;$&#39;;   //找出不匹配的括号
    }
    cout &amp;lt;&amp;lt; tmp &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; str;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用栈来解决&#34;&gt;使用栈来解决&lt;/h2&gt;

&lt;p&gt;首先忽略掉不匹配括号的标记问题，聚焦于判断整个字符串是否存在不匹配的括号。要看字符串是否匹配，只要看左括号是否有对应的右括号，或者右括号是否有对应的左括号，问题解决方法是相同的。&lt;/p&gt;

&lt;p&gt;读入一个左括号我们就可以把它压入栈中，遇到右括号就弹出栈中的左括号。如果所有的右括号都读取完，栈中还有左括号，或者读入一个右括号栈中已经没有了括号，就意味着该字符串中的括号不匹配。C++代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;string&amp;gt;
using namespace std;
int main(){
    stack&amp;lt;char&amp;gt; s;
    string tmp;
    cin &amp;gt;&amp;gt; tmp;
    for(int i = 0; i &amp;lt; tmp.length(); i++){
        if(tmp[i] == &#39;(&#39;)
            s.push(tmp[i]);
        else
        {
            if(s.empty())
                cout &amp;lt;&amp;lt; &amp;quot;FALSE&amp;quot;;
            else
            {
                s.pop();
            }
            
        }
        
    }
    if(!s.empty())
        cout &amp;lt;&amp;lt; &amp;quot;FALSE&amp;quot;;
    else
    {
        cout &amp;lt;&amp;lt; &amp;quot;TRUE&amp;quot;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码完全可以不用栈，设置一个变量来记录当前拥有的左括号的数量就可以大大简化代码。&lt;/p&gt;

&lt;p&gt;如果我们想要知道是哪几个字符不匹配，我的想法是直接将字符的索引压入栈中，因为只有一种括号，把字符压入栈中实际上是不必要之举。将上面的代码输出错误的地方改成记录错误的下标，就可以将出错字符的下标记录下来，当所有的右括号都判断完之后，栈中剩余的所有左括号下标也同样要记录下来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://wanakiki.github.io/about/</link>
      <pubDate>Sat, 20 Apr 2019 13:54:01 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/about/</guid>
      <description>&lt;p&gt;趁着运动会的假期把GitHub上面博客的生成方式从hexo换到了hugo，希望今后能够坚持下去😀，另外之前没有写多少博文，迁移过来并不会造成太多的麻烦。&lt;/p&gt;

&lt;p&gt;新方式的配置主要参考了&lt;a href=&#34;https://mogeko.me/2018/018/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Mogeko的博客&lt;/a&gt;，在此对他表示感谢。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>