<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wanakiki`s Blog on Wanakiki`s Blog</title>
    <link>https://wanakiki.github.io/</link>
    <description>Recent content in Wanakiki`s Blog on Wanakiki`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 25 Sep 2019 19:23:03 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>利用Termux群发短信</title>
      <link>https://wanakiki.github.io/2019/termux-sms/</link>
      <pubDate>Wed, 25 Sep 2019 19:23:03 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/termux-sms/</guid>
      <description>

&lt;p&gt;Termux的简单应用，为了让群发短信有更便捷高效的解决方案。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Termux&lt;/code&gt;是一个Android下一个高级的终端模拟器，开源且不需要root，支持apt管理软件包，十分方便安装软件包，完美支持Python、PHP、Ruby、Go、Nodejs、MySQL等。随着智能设备的普及和性能的不断提升，如今的手机、平板等的硬件标准已达到了初级桌面计算机的硬件标准，用心去打造完全可以把手机变成一个强大的工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关于软件的更多信息及基本配置，可以去看&lt;a href=&#34;https://www.sqlsec.com/2018/05/termux.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;国光的教程&lt;/a&gt;，写得很赞很全面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：由于谷歌的政策更新，Termux最新版本的API没有访问手机短信内容的权限，想要实现发送短信的功能，需要使用相对较久的0.31版本。在这里给Termux API 0.31版本&lt;a href=&#34;https://pan.baidu.com/s/1toMtUW2MOEHPY7GOtfEYUg&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;下载地址&lt;/a&gt;，提取码：ttx1。API的安装方式在国光的文章中也有给出，不清楚可以去翻看。&lt;/p&gt;

&lt;p&gt;在了解完Termux并安装好API后，我们的教程正式开始。&lt;/p&gt;

&lt;h2 id=&#34;具体实现&#34;&gt;具体实现&lt;/h2&gt;

&lt;p&gt;虽然如今的QQ、微信已经承担了大部分我们的日常通信任务，但是总有一些情况需要电话短信来解决，比如给陌生人传达某些通知。电话是最优的解决方案，但是也会有一部分人倾向于短信。在经历了无数次的折磨之后，我终于发现了&lt;code&gt;Termux&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;假设你现在有一个含有联系人姓名及电话号码的表格，将无用信息删除，只保留姓名和号码两列具体内容后，可以通过&lt;code&gt;文件 -&amp;gt; 另存为 -&amp;gt; 文本文件(制表符分隔)&lt;/code&gt;的方式获得一个格式整齐的文本文档。将其重命名为&lt;code&gt;data.txt&lt;/code&gt;，用记事本打开后选择另存为，在另存为界面调整保存编码为&lt;code&gt;UTF-8&lt;/code&gt;，这步一定要做，不然程序无法正常读取文件。&lt;/p&gt;

&lt;p&gt;将得到的文件用QQ或者TIM发送到你的手机并接受，&lt;strong&gt;按照国光的教程中建立好文件夹链接&lt;/strong&gt;的前提下。以QQ为例，在终端中输入下面几行命令便可下载好程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/QQ
wget https://raw.githubusercontent.com/wanakiki/furry/master/termux-sms/messages.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以找到默认的信息语句对其进行修改，以达到我们的目的。修改完毕后执行&lt;code&gt;python messages.py&lt;/code&gt;命令，运行程序。&lt;/p&gt;

&lt;p&gt;python实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
import os


def send_sms(aim, text):
    &amp;quot;&amp;quot;&amp;quot;use two argv to send messages
    &amp;quot;&amp;quot;&amp;quot;
    os.system(&#39;termux-sms-send -n &#39; + aim + &#39; &#39; + text)
    return


def fileMessage(fileName):
    &amp;quot;&amp;quot;&amp;quot;send messages form an excel(name, number)
    &amp;quot;&amp;quot;&amp;quot;

    print(&#39;start read file&#39;)
    try:
        fh = open(fileName, encoding=&#39;utf-8&#39;)
    except:
        print(&#39;Can\&#39;t find the data file&#39;)
        return

    # create list (name, number)
    group = []
    for line in fh:
        line = line.split()
        group.append(line)
    fh.close()

    # send message
    words = &amp;quot; hello, this is termux&amp;quot;  # Replace it with your own words
    for people in group:
        send_sms(people[1], people[0] + words)

    print(&#39;finish&#39;)
    return


def sendOne():
    aim = input(&#39;Please input your aim number\n&#39;)
    words = input(&#39;Now you can input your message\n&#39;)

    print(&#39;+=======================+&#39;)
    print(&#39;Please check your input:&#39;)
    print(&#39;number: &#39;, aim)
    print(&#39;words: &#39;, words)
    flag = input(
        &amp;quot;Now, if your input is correct, input &#39;y&#39; or &#39;Y&#39; to send your message: &amp;quot;)
    if (flag == &#39;y&#39; or flag == &#39;Y&#39;):
        send_sms(aim, words)
    return


print(&amp;quot;&amp;quot;&amp;quot;Functions:
1 Only send one message.(Test this program)
2 Send messages form one file.
+============================================+&amp;quot;&amp;quot;&amp;quot;)

flag = input(&#39;Choose the function:&#39;)
if flag == &#39;1&#39;:
    sendOne()
elif flag == &#39;2&#39;:
    fileMessage(&#39;data.txt&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/shengsai/20190925205425.png&#34; alt=&#34;运行结果&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>提取小米云服务短信</title>
      <link>https://wanakiki.github.io/2019/short-message/</link>
      <pubDate>Thu, 05 Sep 2019 12:16:09 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/short-message/</guid>
      <description>&lt;p&gt;最近手机刷了AOSIP，原来的短信都没有同步，去小米云服务官网发现没有导出按钮，稍微折腾了下达到了目的，简单记录。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;登陆&lt;a href=&#34;https://i.mi.com/?_locale=zh_CN&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;小米云服务&lt;/a&gt;，进入短信界面，这个界面是动态加载的，需要手动下滑到最底部确定所有短信都已经被加载出来。&lt;/p&gt;

&lt;p&gt;之后按下&lt;code&gt;Ctrl+s&lt;/code&gt;，把整个网页保存下来，保存之后会是一个较大的html文件，用编辑器打开，找到其中短信部分。新建一个html文件，把短信部分的代码直接复制进来，使用文本编辑器自动进行格式化。最终可以得到一个可以正常打开浏览的界面。&lt;/p&gt;

&lt;p&gt;现在基本达到了短信备份的目的，但是我最近刚好计划着换掉原来的手机号，但是又害怕之前注册过的网站密码无法找回。这时候可以用保存好的短信html文件加上简单的python脚本，提取短信内容中被方括号包裹着的信息，将提取出来的公司名输出到一个文件中，可以用来后续的手机换绑。&lt;/p&gt;

&lt;p&gt;超级简单的python脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import re

fw = open(&#39;公司列表.txt&#39;,&#39;w&#39;,encoding=&#39;UTF-8&#39;)  #引号内为输出文件名
fh = open(&#39;网页.html&#39;,encoding=&#39;UTF-8&#39;)     #引号内文件名根据自己情况修改
store = []

for line in fh:
    res = re.findall(&#39;【(.*?)】&#39;, line)
    for nm in res:
        if nm not in store:
            store.append(nm)

for x in store:
    fw.write(x + &#39;\n&#39;)
fw.close()
fh.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面脚本运行结束之后，就能得到想要的公司列表。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>新生の大学分享</title>
      <link>https://wanakiki.github.io/2019/univ-share/</link>
      <pubDate>Fri, 30 Aug 2019 22:54:12 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/univ-share/</guid>
      <description>

&lt;p&gt;可能很多人都会问怎么样才能过好自己的大学生活，但是当我想要去总结自己大学以来的经验，首先想到的大部分都是自己的遗憾，提不出来什么有价值的建议。&lt;/p&gt;

&lt;p&gt;今年的新生由我来带，借此机会整理一下之前在于老师那里听到的分享，希望能对他人带来一些启发。（当然这部分内容对于19级来说是新老生交流一部分。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;blockquote&gt;
&lt;p&gt;文章观点取自于老师的分享，暂时未询问其本人意见。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总的来看，大学可以分为三个阶段，前三学期为一阶段，大二下及大三上为一阶段，大三下及整个大四为一阶段。&lt;/p&gt;

&lt;h2 id=&#34;大学的前三个学期&#34;&gt;大学的前三个学期&lt;/h2&gt;

&lt;p&gt;从高中来到大学这个小社会，绝大部分学生，尤其是像我一样的山东考生，适应大学着实需要一定的时期。大学的生活和高中有太多不同，步入大学也会发现周围的人有各种各样的追求，如何快速适应新的环境、找到新的目标是这个阶段首要解决的问题。&lt;/p&gt;

&lt;p&gt;从大学的课程设定也可以看出，对于大部分专业的学生来说前三个学期都是打基础的过程，这个时期学习的课程主要是为自身专业化的发展打下基础，为未来的专业课程做准备。&lt;/p&gt;

&lt;p&gt;对于理工科专业，高数真的是步入大学之后最大的难题，本身高中和大学数学课程的交接设定的就不合理，高中课本与大学课本衔接程度不高，而这个时候的大学生们还在享受着自己刚刚拥有的“自由”，高数的学习时间不是很充分。最终自然导致了学习效果较差，对今后的专业课学习也会带来不利影响。这点个人深有体会。&lt;/p&gt;

&lt;p&gt;美国的本科生没有设立医学专业，学医的研究生都是从生物专业的本科生选拔而来，对这部分医学专业的学生来说，他们的适应时期是整个本科。&lt;/p&gt;

&lt;h2 id=&#34;大二下-大三上&#34;&gt;大二下，大三上&lt;/h2&gt;

&lt;p&gt;对于想要走最多人走的路的那些人，这个时期的重点在&lt;strong&gt;科研&lt;/strong&gt;。因为经过了前三个学期的学习，理论上每个人都已经掌握了基本的专业知识，可以试着以本科生的身份加入一些实验室，提前了解实验室。&lt;/p&gt;

&lt;p&gt;最佳的方案是在大二上学期的寒假或者更早就确定好方向，及时地联系老师并进行一定科研知识的学习。但是要注意的是，加入一个实验室是一件很慎重的事情，不能因为自己的一时冲动或者是好奇才去报名。你的动机会决定你最终的成就，如果你没有下好决定不如再进行一定时间的观望。&lt;/p&gt;

&lt;p&gt;进入实验室后，要避免成为工人，在大学最好要学会如何与他人交流，积极主动的人往往会获得更多的机遇。毕竟现在还是本科生，和实验室的研究生总会有一些代沟，你可能过了几个月之后还会独自一人在角落里研究一些常识性的问题。如果有这种情况，不如从一开始就和一个研究生学长学姐保持好关系，很多简单的问题可以去问学长学姐，但不是很适合去问老师。&lt;/p&gt;

&lt;h2 id=&#34;大三下以及大四&#34;&gt;大三下以及大四&lt;/h2&gt;

&lt;p&gt;如果你能够完成此前的计划，这一阶段将会成为收获的阶段。&lt;del&gt;原谅我笑了&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;大家的去向有下面几种：&lt;/p&gt;

&lt;h3 id=&#34;保研&#34;&gt;保研&lt;/h3&gt;

&lt;p&gt;整体推免比例大概有10~15%，分下面几种情况&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;普通推免：满足成绩要求，并且六级达到426分。&lt;/li&gt;
&lt;li&gt;科技竞赛：在本校，要求专业前50%并且通过四级。国二及以上的奖项可用于竞赛保研。但满足推免条件的竞赛具有不确定性。&lt;/li&gt;
&lt;li&gt;特殊学术专长：SI EI第一作者，专业前50%，通过六级。&lt;/li&gt;
&lt;li&gt;研究生支教团：支教一年，对个人的志愿服务经历有要求。&lt;/li&gt;
&lt;li&gt;在职研究生：中共党员+四级&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;考研&#34;&gt;考研&lt;/h3&gt;

&lt;p&gt;考研比例大概占毕业生的35~40%，且有一定数量的二战人员。考研有很多相关的复习计划，在这里不列出。&lt;/p&gt;

&lt;h3 id=&#34;出国&#34;&gt;出国&lt;/h3&gt;

&lt;p&gt;实验室经历可能更有帮助。&lt;/p&gt;

&lt;h3 id=&#34;主动就业&#34;&gt;主动就业&lt;/h3&gt;

&lt;p&gt;在假期参加实习，尽早规划尽早行动。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PY4E 题目整理（下）</title>
      <link>https://wanakiki.github.io/2019/python-assignments/</link>
      <pubDate>Mon, 05 Aug 2019 18:29:25 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/python-assignments/</guid>
      <description>

&lt;p&gt;Coursera中python教程同步题目整理，涉及到网络和数据库编程部分。题目地址：&lt;a href=&#34;https://www.py4e.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;py4e&lt;/a&gt;。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;blockquote&gt;
&lt;p&gt;打开网页的操作步骤，导入urllib库，urllib.requert.urlopen(url).read()
可以直接对字典进行url编码 urllib.parse.urlencode(parms)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;exploring-the-hypert-ext-transport-protocol-探索超文本传输协议&#34;&gt;Exploring the HyperT ext Transport Protocol（探索超文本传输协议）&lt;/h2&gt;

&lt;p&gt;You are to retrieve the following document using the HTTP protocol in a way that you can examine the HTTP Response headers.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://data.pr4e.org/intro-short.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://data.pr4e.org/intro-short.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are three ways that you might retrieve this web page and look at the response headers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preferred: Modify the socket1.py program to retrieve the above URL and print out the headers and data. Make sure to change the code to retrieve the above URL - the values are different for each URL.&lt;/li&gt;
&lt;li&gt;Open the URL in a web browser with a developer console or FireBug and manually examine the headers that are returned.&lt;/li&gt;
&lt;li&gt;Use the telnet program as shown in lecture to retrieve the headers and content.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enter the header values in each of the fields below and press &amp;ldquo;Submit&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;有三种方式查看相应头文件，第一种方式是使用Python脚本，第二种方式是用浏览器打开URL，在控制台查看，第三种方式是使用telnet程序。仅列出了第一种的脚本。&lt;/p&gt;

&lt;p&gt;由于网络的原因这段代码没有成功进行测试，在设定socket命令时的&lt;code&gt;\r\n&lt;/code&gt;也不清楚具体的含义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import socket

mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
mysock.connect((&#39;data.pr4e.org&#39;, 80))
print(&#39;connected&#39;)
cmd = &#39;GET http://data.pr4e.org/intro-short.txt HTTP/1.0\r\n\r\n&#39;.encode()
mysock.send(cmd)

while True:
    data = mysock.recv(512)
    if len(data) &amp;lt; 1:
        break
    print(data.decode(), end=&#39;&#39;)
mysock.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scraping-numbers-from-html-using-beautifulsoup&#34;&gt;Scraping Numbers from HTML using BeautifulSoup&lt;/h2&gt;

&lt;p&gt;In this assignment you will write a Python program similar to &lt;a href=&#34;http://www.py4e.com/code3/urllink2.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/urllink2.py&lt;/a&gt;. The program will use urllib to read the HTML from the data files below, and parse the data, extracting numbers and compute the sum of the numbers in the file.&lt;/p&gt;

&lt;p&gt;We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sample data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_42.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_42.html&lt;/a&gt; (Sum=2553)&lt;/li&gt;
&lt;li&gt;Actual data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_275913.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_275913.html&lt;/a&gt; (Sum ends with 37)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You do not need to save these files to your folder since your program will read the data directly from the URL.&lt;/p&gt;

&lt;h3 id=&#34;data-format&#34;&gt;Data Format&lt;/h3&gt;

&lt;p&gt;The file is a table of names and comment counts. You can ignore most of the data in the file except for lines like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Modu&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span class=&amp;quot;comments&amp;quot;&amp;gt;90&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Kenzie&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span class=&amp;quot;comments&amp;quot;&amp;gt;88&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Hubert&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span class=&amp;quot;comments&amp;quot;&amp;gt;87&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析网页，计算网页中数字的总和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 抓取网站中的数据并计算数据总和
import urllib.request
import urllib.parse
import urllib.error
from bs4 import BeautifulSoup


url = &#39;http://python-data.dr-chuck.net/comments_275913.html&#39;
html = urllib.request.urlopen(url).read()
soup = BeautifulSoup(html, &#39;html.parser&#39;)

span = soup(&#39;span&#39;)
res = 0
for aspan in span:
    res = res + int(aspan.get_text())

print(&#39;结果为&#39;, res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;following-links-in-python&#34;&gt;Following Links in Python&lt;/h2&gt;

&lt;p&gt;In this assignment you will write a Python program that expands on &lt;a href=&#34;http://www.py4e.com/code3/urllinks.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/urllinks.py&lt;/a&gt;. The program will use urllib to read the HTML from the data files below, extract the href= vaues from the anchor tags, scan for a tag that is in a particular position relative to the first name in the list, follow that link and repeat the process a number of times and report the last name you find.&lt;/p&gt;

&lt;p&gt;We provide two files for this assignment. One is a sample file where we give you the name for your testing and the other is the actual data you need to process for the assignment&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sample problem: Start at &lt;a href=&#34;http://py4e-data.dr-chuck.net/known_by_Fikret.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/known_by_Fikret.html&lt;/a&gt;
Find the link at position 3 (the first name is 1). Follow that link. Repeat this process 4 times. The answer is the last name that you retrieve.
Sequence of names: Fikret Montgomery Mhairade Butchi Anayah
Last name in sequence: Anayah&lt;/li&gt;
&lt;li&gt;Actual problem: Start at: &lt;a href=&#34;http://py4e-data.dr-chuck.net/known_by_Cohen.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/known_by_Cohen.html&lt;/a&gt;
Find the link at position 18 (the first name is 1). Follow that link. Repeat this process 7 times. The answer is the last name that you retrieve.
Hint: The first character of the name of the last page that you will load is: A&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;strategy&#34;&gt;Strategy&lt;/h3&gt;

&lt;p&gt;The web pages tweak the height between the links and hide the page after a few seconds to make it difficult for you to do the assignment without writing a Python program. But frankly with a little effort and patience you can overcome these attempts to make it a little harder to complete the assignment without writing a Python program. But that is not the point. The point is to write a clever Python program to solve the program.&lt;/p&gt;

&lt;h3 id=&#34;sample-execution&#34;&gt;Sample execution&lt;/h3&gt;

&lt;p&gt;Here is a sample execution of a solution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;$ python3 solution.py
Enter URL: http://py4e-data.dr-chuck.net/known_by_Fikret.html
Enter count: 4
Enter position: 3
Retrieving: http://py4e-data.dr-chuck.net/known_by_Fikret.html
Retrieving: http://py4e-data.dr-chuck.net/known_by_Montgomery.html
Retrieving: http://py4e-data.dr-chuck.net/known_by_Mhairade.html
Retrieving: http://py4e-data.dr-chuck.net/known_by_Butchi.html
Retrieving: http://py4e-data.dr-chuck.net/known_by_Anayah.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The answer to the assignment for this execution is &amp;ldquo;Anayah&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;程序要求：从指定的链接开始，解析html页面，获取所有的herf标签，找到指定位置（position）的链接，重复这个过程指定次数（count)。最终输出找到的人名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 跟踪超链接，找到目标
import urllib.request
import urllib.parse
import urllib.error
from bs4 import BeautifulSoup

# 假定输入规范
count = int(input(&#39;Enter Count:&#39;))
position = int(input(&#39;Enter Position:&#39;)) - 1    #从1开始计算位置
flag = int(input(&#39;&#39;&#39;Select Url:
1: http://py4e-data.dr-chuck.net/known_by_Fikret.html
2: http://py4e-data.dr-chuck.net/known_by_Cohen.html
&#39;&#39;&#39;))

if flag == 1:
    url = &#39;http://py4e-data.dr-chuck.net/known_by_Fikret.html&#39;
else:
    url = &#39;http://py4e-data.dr-chuck.net/known_by_Cohen.html&#39;

while True:
    html = urllib.request.urlopen(url).read()   #打开界面
    soup = BeautifulSoup(html, &#39;html.parser&#39;)   #界面解析


    #界面链接的格式为 ``&amp;lt;a href = &amp;quot;xx.com&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;``
    #应该提取a标签
    a_coll = soup(&#39;a&#39;)    #获取a标签集合 属于beautiful soup中的类型，应该是重载了括号，print(a_coll[0])支持这种访问
    href = a_coll[position].get(&#39;href&#39;, None)
    if href is None:
        print(&#39;runtime error&#39;)
        quit()

    if count &amp;gt; 1:
        count = count - 1
        url = href  # 更新url 以进一步抓取
    else:
        res = a_coll[position].get_text()   #获取内容
        break

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;extracting-data-from-xml&#34;&gt;Extracting Data from XML&lt;/h2&gt;

&lt;p&gt;In this assignment you will write a Python program somewhat similar to &lt;a href=&#34;http://www.py4e.com/code3/geoxml.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/geoxml.py&lt;/a&gt;. The program will prompt for a URL, read the XML data from that URL using urllib and then parse and extract the comment counts from the XML data, compute the sum of the numbers in the file.&lt;/p&gt;

&lt;p&gt;We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sample data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_42.xml&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_42.xml&lt;/a&gt; (Sum=2553)&lt;/li&gt;
&lt;li&gt;Actual data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_275915.xml&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_275915.xml&lt;/a&gt; (Sum ends with 24)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You do not need to save these files to your folder since your program will read the data directly from the URL. Note: Each student will have a distinct data url for the assignment - so only use your own data url for analysis.&lt;/p&gt;

&lt;h3 id=&#34;data-format-and-approach&#34;&gt;Data Format and Approach&lt;/h3&gt;

&lt;p&gt;The data consists of a number of names and comment counts in XML as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;&amp;lt;comment&amp;gt;
  &amp;lt;name&amp;gt;Matthias&amp;lt;/name&amp;gt;
  &amp;lt;count&amp;gt;97&amp;lt;/count&amp;gt;
&amp;lt;/comment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You are to look through all the &lt;code&gt;&amp;lt;comment&amp;gt;&lt;/code&gt; tags and find the &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; values sum the numbers. The closest sample code that shows how to parse XML is geoxml.py. But since the nesting of the elements in our data is different than the data we are parsing in that sample code you will have to make real changes to the code.&lt;/p&gt;

&lt;p&gt;To make the code a little simpler, you can use an XPath selector string to look through the entire tree of XML for any tag named &amp;lsquo;count&amp;rsquo; with the following line of code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;counts = tree.findall(&#39;.//count&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take a look at the Python ElementTree documentation and look for the supported XPath syntax for details. You could also work from the top of the XML down to the comments node and then loop through the child nodes of the comments node.&lt;/p&gt;

&lt;h3 id=&#34;sample-execution-1&#34;&gt;Sample Execution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;$ python3 solution.py
Enter location: http://py4e-data.dr-chuck.net/comments_42.xml
Retrieving http://py4e-data.dr-chuck.net/comments_42.xml
Retrieved 4189 characters
Count: 50
Sum: 2...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序要求：解析XML文件，计算整个文件中count标签的总和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import xml.etree.ElementTree as ET
import urllib.request
import urllib.parse
import urllib.error

url = &#39;http://py4e-data.dr-chuck.net/comments_275915.xml&#39;   # 指定URL
uh = urllib.request.urlopen(url)
data = uh.read()    #获取网页数据

print(&#39;Retrived&#39;, len(data), &#39;characters&#39;)
tree = ET.fromstring(data)
counts = tree.findall(&#39;.//count&#39;)   #查找count标签
# counts = tree.findall(&#39;comments/comment/count&#39;)
# 查找count可以使用上面这行语句

print(&#39;Count:&#39;, len(counts))

res = 0
for count in counts:
    res = res + int(count.text)

print(&#39;Sum:&#39;, res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;extracting-data-from-json&#34;&gt;Extracting Data from JSON&lt;/h2&gt;

&lt;p&gt;In this assignment you will write a Python program somewhat similar to &lt;a href=&#34;http://www.py4e.com/code3/json2.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/json2.py&lt;/a&gt;. The program will prompt for a URL, read the JSON data from that URL using urllib and then parse and extract the comment counts from the JSON data, compute the sum of the numbers in the file and enter the sum below:&lt;/p&gt;

&lt;p&gt;We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sample data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_42.json&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_42.json&lt;/a&gt; (Sum=2553)&lt;/li&gt;
&lt;li&gt;Actual data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_275916.json&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_275916.json&lt;/a&gt; (Sum ends with 15)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You do not need to save these files to your folder since your program will read the data directly from the URL. Note: Each student will have a distinct data url for the assignment - so only use your own data url for analysis.&lt;/p&gt;

&lt;h3 id=&#34;data-format-1&#34;&gt;Data Format&lt;/h3&gt;

&lt;p&gt;The data consists of a number of names and comment counts in JSON as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  comments: [
    {
      name: &amp;quot;Matthias&amp;quot;
      count: 97
    },
    {
      name: &amp;quot;Geomer&amp;quot;
      count: 97
    }
    ...
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The closest sample code that shows how to parse JSON and extract a list is json2.py. You might also want to look at geoxml.py to see how to prompt for a URL and retrieve data from a URL.&lt;/p&gt;

&lt;h3 id=&#34;sample-execution-2&#34;&gt;Sample Execution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;$ python3 solution.py
Enter location: http://py4e-data.dr-chuck.net/comments_42.json
Retrieving http://py4e-data.dr-chuck.net/comments_42.json
Retrieved 2733 characters
Count: 50
Sum: 2...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析JSON文件，获得count的总和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import urllib.request, urllib.error, urllib.parse
import json     #导入json

# - Sample data: http://py4e-data.dr-chuck.net/comments_42.json (Sum=2553)
# - Actual data: http://py4e-data.dr-chuck.net/comments_275916.json (Sum ends with 15)

url = input(&#39;Enter url &#39;)
print(&#39;Retriving&#39;, url)
uh = urllib.request.urlopen(url).read()
print(&#39;Retrived&#39;, len(uh), &#39;characters&#39;)

js = json.loads(uh)
# 观察文档结构，js为字典，js[&#39;comments&#39;]为由字典组成的list

res = 0
for comment in js[&#39;comments&#39;]:
    res = res + comment[&#39;count&#39;]

print(&#39;Sum:&#39;, res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;calling-a-json-api&#34;&gt;Calling a JSON API&lt;/h2&gt;

&lt;p&gt;In this assignment you will write a Python program somewhat similar to &lt;a href=&#34;http://www.py4e.com/code3/geojson.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/geojson.py&lt;/a&gt;. The program will prompt for a location, contact a web service and retrieve JSON for the web service and parse that data, and retrieve the first place_id from the JSON. A place ID is a textual identifier that uniquely identifies a place as within Google Maps.&lt;/p&gt;

&lt;h3 id=&#34;api-end-points&#34;&gt;API End Points&lt;/h3&gt;

&lt;p&gt;To complete this assignment, you should use this API endpoint that has a static subset of the Google Data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;http://py4e-data.dr-chuck.net/json?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This API uses the same parameter (address) as the Google API. This API also has no rate limit so you can test as often as you like. If you visit the URL with no parameters, you get &amp;ldquo;No address&amp;hellip;&amp;rdquo; response.&lt;/p&gt;

&lt;p&gt;To call the API, you need to provide the address that you are requesting as the address= parameter that is properly URL encoded using the urllib.parse.urlencode() function as shown in &lt;a href=&#34;http://www.py4e.com/code3/geojson.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/geojson.py&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;test-data-sample-execution&#34;&gt;Test Data / Sample Execution&lt;/h3&gt;

&lt;p&gt;You can test to see if your program is working with a location of &amp;ldquo;South Federal University&amp;rdquo; which will have a place_id of &amp;ldquo;ChIJ9e_QQm0sDogRhUPatldEFxw&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;$ python3 solution.py
Enter location: South Federal University
Retrieving http://...
Retrieved 2291 characters
Place id ChIJ9e_QQm0sDogRhUPatldEFxw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用谷歌API查询指定地点的&lt;code&gt;place id&lt;/code&gt;，因为谷歌地图API现在需要验证，所以最好使用PY4E提供的副本。需要注意，使用py4e提供的副本时，需要额外传递一个key参数，这点在作业说明中没有指出，查看代码包中的代码之后才发现这个值为42，&lt;a href=&#34;http://www.py4e.com/code3/geojson.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/geojson.py&lt;/a&gt; 具体见这个链接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import urllib.error, urllib.request, urllib.parse
import json

target = &#39;http://py4e-data.dr-chuck.net/json?&#39;  #使用这个接口，需要 key参数且值为42
local = input(&#39;Enter location: &#39;)

url = target + urllib.parse.urlencode({&#39;address&#39;: local, &#39;key&#39; : 42})
#对字符串进行url编码，直接传递参数和值构成的字典
print(&#39;Retriving&#39;, url)

data = urllib.request.urlopen(url).read()
print(&#39;Retrived&#39;, len(data), &#39;characters&#39;)

js = json.loads(data)
# print(json.dumps(js, indent = 4)) #查看接收到的文件结构
print(&#39;Place id&#39;, js[&#39;results&#39;][0][&#39;place_id&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;counting-organizations&#34;&gt;Counting Organizations&lt;/h2&gt;

&lt;p&gt;This application will read the mailbox data (mbox.txt) and count the number of email messages per organization (i.e. domain name of the email address) using a database with the following schema to maintain the counts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;CREATE TABLE Counts (org TEXT, count INTEGER)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you have run the program on mbox.txt upload the resulting database file above for grading.&lt;/p&gt;

&lt;p&gt;If you run the program multiple times in testing or with dfferent files, make sure to empty out the data before each run.&lt;/p&gt;

&lt;p&gt;You can use this code as a starting point for your application: &lt;a href=&#34;http://www.py4e.com/code3/emaildb.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/emaildb.py&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The data file for this application is the same as in previous assignments: &lt;a href=&#34;http://www.py4e.com/code3/mbox.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/mbox.txt&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because the sample code is using an UPDATE statement and committing the results to the database as each record is read in the loop, it might take as long as a few minutes to process all the data. The commit insists on completely writing all the data to disk every time it is called.&lt;/p&gt;

&lt;p&gt;The program can be speeded up greatly by moving the commit operation outside of the loop. In any database program, there is a balance between the number of operations you execute between commits and the importance of not losing the results of operations that have not yet been committed.&lt;/p&gt;

&lt;p&gt;此前做过的统计文本文件中每个人发送的邮件数目的升级版，统计各个公司服务器域名发送的邮件总数，将最终找到的结果保存到了数据库中。需要注意，提交sql查询时为了加快速度要放在循环外部。如何使用SQL可见&lt;a href=&#34;https://docs.python.org/zh-cn/3/library/sqlite3.html#module-sqlite3&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlite3

conn = sqlite3.connect(&#39;mail-count.sqlite&#39;)
cur = conn.cursor()

cur.execute(&#39;DROP TABLE IF EXISTS Counts&#39;)  # 如果存在就提前删除表
cur.execute(&#39;&#39;&#39;CREATE TABLE Counts (org TEXT, count INTEGER)&#39;&#39;&#39;)    # 创建表

fh = open(&#39;mbox.txt&#39;)
for line in fh:
    if not line.startswith(&#39;From:&#39;):
        continue
    mail = line.split()[1]
    index = mail.find(&#39;@&#39;)+1
    org = mail[index:]

    # 针对org执行sql后续操作，先查询再决定更新还是插入
    cur.execute(&#39;&#39;&#39;SELECT count FROM Counts WHERE org = ?&#39;&#39;&#39;, (org,) ) #execute函数第二个参数需要是元组
    num = cur.fetchone()    #返回list，查询不到时返回None

    if num is None:
        cur.execute(&#39;INSERT INTO Counts(org, count) VALUES(?, 1)&#39;, (org, ))
    else:
        cur.execute(&#39;UPDATE Counts SET count = ? WHERE org = ?&#39;, (num[0] + 1, org))
        # 在进行更新时可以直接 count = count + 1

conn.commit()   #提交放在循环外加速
cur.execute(&#39;SELECT * FROM Counts ORDER BY count DESC LIMIT 1&#39;)
print(cur.fetchone())
cur.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;musical-track-database&#34;&gt;Musical Track Database&lt;/h2&gt;

&lt;p&gt;This application will read an iTunes export file in XML and produce a properly normalized database with this structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE Artist (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name    TEXT UNIQUE
);

CREATE TABLE Genre (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name    TEXT UNIQUE
);

CREATE TABLE Album (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    artist_id  INTEGER,
    title   TEXT UNIQUE
);

CREATE TABLE Track (
    id  INTEGER NOT NULL PRIMARY KEY
        AUTOINCREMENT UNIQUE,
    title TEXT  UNIQUE,
    album_id  INTEGER,
    genre_id  INTEGER,
    len INTEGER, rating INTEGER, count INTEGER
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run the program multiple times in testing or with different files, make sure to empty out the data before each run.&lt;/p&gt;

&lt;p&gt;You can use this code as a starting point for your application: &lt;a href=&#34;http://www.py4e.com/code3/tracks.zip&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/tracks.zip&lt;/a&gt;. The ZIP file contains the Library.xml file to be used for this assignment. You can export your own tracks from iTunes and create a database, but for the database that you turn in for this assignment, only use the Library.xml data that is provided.&lt;/p&gt;

&lt;p&gt;To grade this assignment, the program will run a query like this on your uploaded database and look for the data it expects to see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT Track.title, Artist.name, Album.title, Genre.name
    FROM Track JOIN Genre JOIN Album JOIN Artist
    ON Track.genre_id = Genre.ID and Track.album_id = Album.id
        AND Album.artist_id = Artist.id
    ORDER BY Artist.name LIMIT 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The expected result of the modified query on your database is: (shown here as a simple HTML table with titles)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Track&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Artist&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Album&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Genre&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Chase the Ace&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AC/DC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Who Made Who&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Rock&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;D.T.&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AC/DC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Who Made Who&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Rock&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;For Those About To Rock (We Salute You)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AC/DC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Who Made Who&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Rock&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlite3
import xml.etree.ElementTree as ET

conn = sqlite3.connect(&#39;music.sqlite&#39;)
cur = conn.cursor()

cur.executescript(&#39;&#39;&#39;
DROP TABLE IF EXISTS Artist;
DROP TABLE IF EXISTS Genre;
DROP TABLE IF EXISTS Album;
DROP TABLE IF EXISTS Track;&#39;&#39;&#39;) 
#如果存在就先删除表
# 执行多条查询需要 executescript

cur.executescript(&#39;&#39;&#39;CREATE TABLE Artist (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name    TEXT UNIQUE
);

CREATE TABLE Genre (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name    TEXT UNIQUE
);

CREATE TABLE Album (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    artist_id  INTEGER,
    title   TEXT UNIQUE
);

CREATE TABLE Track (
    id  INTEGER NOT NULL PRIMARY KEY 
        AUTOINCREMENT UNIQUE,
    title TEXT  UNIQUE,
    album_id  INTEGER,
    genre_id  INTEGER,
    len INTEGER, rating INTEGER, count INTEGER
);&#39;&#39;&#39;)  # 执行多行时注意使用三个引号

file_name = &#39;Library.xml&#39;
fh = open(file_name)
tree = ET.fromstring(fh.read())
dicts = tree.findall(&#39;./dict/dict/dict&#39;)

# 查看xml文件，分析目录树结构 需要在/dict/dict/dict内查找字段
# 定义查找函数
def lookup(pare, aim):
    flag = False
    for child in pare:
        if flag:
            return child.text
        if child.tag == &#39;key&#39; and child.text == aim:
            flag = True
    return None

# 通过构建的数据库情况，需要查找的字段为
# Track ID   Name    Artist     Album   Play Count  Rating  Total Time

for entry in dicts:
    if(lookup(entry, &#39;Track ID&#39;) is None):  continue
    name = lookup(entry, &#39;Name&#39;)
    artist = lookup(entry, &#39;Artist&#39;)
    album = lookup(entry, &#39;Album&#39;)
    count = lookup(entry, &#39;Play Count&#39;)
    rating = lookup(entry, &#39;Rating&#39;)
    length = lookup(entry, &#39;Total Time&#39;)
    genre = lookup(entry, &#39;Genre&#39;)

    if name is None or artist is None or album is None or genre is None:
        continue
    print(name, artist, album, count, rating, length)

    # 根据建立数据库的顺序进行插入，并获取外键对应的id值
    # 注意对于唯一元素插入时使用ignore
    cur.execute(&#39;&#39;&#39;INSERT OR IGNORE INTO Artist(name) VALUES(?)&#39;&#39;&#39;, (artist,))
    cur.execute(&#39;SELECT id FROM Artist WHERE name = ?&#39;, (artist,))
    artist_id = cur.fetchone()[0]   # 查询返回的是数组

    cur.execute(&#39;INSERT OR IGNORE INTO Genre(name) VALUES(?)&#39;, (genre,))
    cur.execute(&#39;SELECT id FROM Genre WHERE name = ?&#39;,(genre,))
    genre_id = cur.fetchone()[0]

    cur.execute(&#39;INSERT OR IGNORE INTO Album(artist_id, title) VALUES(?, ?)&#39;,(artist_id, album))
    cur.execute(&#39;SELECT id FROM Album WHERE title = ?&#39;, (album,))
    album_id = cur.fetchone()[0]

    # 至于这里为什么要用replace原因不知
    cur.execute(&#39;&#39;&#39;INSERT OR REPLACE INTO Track(title, album_id, genre_id, len, rating, count) 
    VALUES(?, ?, ?, ?, ?, ?)&#39;&#39;&#39;,(name, album_id, genre_id, length, rating, count))

conn.commit()
cur.execute(&#39;&#39;&#39;SELECT Track.title, Artist.name, Album.title, Genre.name
    FROM Track JOIN Genre JOIN Album JOIN Artist
    ON Track.genre_id = Genre.ID and Track.album_id = Album.id
        AND Album.artist_id = Artist.id
    ORDER BY Artist.name LIMIT 3&#39;&#39;&#39;)
res = cur.fetchall()
for line in res:
    print(line)
cur.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然执行之后结果和示例结果不一样，但是个人认为程序没有错误。&lt;/p&gt;

&lt;h2 id=&#34;make-database-from-json&#34;&gt;Make database from JSON&lt;/h2&gt;

&lt;p&gt;This application will read roster data in JSON format, parse the file, and then produce an SQLite database that contains a User, Course, and Member table and populate the tables from the data file.&lt;/p&gt;

&lt;p&gt;You can base your solution on this code: &lt;a href=&#34;http://www.py4e.com/code3/roster/roster.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/roster/roster.py&lt;/a&gt; - this code is incomplete as you need to modify the program to store the &lt;strong&gt;role&lt;/strong&gt; column in the &lt;strong&gt;Member&lt;/strong&gt; table to complete the assignment.&lt;/p&gt;

&lt;p&gt;Each student gets their own file for the assignment. Download this file and save it as &lt;code&gt;roster_data.json&lt;/code&gt;. Move the downloaded file into the same folder as your &lt;code&gt;roster.py&lt;/code&gt; program.&lt;/p&gt;

&lt;p&gt;Once you have made the necessary changes to the program and it has been run successfully reading the above JSON data, run the following SQL command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT hex(User.name || Course.title || Member.role ) AS X FROM
    User JOIN Member JOIN Course
    ON User.id = Member.user_id AND Member.course_id = Course.id
    ORDER BY X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find the first row in the resulting record set and enter the long string that looks like 53656C696E613333.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import json
import sqlite3

conn = sqlite3.connect(&#39;rosterdb.sqlite&#39;)
cur = conn.cursor()

# 建立数据库
cur.executescript(&#39;&#39;&#39;
DROP TABLE IF EXISTS User;
DROP TABLE IF EXISTS Member;
DROP TABLE IF EXISTS Course;

CREATE TABLE User (
    id     INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name   TEXT UNIQUE
);

CREATE TABLE Course (
    id     INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    title  TEXT UNIQUE
);

CREATE TABLE Member (
    user_id     INTEGER,
    course_id   INTEGER,
    role        INTEGER,
    PRIMARY KEY (user_id, course_id)
)
&#39;&#39;&#39;)


file_name = input(&#39;Enter filename: &#39;)
if(len(file_name) &amp;lt; 1):
    file_name = &#39;roster_data.json&#39;
fh = open(file_name).read()
js = json.loads(fh)

for record in js:
    name = record[0]
    title = record[1]
    role = record[2]

    cur.execute(&#39;INSERT OR IGNORE INTO User(name) VALUES(?)&#39;, (name,))
    cur.execute(&#39;SELECT id FROM User WHERE name = ?&#39;, (name,))
    user_id = cur.fetchone()[0]

    cur.execute(&#39;INSERT OR IGNORE INTO Course(title) VALUES(?)&#39;, (title,))
    cur.execute(&#39;SELECT id FROM Course WHERE title = ?&#39;, (title,))
    course_id = cur.fetchone()[0]

    cur.execute(&#39;INSERT OR REPLACE INTO Member(user_id, course_id, role) VALUES(?,?,?)&#39;, (user_id, course_id, role))

cur.execute(&#39;&#39;&#39;SELECT hex(User.name || Course.title || Member.role ) AS X FROM 
    User JOIN Member JOIN Course 
    ON User.id = Member.user_id AND Member.course_id = Course.id
    ORDER BY X LIMIT 5&#39;&#39;&#39;)
res = cur.fetchall()
for line in res:
    print(line)

conn.commit()
cur.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多对多关系示例。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PY4E 题目整理（上）</title>
      <link>https://wanakiki.github.io/2019/python-assignment/</link>
      <pubDate>Sun, 04 Aug 2019 17:39:49 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/python-assignment/</guid>
      <description>

&lt;p&gt;Coursera中python教程同步题目整理，因为旁听课程不能直接对每章的编程作业进行提交，学到中期之后才发现&lt;a href=&#34;https://www.py4e.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;py4e&lt;/a&gt;上有几乎所有题目的在线测试环境，在看完所有的教学视频之后重新刷题，回顾知识点，在此进行整理。分为基础部分和网络及数据库编程部分。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;hello-world&#34;&gt;Hello world&lt;/h2&gt;

&lt;h3 id=&#34;problem&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Write a program that uses a print statement to say &amp;lsquo;hello world&amp;rsquo; as shown in &amp;lsquo;Desired Output&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;code&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; print(&#39;hello world&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;回顾&#34;&gt;回顾&lt;/h3&gt;

&lt;p&gt;Python中字符串可以用四种引号组合进行标注：&lt;code&gt;&#39; &amp;quot; &#39;&#39;&#39; &amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;，其中单独的单引或者双引可以使引号内部不同的引号不需要进行转义，如&lt;code&gt;&amp;quot;this is &#39;a&#39; test&amp;quot;&lt;/code&gt;中的单引号就不需要进行转义。三个单引号和双引号具有相同的作用，可以保证被定义的字符串原封不动地输出（一般定义多行），在后面执行SQL语句时有用到。同时其中的单引号或者双引号不需要转义。&lt;/p&gt;

&lt;h2 id=&#34;2-3&#34;&gt;2-3&lt;/h2&gt;

&lt;h3 id=&#34;problem-1&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Write a program to prompt the user for hours and rate per hour using input to compute gross pay. Use 35 hours and a rate of 2.75 per hour to test the program (the pay should be 96.25). You should use input to read a string and float() to convert the string to a number. Do not worry about error checking or bad user data.&lt;/p&gt;

&lt;p&gt;根据输入的时间和工资标准计算总工资，并输出。假定时间为35小时，工资标准为2.75每小时，标准结果应为96.25。&lt;/p&gt;

&lt;h3 id=&#34;desired-output&#34;&gt;Desired Output&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;Pay: 96.25
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;code-1&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# This first line is provided for you

hrs = input(&amp;quot;Enter Hours:&amp;quot;)
hrs = float(hrs)

rate = float(input(&amp;quot;Enter Rate:&amp;quot;))
print(&#39;Pay:&#39;, hrs * rate)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-1&#34;&gt;3-1&lt;/h2&gt;

&lt;h3 id=&#34;problem-2&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Write a program to prompt the user for hours and rate per hour using input to compute gross pay. Pay the hourly rate for the hours up to 40 and 1.5 times the hourly rate for all hours worked above 40 hours. Use 45 hours and a rate of 10.50 per hour to test the program (the pay should be 498.75). You should use input to read a string and float() to convert the string to a number. Do not worry about error checking the user input - assume the user types numbers properly.&lt;/p&gt;

&lt;p&gt;根据时长和工资标准计算工资，工作时间大于40小时的部分需要付1.5倍工资，标准输入为45，10.5，标准输出为498.75。&lt;/p&gt;

&lt;h3 id=&#34;code-2&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hrs = input(&amp;quot;Enter Hours:&amp;quot;)
h = float(hrs)

rate = float(input(&amp;quot;Enter Rates:&amp;quot;))
if h &amp;gt; 40:
    res = 40 * rate + (h - 40) * rate * 1.5
else:
    res = rate * 40
print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-3&#34;&gt;3-3&lt;/h2&gt;

&lt;h3 id=&#34;program&#34;&gt;Program&lt;/h3&gt;

&lt;p&gt;Write a program to prompt for a score between 0.0 and 1.0. If the score is out of range, print an error. If the score is between 0.0 and 1.0, print a grade using the following table:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Score&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Grade&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;= 0.9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;= 0.8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;= 0.7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;= 0.6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;D&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt; 0.6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;F&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If the user enters a value out of range, print a suitable error message and exit. For the test, enter a score of 0.85.&lt;/p&gt;

&lt;p&gt;按照表格输出对应的级别，要求输入在0到1，越界输出错误信息，假定输入为0.85。&lt;/p&gt;

&lt;h3 id=&#34;code-3&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;score = input(&amp;quot;Enter Score: &amp;quot;)
grade = [&#39;D&#39;,&#39;C&#39;,&#39;B&#39;,&#39;A&#39;]

try:
    score = float(score)
except:
    print(&#39;输入不是浮点数&#39;)
    quit()

if score &amp;lt; 0 or score &amp;gt; 1:
    print(&#39;输入不在指定范围&#39;)
    quit()

score = int(score * 10)

if score &amp;lt; 6:
    print(&#39;F&#39;)
elif score &amp;gt; 9:
    print(&#39;A&#39;)
else:
    print(grade[score-6])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有用那么多的判断，使用了一个list。&lt;/p&gt;

&lt;h2 id=&#34;4-6&#34;&gt;4-6&lt;/h2&gt;

&lt;h3 id=&#34;problem-3&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Write a program to prompt the user for hours and rate per hour using input to compute gross pay. Pay should be the normal rate for hours up to 40 and time-and-a-half for the hourly rate for all hours worked above 40 hours. Put the logic to do the computation of pay in a function called computepay() and use the function to do the computation. The function should return a value. Use 45 hours and a rate of 10.50 per hour to test the program (the pay should be 498.75). You should use input to read a string and float() to convert the string to a number. Do not worry about error checking the user input unless you want to - you can assume the user types numbers properly. Do not name your variable sum or use the sum() function.&lt;/p&gt;

&lt;p&gt;使用函数计算&lt;a href=&#34;#3-1&#34;&gt;3-1问题&lt;/a&gt;，假定输入规范，测试输入为45h，10.5，标准结果为498.75。&lt;/p&gt;

&lt;h3 id=&#34;code-4&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def computepay(h, r):
    if h &amp;lt;= 40:
        return h * r
    else:
        return 40 * r + (h - 40) * r * 1.5


hrs = input(&amp;quot;Enter Hours:&amp;quot;)
hrs = float(hrs)
rat = float(input(&amp;quot;Enter Rates:&amp;quot;))

p = computepay(hrs, rat)
print(p)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-2&#34;&gt;5-2&lt;/h2&gt;

&lt;h3 id=&#34;problem-4&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Write a program that repeatedly prompts a user for integer numbers until the user enters &amp;lsquo;done&amp;rsquo;. Once &amp;lsquo;done&amp;rsquo; is entered, print out the largest and smallest of the numbers. If the user enters anything other than a valid number catch it with a try/except and put out an appropriate message and ignore the number. Enter 7, 2, bob, 10, and 4 and match the output below.&lt;/p&gt;

&lt;p&gt;写一个程序监测用户输入的整数，直到用户输入“done”程序停止，之后程序输出这批数字的最大值和最小值。需要对输入进行检测，对于不合法的输入需要输出&lt;code&gt;Invalid input&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;code-5&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;largest = None
smallest = None
while True:
    num = input(&amp;quot;Enter a number: &amp;quot;)
    if num == &amp;quot;done&amp;quot;:
        break

    try:
        num = int(num)
    except:
        print(&#39;Invalid input&#39;)
        continue

    if largest is None:
        largest = num
        smallest = num
    else:
        if largest &amp;lt; num:
            largest = num
        if smallest &amp;gt; num:
            smallest = num

print(&amp;quot;Maximum is&amp;quot;, largest)
print(&amp;quot;Minimum is&amp;quot;, smallest)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-5&#34;&gt;6-5&lt;/h2&gt;

&lt;p&gt;Write code using find() and string slicing (see section 6.10) to extract the number at the end of the line below. Convert the extracted value to a floating point number and print it out.&lt;/p&gt;

&lt;p&gt;通过find和切片截取字符串中的浮点数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;text = &amp;quot;X-DSPAM-Confidence:    0.8475&amp;quot;
index = text.find(&#39;0&#39;)

res = float(text[index:])
print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;7-2&#34;&gt;7-2&lt;/h2&gt;

&lt;p&gt;Write a program that prompts for a file name, then opens that file and reads through the file, looking for lines of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;X-DSPAM-Confidence:    0.8475
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Count these lines and extract the floating point values from each of the lines and compute the average of those values and produce an output as shown below. Do not use the sum() function or a variable named sum in your solution.&lt;/p&gt;

&lt;p&gt;You can download the sample data at &lt;a href=&#34;http://www.py4e.com/code3/mbox-short.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/mbox-short.txt&lt;/a&gt; when you are testing below enter mbox-short.txt as the file name.&lt;/p&gt;

&lt;p&gt;文件操作，提取指定格式行的数据，并计算平均值。标准输出为&lt;code&gt;Average spam confidence: 0.750718518519&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def getNumber(line : str):
    index = line.find(&#39;:&#39;) + 1  #查找冒号更加合适
    return float(line[index:])

# Use the file name mbox-short.txt as the file name
fname = input(&amp;quot;Enter file name: &amp;quot;)
if len(fname) &amp;lt; 1:
    fname = &#39;mbox-short.txt&#39;
fh = open(fname)

Sum = 0
num = 0
for line in fh:
    if not line.startswith(&amp;quot;X-DSPAM-Confidence:&amp;quot;):
        continue
    Sum = Sum + getNumber(line.rstrip())
    num = num + 1

print(&#39;Average spam confidence:&#39;, Sum / num)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;8-4&#34;&gt;8-4&lt;/h2&gt;

&lt;p&gt;Open the file romeo.txt and read it line by line. For each line, split the line into a list of words using the split() method. The program should build a list of words. For each word on each line check to see if the word is already in the list and if not append it to the list. When the program completes, sort and print the resulting words in alphabetical order.&lt;/p&gt;

&lt;p&gt;You can download the sample data at &lt;a href=&#34;http://www.py4e.com/code3/romeo.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/romeo.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;读取文件，统计其中出现过的单词，按字典序输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fname = input(&amp;quot;Enter file name: &amp;quot;)
if len(fname) &amp;lt; 1:
    fname = &#39;romeo.txt&#39;
fh = open(fname)
lst = list()

for line in fh:
    line = line.rstrip()
    words = line.split()

    for word in words:
        if word not in lst:
            lst.append(word)

lst.sort()
print(lst)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;8-5&#34;&gt;8-5&lt;/h2&gt;

&lt;p&gt;Open the file mbox-short.txt and read it line by line. When you find a line that starts with &amp;lsquo;From &amp;rsquo; like the following line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will parse the From line using split() and print out the second word in the line (i.e. the entire address of the person who sent the message). Then print out a count at the end.&lt;/p&gt;

&lt;p&gt;Hint: make sure not to include the lines that start with &amp;lsquo;From:&amp;lsquo;.&lt;/p&gt;

&lt;p&gt;You can download the sample data at &lt;a href=&#34;http://www.py4e.com/code3/mbox-short.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/mbox-short.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;读文件，对其中&lt;code&gt;From&lt;/code&gt;开始的行，输出邮件来源并统计个数，在最后输出统计结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fname = input(&amp;quot;Enter file name: &amp;quot;)
if len(fname) &amp;lt; 1:
    fname = &amp;quot;mbox-short.txt&amp;quot;

fh = open(fname)
count = 0

for line in fh:
    if not line.startswith(&#39;From &#39;):
        continue
    line = line.split()
    print(line[1])
    count = count + 1

print(&amp;quot;There were&amp;quot;, count, &amp;quot;lines in the file with From as the first word&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-4&#34;&gt;9-4&lt;/h2&gt;

&lt;p&gt;Write a program to read through the mbox-short.txt and figure out who has sent the greatest number of mail messages. The program looks for &amp;lsquo;From &amp;rsquo; lines and takes the second word of those lines as the person who sent the mail. The program creates a Python dictionary that maps the sender&amp;rsquo;s mail address to a count of the number of times they appear in the file. After the dictionary is produced, the program reads through the dictionary using a maximum loop to find the most prolific committer.&lt;/p&gt;

&lt;p&gt;统计文件中的发信人行，使用字典存储每个人发送邮件的数目。最后使用一个最大for循环，查找到发送最多邮件的人。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;name = input(&amp;quot;Enter file:&amp;quot;)
if len(name) &amp;lt; 1:
    name = &amp;quot;mbox-short.txt&amp;quot;
handle = open(name)
res = dict()

for line in handle:
    if not line.startswith(&#39;From &#39;):
        continue

    line = line.split()
    author = line[1]
    res[author] = res.get(author, 0) + 1

name = None
count = None
for k, v in res.items():
    if count is None or v &amp;gt; count:
        count = v
        name = k

print(name, count)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;10-2&#34;&gt;10-2&lt;/h2&gt;

&lt;p&gt;Write a program to read through the mbox-short.txt and figure out the distribution by hour of the day for each of the messages. You can pull the hour out from the &amp;lsquo;From &amp;rsquo; line by finding the time and then splitting the string a second time using a colon.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have accumulated the counts for each hour, print out the counts, sorted by hour as shown below.&lt;/p&gt;

&lt;p&gt;统计各个时段中邮件的数目，存储到字典之中，最后按照时间顺序输出各个时间段对应的邮件数。（需要对dict进行排序）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;name = input(&amp;quot;Enter file:&amp;quot;)
if len(name) &amp;lt; 1 : name = &amp;quot;mbox-short.txt&amp;quot;
handle = open(name)

status = {}
for line in handle:
    if not line.startswith(&#39;From &#39;):
        continue

    # 抓取时间
    line = line.split()
    line = line[5]
    line = line.split(&#39;:&#39;)

    # 截取时间
    tim = line[0]
    if tim in status:
        status[tim] = status[tim] + 1
    else:
        status[tim] = 1

res = sorted([(k, v) for (k, v) in status.items()])
for k, v in res:
    print(k, v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面将dict转化为list的步骤利用了python的特性。&lt;/p&gt;

&lt;h2 id=&#34;regular-expressions&#34;&gt;Regular Expressions&lt;/h2&gt;

&lt;h3 id=&#34;finding-numbers-in-a-haystack&#34;&gt;Finding Numbers in a Haystack&lt;/h3&gt;

&lt;p&gt;In this assignment you will read through and parse a file with text and numbers. You will extract all the numbers in the file and compute the sum of the numbers.&lt;/p&gt;

&lt;h3 id=&#34;data-files&#34;&gt;Data Files&lt;/h3&gt;

&lt;p&gt;We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sample data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/regex_sum_42.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/regex_sum_42.txt&lt;/a&gt; (There are 90 values with a sum=445833)&lt;/li&gt;
&lt;li&gt;Actual data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/regex_sum_275911.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/regex_sum_275911.txt&lt;/a&gt; (There are 92 values and the sum ends with 76)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These links open in a new window. Make sure to save the file into the same folder as you will be writing your Python program. Note: Each student will have a distinct data file for the assignment - so only use your own data file for analysis.&lt;/p&gt;

&lt;h3 id=&#34;data-format&#34;&gt;Data Format&lt;/h3&gt;

&lt;p&gt;The file contains much of the text from the introduction of the textbook except that random numbers are inserted throughout the text. Here is a sample of the output you might see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;Why should you learn to write programs? 7746
12 1929 8827
Writing programs (or programming) is a very creative
7 and rewarding activity.  You can write programs for
many reasons, ranging from making your living to solving
8837 a difficult data analysis problem to having fun to helping 128
someone else solve a problem.  This book assumes that
everyone needs to know how to program ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sum for the sample text above is 27486. The numbers can appear anywhere in the line. There can be any number of numbers in each line (including none).&lt;/p&gt;

&lt;h3 id=&#34;handling-the-data&#34;&gt;Handling The Data&lt;/h3&gt;

&lt;p&gt;The basic outline of this problem is to read the file, look for integers using the re.findall(), looking for a regular expression of &amp;lsquo;[0-9]+&amp;rsquo; and then converting the extracted strings to integers and summing up the integers.&lt;/p&gt;

&lt;h3 id=&#34;my-code&#34;&gt;My Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 统计文件中数字的总和
import re

filename = input(&#39;Input filename:&#39;)
if len(filename) &amp;lt; 1:
    filename = &#39;regex_sum_275911.txt&#39;

res = 0
fh = open(filename)
for line in fh:
    tmp = re.findall(&#39;[0-9]+&#39;, line)

    # 计算一行中数字的和
    for x in tmp:
        res = res + int(x)

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;两行代码解决问题&lt;/strong&gt;（好熟悉&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Python 2
import re
print sum( [ ****** *** * in **********(&#39;[0-9]+&#39;,**************************.read()) ] )

Python 3:
import re
print( sum( [ ****** *** * in **********(&#39;[0-9]+&#39;,**************************.read()) ] ) )
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Latex 插入图片方式整理</title>
      <link>https://wanakiki.github.io/2019/latex-img/</link>
      <pubDate>Fri, 14 Jun 2019 23:22:50 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/latex-img/</guid>
      <description>&lt;p&gt;又到期末，承担了帮别人排版论文的工作。因为自己不熟悉图片的插入方式拖慢了进度，趁今天有时间整理一下。当然，最大的目的还是备忘。
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;新建一个&lt;code&gt;.tex&lt;/code&gt;文件，并将下面的代码复制到其中。在同一文件夹中准备一张图片（最好是方形），命名为&lt;code&gt;test.jpg&lt;/code&gt;。构建代码就可以看到效果，自己也可以对更多的细节进行修改。同时插入2*3或者3*3图片的情况还有待补充😀&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\documentclass[UTF8]{article}
\usepackage{graphicx} %use graph format
%\usepackage{subfig}
\usepackage{ctex}
\usepackage{CJK}
\usepackage{caption}
\usepackage{subfigure}
\usepackage{float}  %引入 H固定图片

\begin{document}
    \section{单个图片插入}
    \begin{figure}[h]
        \centering
        \includegraphics[width = 0.5\linewidth]{test.jpg}
        \caption{单个图片插入}
    \end{figure}

    \section{多个图片插入}
    一行存在两个同级图片
    \begin{figure}[h]
        \begin{minipage}[t]{0.5\linewidth}
            \centering
            \includegraphics[width = 0.5\linewidth]{test.jpg}
            \caption{左侧图片}
        \end{minipage}  %注意不要空开一行
        \begin{minipage}[t]{0.5\linewidth}
            \centering
            \includegraphics[width = 0.5\linewidth]{test.jpg}
            \caption{右侧图片}
        \end{minipage}
    \end{figure}

    在一行并排两个子图(使用subfigure达到防止两个的目的，minipage起到一侧显示两个的效果)
    \begin{figure}[H]
        \centering
        \subfigure[左子图]{
            \begin{minipage}[b]{0.5\linewidth}
                \centering
                \includegraphics[width = 0.5\linewidth]{test.jpg}\\
                \includegraphics[width = 0.5\linewidth]{test.jpg}  
            \end{minipage}
        }\subfigure[右子图]{
            \centering
            \begin{minipage}[b]{0.5\linewidth}
                \centering
                \includegraphics[width = 0.5\linewidth]{test.jpg} \\
                \includegraphics[width = 0.5\linewidth]{test.jpg}
            \end{minipage}
        }
        \caption{两个子图}
    \end{figure}

    使用minipage加自定义标签同样可以达到上述目的，自定义标签同样也可以达到表面上并列两个同级图片的效果。
    \begin{figure}[!htp]
        \begin{minipage}[t]{0.5\linewidth}%设定图片下字的宽度，在此基础尽量满足图片的长宽
        \centering
        \includegraphics[width = 0.5\linewidth]{test.jpg}
        \caption*{(a) This is the left picure.}%加*可以去掉默认前缀，作为图片单独的说明
        \label{fig:side:a}
        \end{minipage}
        \begin{minipage}[t]{0.5\linewidth}%需要几张添加即可，注意设定合适的linewidth
        \centering
        \includegraphics[width = 0.5\linewidth]{test.jpg}
        \caption*{(b)This is the right picture.}
        \label{fig:side:b}
        \end{minipage}
        \caption{两个子图}
    \end{figure}
    \end{document}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业七 Transport</title>
      <link>https://wanakiki.github.io/2019/transport/</link>
      <pubDate>Fri, 17 May 2019 09:47:43 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/transport/</guid>
      <description>

&lt;p&gt;清华OJ广度优先搜索题目。
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2 id=&#34;描述&#34;&gt;描述&lt;/h2&gt;

&lt;p&gt;某广播公司要在一个地区架设无线广播发射装置。该地区共有n个小镇，每个小镇都要安装一台发射机并播放各自的节目。&lt;/p&gt;

&lt;p&gt;不过，该公司只获得了FM104.2和FM98.6两个波段的授权，而使用同一波段的发射机会互相干扰。已知每台发射机的信号覆盖范围是以它为圆心，20km为半径的圆形区域，因此，如果距离小于20km的两个小镇使用同样的波段，那么它们就会由于波段干扰而无法正常收听节目。现在给出这些距离小于20km的小镇列表，试判断该公司能否使得整个地区的居民正常听到广播节目。&lt;/p&gt;

&lt;h3 id=&#34;输入&#34;&gt;输入&lt;/h3&gt;

&lt;p&gt;第一行为两个整数n，m，分别为小镇的个数以及接下来小于20km的小镇对的数目。 接下来的m行，每行2个整数，表示两个小镇的距离小于20km（编号从1开始）。&lt;/p&gt;

&lt;h3 id=&#34;输出&#34;&gt;输出&lt;/h3&gt;

&lt;p&gt;如果能够满足要求，输出1，否则输出-1。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;输入样例
4 3
1 2
1 3
2 4

输出样例
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;限制&lt;/p&gt;

&lt;p&gt;1 ≤ n ≤ 10000&lt;/p&gt;

&lt;p&gt;1 ≤ m ≤ 30000&lt;/p&gt;

&lt;p&gt;不需要考虑给定的20km小镇列表的空间特性，比如是否满足三角不等式，是否利用传递性可以推出更多的信息等等。&lt;/p&gt;

&lt;p&gt;时间：2 sec&lt;/p&gt;

&lt;p&gt;空间：256MB&lt;/p&gt;

&lt;p&gt;提示
BFS&lt;/p&gt;

&lt;h2 id=&#34;问题分析-解决方案&#34;&gt;问题分析&amp;amp;解决方案&lt;/h2&gt;

&lt;p&gt;通过读题不难发现题目的要点有两个：第一，每个小镇都需要安装一台发射机；第二，相距20km以内的小镇不能使用相同频率的波段。我们要做的就是通过题目给出的距离小于20km的小镇列表，判断是否能够保证每个小镇都能正常收听广播。&lt;/p&gt;

&lt;p&gt;因为相互距离小于20km的小镇之间才会发生干扰，所以我们只需要考虑这一部分小镇能否满足条件即可解决问题，而那些相隔较远的小镇在这个题目中对我们没有造成任何危害。&lt;/p&gt;

&lt;p&gt;现在我们讨论距离小于20km的这一部分小镇，假设这一部分小镇队集合为M（可以直接理解为图）。题目已经明确指出，在距离小于20km的前提下，如两个小镇有相同的波段就会互相干扰，所以对于M中任意一个小镇队(u,v)，在u的频率确定的条件下，v的频率也随之固定。&lt;/p&gt;

&lt;p&gt;因为我们对频率没有更多的附加条件，所以我们可以将FM104.2和FM98.6两个波段直接抽象为两个不同的标志，作为小镇的一个属性ele。之后我们在M内任意初始化其中一个节点的ele属性（初始化的值也是任意的，因为抽象只是为了区分两种情况），按照小镇队频率互斥的要求我们就可以把与之联通的所有小镇的ele属性确定下来。只要过程中不出现相互矛盾的点，我们就可以成功布置。&lt;/p&gt;

&lt;p&gt;考虑到给出的M可能是分块的，所以在执行完一次扩展之后程序还需要对其他节点进行判断。这样就能够保证程序的正确性。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;现在回顾一下我们需要做的操作：按照互斥的规则从任意一点展开，判断是否能够蔓延到所有的节点。因为数据是成对输入的，所以我们很容易联想到用图来保存，那么我们在这个题目中所需要的操作实质上就变成了一个图遍历的问题，更准确来讲，BFS问题，因为广度优先更有利于提前发现不满足互斥条件的点。&lt;/p&gt;

&lt;p&gt;所以实现思路也很明确了：用图的形式将输入数据保存下来，然后采用BFS策略对图进行遍历。考虑到要通过ele属性判断是否互斥，所以在定义图的节点的时候要加上这个属性，BFS中也要根据当前一轮搜索的出发点的属性设置与之相连的点的属性，或者判断已访问的点的属性是否和该轮搜索出发点的属性是否相同。&lt;/p&gt;

&lt;p&gt;关于图的存储形式，我使用的是邻接表，采用邻接矩阵会耗费较大的空间。另外还要注意，本题中的图为无向图。而ele属性的三种标记形式，我有以下两种方案，我采用的是前者。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初始状态为0，相对立的两种状态为-1和1，可以直接通过取相反数的方法更新。&lt;/li&gt;
&lt;li&gt;初始状态为2，相对立的两种状态为0和1，通过（x+1）%2的方式进行更新。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;另外一点，本次题目因为要在清华OJ上进行测试，没有stl标准库，如果要用到队列的话需要自己实现。我采用了链表和数组模拟两种方式对队列进行了实现，均通过了测试，代码将在下面给出。另外也一并附上stl版本。&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;h3 id=&#34;用链表实现队列&#34;&gt;用链表实现队列&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
//#include &amp;lt;queue&amp;gt;
using namespace std;

//队列节点
struct node_of_queue{
    int del;
    node_of_queue* next;
    node_of_queue(int v, node_of_queue* x = NULL):del(v),next(x){}
};

//队列类
class myQueue{
public:
    node_of_queue* front;
    node_of_queue* back;
    myQueue():front(NULL),back(NULL){}
    int Front(){
        if(front)
            return (front-&amp;gt;del);
        return 0;
    }
    void push(int x){
        node_of_queue* tmp = new node_of_queue(x);
        if(!front)
            front = tmp;
        if(!back)
            back = tmp;
        else{
            back-&amp;gt;next = tmp;
            back = tmp;
        }
        return ;
    }
    bool empty(){
        return front == NULL;
    }
    void pop(){
        if(front){
            node_of_queue* tmp = front;
            front = front-&amp;gt;next;
            if(!front)
                back = NULL;
            delete tmp;
        }
        return ;
    }
};

//小镇节点
struct Node{
    int _id;
    Node* _next;
    Node(int id, Node* next = NULL):_id(id), _next(next){}
};

//小镇集合
struct Nodes{
    int _ele;
    Node* _next;
    Nodes():_ele(0), _next(NULL){}
    void insert(int id);
};

void Nodes::insert(int id){
    _next = new Node(id, _next);
    return ;
}

int main(){
    Nodes nodes[10005];
    myQueue myQ;
    int n, m;
    int v, u;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while(m--){
        cin &amp;gt;&amp;gt; v &amp;gt;&amp;gt; u;
        nodes[v].insert(u);
        nodes[u].insert(v); //无向图需要两次插入
    }
    for(int cur = 1; cur &amp;lt;= n; cur++){
        if(!nodes[cur]._ele){
            nodes[cur]._ele = 1;    //进行标记
            myQ.push(cur);

            int tmp;
            while(!myQ.empty()){
                tmp = myQ.Front();
                myQ.pop();

                Node* cur_node = nodes[tmp]._next;
                while(cur_node){
                    if (nodes[cur_node-&amp;gt;_id]._ele == nodes[tmp]._ele){
                        //已放置同色
                        cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
                        return 0;
                    }
                    if(!nodes[cur_node-&amp;gt;_id]._ele){
                        //未放置
                        nodes[cur_node-&amp;gt;_id]._ele = -nodes[tmp]._ele;
                        myQ.push(cur_node-&amp;gt;_id);    //只入队没被访问过的点
                    }
                    cur_node = cur_node -&amp;gt;_next;
                }
            }
        }
    }
    cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用数组模拟队列&#34;&gt;用数组模拟队列&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
//#include &amp;lt;queue&amp;gt;
using namespace std;
int myQ[10005], front, back;    //队列数组

struct Node{
    int _id;
    Node* _next;
    Node(int id, Node* next = NULL):_id(id), _next(next){}
};
struct Nodes{
    int _ele;
    Node* _next;
    Nodes():_ele(0), _next(NULL){}
    void insert(int id);
};

void Nodes::insert(int id){
    _next = new Node(id, _next);
    return ;
}

int main(){
    Nodes nodes[10005];
    //queue&amp;lt;int&amp;gt; myQ;
    int n, m;
    int v, u;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while(m--){
        cin &amp;gt;&amp;gt; v &amp;gt;&amp;gt; u;
        nodes[v].insert(u);
        nodes[u].insert(v);
    }
    for(int cur = 1; cur &amp;lt;= n; cur++){
        if(!nodes[cur]._ele){
            nodes[cur]._ele = 1;    //进行标记
            front = back = 0;
            myQ[back++] = cur;

            int tmp;
            while(front &amp;lt; back){
                tmp = myQ[front++];

                Node* cur_node = nodes[tmp]._next;
                while(cur_node){
                    if(!nodes[cur_node-&amp;gt;_id]._ele){
                        //未放置
                        nodes[cur_node-&amp;gt;_id]._ele = -nodes[tmp]._ele;
                        myQ[back++] = cur_node-&amp;gt;_id;
                    }
                    else if (nodes[cur_node-&amp;gt;_id]._ele == nodes[tmp]._ele){
                        //已放置同色
                        cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
                        return 0;
                    }
                    cur_node = cur_node -&amp;gt;_next;
                }
            }
        }
    }
    cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;stl标准模板库&#34;&gt;stl标准模板库&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;queue&amp;gt;
using namespace std;

struct Node{
    int _id;
    Node* _next;
    Node(int id, Node* next = NULL):_id(id), _next(next){}
};
struct Nodes{
    int _ele;
    Node* _next;
    Nodes():_ele(2), _next(NULL){}
    void insert(int id);
};

void Nodes::insert(int id){
    _next = new Node(id, _next);
    return ;
}

int main(){
    Nodes nodes[100];
    queue&amp;lt;int&amp;gt; myQ;
    int n, m;
    int v, u;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while(m--){
        cin &amp;gt;&amp;gt; v &amp;gt;&amp;gt; u;
        nodes[v].insert(u);
        nodes[u].insert(v);
    }

    int s = 1;
    int cur = s;
    do
        if(nodes[cur]._ele == 2){
            nodes[cur]._ele = (nodes[cur]._ele+1)%2;    //进行标记
            myQ.push(cur);

            int tmp = cur;
            while(!myQ.empty()){
                tmp = myQ.front();
                myQ.pop();

                Node* cur_node = nodes[tmp]._next;
                while(cur_node){
                    if(nodes[cur_node-&amp;gt;_id]._ele == 2){
                        //未放置
                        nodes[cur_node-&amp;gt;_id]._ele = (nodes[tmp]._ele+1)%2;
                        myQ.push(cur_node-&amp;gt;_id);
                    }
                    else if (nodes[cur_node-&amp;gt;_id]._ele == nodes[tmp]._ele){
                        //以放置同色
                        cout &amp;lt;&amp;lt; -1 &amp;lt;&amp;lt; endl;
                        return 0;
                    }

                    cur_node = cur_node -&amp;gt;_next;
                }
            }
        }
    while(s != (cur = (++cur%n)));
    cout &amp;lt;&amp;lt; 1 &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;p&gt;最开始的代码使用的标准模板库中的queue，但是提交发现不能编译，于是自己手写了一个队列进行提交，但是只通过了7个测试。第一反应是自己的队列写错了，但经过多组数据测试之后发现是BFS过程中对已经访问过的点进行了入队操作。改正之后成功提交。之后顺便写了用数组模拟队列的代码，也成功通过。&lt;/p&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;p&gt;实现邻接表的时候发现自己对图的掌握程度相对较低，整个逻辑想了一会才能用代码写出来。这个程序一开始保存图的时候还保存成了有向图&amp;hellip;&lt;/p&gt;

&lt;p&gt;BFS搜索策略也是最近才接触，本以为上课的时候已经理解，但自己的代码写出来就有一些漏洞，这不是细节处理不到位，而是对这个概念理解的还不够清晰，不然怎么写都不会写错，即使写错了也能很快找出来。&lt;/p&gt;

&lt;p&gt;算法不能只停在纸面上，还要落实到代码中。经过了这次编程任务，我觉得我对图、图搜索相关知识的理解又加深了一些。（至少BFS记的更清楚了🙃&lt;/p&gt;

&lt;p&gt;另外感觉这次写的代码可读性不是很高📌&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2019年山东省省赛回顾</title>
      <link>https://wanakiki.github.io/2019/shengsai-2019/</link>
      <pubDate>Sun, 12 May 2019 23:24:12 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/shengsai-2019/</guid>
      <description>

&lt;p&gt;2019年5月11-12号山东省ACM竞赛回顾（想起来什么写什么，绝大部分内容和比赛内容无关）
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;第一天中午到济南大学，开幕式之后开始热身赛（开幕式上那个山东大学的老师再一次提到了山大夺冠的问题）。&lt;/p&gt;

&lt;h2 id=&#34;热身赛&#34;&gt;热身赛&lt;/h2&gt;

&lt;p&gt;今年的操作环境是64位win7，题目编译环境还是Linux。电脑上面自带的IDE是codeblocks和DevC++，比较令我意外的是，他们居然还有VSCode。在热身赛开始前稍微鼓捣了一下VSCode，发现只装了一个C++高亮的插件，也没有给好的debug配置文件。我们队只有我平时用VSCode写代码，但我发现我还是不会整配置文件，毕竟原来自己用的时候折腾好了之后就一直用下去，当时也是在别人文件的基础上修改的，有时间的话，还得研究一下这个文件怎么写。&lt;/p&gt;

&lt;p&gt;热身赛只有四个题，前三个都是挺简单的，如果日常有刷题的话应该很快就能做出来。为什么这么说呢，因为我们周围的人很快就把三个题搞定了。但是很不幸，我们到最后只做出来一个，好慌啊。&lt;br /&gt;
第一题是签到题，很简单，第二题我们看不懂题目（么的词典），第三题是当初校选出的题，我们也没有补😔。总之到最后就很尴尬的走出去了。&lt;/p&gt;

&lt;p&gt;热身赛给人印象最深刻的是最后一个题目，让我们认出21个二次元角色，并输出题目要的那几个。没有算法，只要你够死宅就可以了！&lt;/p&gt;

&lt;h2 id=&#34;正式赛&#34;&gt;正式赛&lt;/h2&gt;

&lt;p&gt;这次比赛题目比去年多，一共有十三道，虽然题目变多，但是绝大部分人能做出来的只有五道，我们就是&amp;hellip;如果能六道就是银牌。&lt;/p&gt;

&lt;p&gt;最后一题带了之狼的图片，我先看的这个，是一道简单的签到，没有很难的点，只要注意一点优化就可以。第一发WA了，zzc提醒了一下改了改就过了。整个过程就打了这一个题。&lt;/p&gt;

&lt;p&gt;djr打了我们剩下的四个题，A题日历，他看了之后直接打了，接着去做的石头，两个题都WA了一次，剩下的两个人帮忙改了改就过了。zzc说图比较简单，所以他们就直接开的那个，这个时候我看的机器人。图也是错了几次才改出来，然后zzc和我研究机器人的解法，让他实现的时候代码出现了很大的漏洞，商量之后换djr交了。&lt;/p&gt;

&lt;p&gt;剩下的两个小时，我们就一直研究其他题目，我花了很久的时间看H，但是到最后还是没搞定，而且中间还有短时间有想法写不出来，太垃圾了。整个比赛的时候变成了喷喷怪，把吐沫喷到别人身上好几次，我佛了🙃&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/shengsai/20190513000941.png&#34; alt=&#34;final&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最终的结果是铜，这是题目的链接，不知道什么时候才能补一下。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://vjudge.net/problem#OJId=ZOJ&amp;amp;probNum=&amp;amp;title=&amp;amp;source=The%2010th%20Shandong&amp;amp;category=all?tdsourcetag=s_pctim_aiomsg&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://vjudge.net/problem#OJId=ZOJ&amp;amp;probNum=&amp;amp;title=&amp;amp;source=The%2010th%20Shandong&amp;amp;category=all?tdsourcetag=s_pctim_aiomsg&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;others&#34;&gt;Others&lt;/h2&gt;

&lt;p&gt;第一天晚上没有出去，一直在旅馆呆着了，很无聊，把奇异人生最后一章的大部分看完了，剩下的一点在回来的车上看完的。我还以为那个男生是真心对歌露尔好的，没想到还真就是和日记里面写的那样，就只是想泡她！&lt;/p&gt;

&lt;p&gt;因为热身赛有一道题搞不清自己的算法错在哪了，所以晚上还折腾了一段时间的对拍。用Termux写的，不会shell所以使用的python，基本能跑程序了，但是还需要稍微整合一下。&lt;/p&gt;

&lt;p&gt;省赛金牌会发实习offer，我觉得学弟学妹们需要的话可以往这个方向稍微用点力，当然我也一样😂&lt;/p&gt;

&lt;p&gt;最后的比赛冠军是烟台大学，山东大学占了二三名🤔&lt;/p&gt;

&lt;p&gt;最后来的时候刮起了大风，一上车就开始下雨了，去上车的路上沙子眯眼了好几次😒，这感觉，的确挺亲切的&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>函数对象和函数指针</title>
      <link>https://wanakiki.github.io/2019/funs/</link>
      <pubDate>Wed, 08 May 2019 21:21:26 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/funs/</guid>
      <description>

&lt;p&gt;简单复习一下函数对象和函数指针。
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2 id=&#34;函数指针&#34;&gt;函数指针&lt;/h2&gt;

&lt;p&gt;函数指针，简单点来理解就是一个指向函数的的指针变量，函数指针所指的是一个函数的入口地址。&lt;/p&gt;

&lt;p&gt;函数指针主要有两个作用：用来调用函数和作为函数的参数。&lt;/p&gt;

&lt;h3 id=&#34;函数指针的声明方法及赋值&#34;&gt;函数指针的声明方法及赋值&lt;/h3&gt;

&lt;p&gt;声明方式： 数据类型标识符 (指针变量名) (形参列表)&lt;br /&gt;
例如： &lt;code&gt;int (*fun) (int x);&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中需要注意一点，指针变量名一定要用括号括起来，因为如果不加括号，我们的编译器就会默认其为返回值为指针的一个函数。&lt;/p&gt;

&lt;p&gt;为了方便我们的使用，我们可以用typedef进行声明。之后定义函数指针就会方便许多。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;typedef int(*PF) (int x);
PF pf;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对一个函数指针赋值我们不需要使用取地址符，因为一个函数的函数名就是该函数的入口指针，我们可以直接对函数指针赋值。&lt;/p&gt;

&lt;p&gt;另外，我认为定义（或者说声明）函数指针时就只是相当于声明一个函数，所以函数指针定义时形参的变量名可以省略，&lt;br /&gt;
即 &lt;code&gt;int (*fun) (int x);&lt;/code&gt; 和 &lt;code&gt;int (*fun) (int);&lt;/code&gt; 效果是一样的。&lt;/p&gt;

&lt;h3 id=&#34;调用方法及测试&#34;&gt;调用方法及测试&lt;/h3&gt;

&lt;p&gt;用函数指针调用函数时有两种调用方式：&lt;code&gt;fun(x)&lt;/code&gt; 和 &lt;code&gt;(*fun)(x)&lt;/code&gt;。&lt;br /&gt;
而函数指针作为函数参数时，只需要在函数定义时将其写在函数的形参中，函数内部可以直接使用函数指针指向的函数。&lt;/p&gt;

&lt;p&gt;测试程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

typedef void (*PF) (int);

void visit(int x){
    cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl;
}

void visit_usePf(int x, void (*pf)(int)){
    pf(x);
}

int main(){
    PF pf1;
    void (*pf2) (int);
    void (*pf3) (int x);

    //typedef 声明测试
    pf1 = visit;
    pf1(1);
    (*pf1)(2);

    //第一种定义测试
    pf2 = visit;
    pf2(3);
    visit_usePf(4, pf2);

    //第二种定义测试
    pf3 = visit;
    pf3(5);
    visit_usePf(6, pf3);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数对象&#34;&gt;函数对象&lt;/h2&gt;

&lt;p&gt;在C++中，实现了&lt;code&gt;operator()&lt;/code&gt;的类或者结构体，都可被称为函数对象并进行直接调用。在学习数据结构时图的优先级遍历所使用的优先级更新器便是一个函数对象。sort函数所需要的比较器也是一个函数对象。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

class funA{
    public:
    void operator()(){
        cout &amp;lt;&amp;lt; &amp;quot;Function Object&amp;quot; &amp;lt;&amp;lt; endl;
    }
};

class funB{
    public:
    //函数输出两个数的和
    int operator()(int a, int b){
        return a + b;
    }
};

int main(){
    funA hello;
    funB sum;
    hello();
    cout &amp;lt;&amp;lt; sum(1, 2) &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业六 旅行商（TSP）</title>
      <link>https://wanakiki.github.io/2019/tsp/</link>
      <pubDate>Tue, 07 May 2019 23:55:50 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/tsp/</guid>
      <description>

&lt;p&gt;图论第一次作业，不需要提交报告，在OJ上提交。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;描述&#34;&gt;描述&lt;/h2&gt;

&lt;p&gt;Shrek是一个大山里的邮递员，每天负责给所在地区的n个村庄派发信件。但杯具的是，由于道路狭窄，年久失修，村庄间的道路都只能单向通过，甚至有些村庄无法从任意一个村庄到达。这样我们只能希望尽可能多的村庄可以收到投递的信件。&lt;/p&gt;

&lt;p&gt;Shrek希望知道如何选定一个村庄A作为起点（我们将他空投到该村庄），依次经过尽可能多的村庄，路途中的每个村庄都经过仅一次，最终到达终点村庄B，完成整个送信过程。这个任务交给你来完成。&lt;/p&gt;

&lt;h3 id=&#34;输入&#34;&gt;输入&lt;/h3&gt;

&lt;p&gt;第一行包括两个整数n，m，分别表示村庄的个数以及可以通行的道路的数目。&lt;/p&gt;

&lt;p&gt;以下共m行，每行用两个整数v1和v2表示一条道路，两个整数分别为道路连接的村庄号，道路的方向为从v1至v2，n个村庄编号为[1, n]。&lt;/p&gt;

&lt;p&gt;1 ≤ n ≤ 1,000,000&lt;/p&gt;

&lt;p&gt;0 ≤ m ≤ 1,000,000&lt;/p&gt;

&lt;p&gt;输入保证道路之间没有形成环&lt;/p&gt;

&lt;h3 id=&#34;输出&#34;&gt;输出&lt;/h3&gt;

&lt;p&gt;输出一个数字，表示符合条件的最长道路经过的村庄数。&lt;/p&gt;

&lt;h3 id=&#34;输入样例-1&#34;&gt;输入样例 1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;4 3
1 4
2 4
4 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;输出样例-1&#34;&gt;输出样例 1&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;

&lt;p&gt;先进性拓扑排序，之后dp找到最大值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;
#define myMax(x,y) ((x) &amp;gt; (y) ? (x) : (y))
int inDeg[1000005] = {0};   //入度 用于拓扑排序
int tpSorted[1000005] = {0};    //拓扑排序的顺序

//单个村庄
struct village{
    int id;
    village * next_village;
    village(int _id, village* next = NULL):id(_id),next_village(next){}
};

struct villages{
    village* _next;
    int dp; //直接写入属性
    villages():_next(NULL), dp(1){}
    void add(int next_id);
}Villages[1000005];

void villages::add(int next_id){
    inDeg[next_id] ++;
    if(!_next){
        _next = new village(next_id);
    }
    else{
        _next = new village(next_id, _next);
    }
}

//全局变量真好用...
int topologicalSort(int n){
    int res = 0;    //记录最大值
    int size = 0;   //拓扑数组长度
    for(int i = 1; i &amp;lt;= n; i++)
        if(!inDeg[i])
            tpSorted[size++] = i;
    
    //对数组进行操作
    for(int i = 0; i &amp;lt; size; i++){
        village* cur = Villages[tpSorted[i]]._next;
        while(cur){
            Villages[cur-&amp;gt;id].dp = myMax(Villages[tpSorted[i]].dp+1, Villages[cur-&amp;gt;id].dp);
            res = myMax(Villages[cur-&amp;gt;id].dp, res);

            inDeg[cur-&amp;gt;id]--;
            if(!inDeg[cur-&amp;gt;id])
                tpSorted[size++] = cur-&amp;gt;id;
            cur = cur-&amp;gt;next_village;
        }
    }
    return res;
}
int main(){
    int n, m, v1, v2;
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    while(m--){
        cin &amp;gt;&amp;gt; v1 &amp;gt;&amp;gt; v2;
        Villages[v1].add(v2);        
    }
    cout &amp;lt;&amp;lt; topologicalSort(n) &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业四 表达式树</title>
      <link>https://wanakiki.github.io/2019/bin-tree/</link>
      <pubDate>Fri, 03 May 2019 18:56:50 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/bin-tree/</guid>
      <description>

&lt;p&gt;从中缀表达式构建二叉树
&lt;!-- more --&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190146.jpg&#34; alt=&#34;题目要求&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;问题分析-解决方案&#34;&gt;问题分析 &amp;amp; 解决方案&lt;/h2&gt;

&lt;p&gt;题目要求输入一个中缀表达式，构建其相应的表达式树，并输出验证。&lt;/p&gt;

&lt;p&gt;表达式树的特点是操作符所对应的两个操作数分别对应于操作符的左孩子和右孩子。直接从中缀表达式构建相对困难，考虑此前已经有过从中缀表达式构建后缀表达式的经验，以及后缀表达式运算符位于操作数之后的特点，可以从后缀表达式入手解决该问题。&lt;/p&gt;

&lt;p&gt;通过对表达式树和后缀表达式的观察不难得出可以通过以下方法从后缀表达式得到表达式树：后缀表达式自后向前遍历，在右节点优先级高于左节点的前提下根据当前遍历元素类型进行以下两种操作：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当前元素为运算符，将运算符构建为树的一个节点，若为右孩子则将操作节点压栈。无论是左孩子还是右孩子，之后操作节点转移到新建节点。&lt;/li&gt;
&lt;li&gt;当前元素为操作数，将运算符构建为树的一个节点，若为左孩子则操作节点转移到栈顶节点，栈弹出。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最终解决方案为：将输入的中缀表达式转化为后缀表达式，再按照上述规则构建整个表达式树。同时还要注意最终树形的输出。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;参照课本，构建节点类、二叉树类，并对其中的相关函数进行实现，另外准备一个函数将中缀表达式构建为后缀表达式，并进行树的构建。&lt;/p&gt;

&lt;p&gt;课本中并没有节点深度这个属性，但终端输出时节点如果具有深度属性会非常方便，于是对其进行了补充，并添加了相关的函数对节点的深度进行更新，与高度更新一致调用。这里需要注意，高度的更新是自下向上，深度的更新则是自上而下，需要一个遍历的过程，我在具体实现的过程中采用了层遍历的方式。&lt;/p&gt;

&lt;h3 id=&#34;终端输出的思考&#34;&gt;终端输出的思考&lt;/h3&gt;

&lt;p&gt;如何在终端中输出是一个比较困难的问题。因为终端输出一行后不能回退到上一行，如果不对各个元素提前保存，就要在遍历的时候进行一些小操作。同时输出时空格的控制也需要细节处理。在这里简单介绍一下我的做法。&lt;/p&gt;

&lt;p&gt;我采用的方法是使用层遍历的方法，同时为每一个节点增加横坐标，遍历节点的同时更新节点的横坐标，根据横坐标和深度的情况判断是否需要换行和需要输出空格的数量。伴随着二叉树深度的增加，每层的节点呈指数级增长，如果一开始输出的节点之间的间隔控制的不好，后续的输出就会变得困难。&lt;/p&gt;

&lt;p&gt;高度为n的满二叉树，最底层有2^n个节点，考虑到底层节点不能直接相邻（至少隔一个空格），所以最底层所占字符总长为2^(n+1)个。现假设我们按照满二叉树的形式对整个树进行输出，输出区域为长为2^(n+1)个字符，高为n行的矩形，根节点位于整个图形的对称轴上，故根节点的横坐标为2^n，同理可推得根节点的左孩子的横坐标为2^(n-1)。考虑到在满二叉树的情况下每层节点之间的间隔是一定值，且为该层最左侧节点的横坐标，故在已知一个节点的横坐标及下一层的固定节点间隔的情况下，可以更新出该节点两个孩子的横坐标。&lt;/p&gt;

&lt;p&gt;按照上述方法在进行层遍历的同时对节点横坐标进行更新，记录上一个节点的横坐标，即使二叉树不是完全二叉树也能够正常输出形状。当然，因为终端的宽度一定，当层数大到最后一排无法显示的时候形状一定会发生改变。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190620.png&#34; alt=&#34;结构示意&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190145.jpg&#34; alt=&#34;中缀表达式变为逆波兰表达式&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190144.jpg&#34; alt=&#34;从逆波兰表达式构建树&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;p&gt;共编写了三个文件：node.h、Bintree.h、main.cpp&lt;/p&gt;

&lt;p&gt;1.node.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#define stature(p) ((p) ? (p)-&amp;gt;height : -1)

//节点指针的判断
#define IsLc(x) ((x)-&amp;gt;parent &amp;amp;&amp;amp; ((x) == (x)-&amp;gt;parent-&amp;gt;l_c))
#define IsRc(x) ((x)-&amp;gt;parent &amp;amp;&amp;amp; ((x) == (x)-&amp;gt;parent-&amp;gt;r_c))

#include &amp;lt;iostream&amp;gt;
using namespace std;
//NULL 在何处定义？

template &amp;lt;typename T&amp;gt;
struct node{
    T data;
    node&amp;lt;T&amp;gt;* parent;
    node&amp;lt;T&amp;gt;* l_c;
    node&amp;lt;T&amp;gt;* r_c;
    int height;
    int axis;  //打印时空格
    int depth;  //深度非常重要！
    
    //构造函数
    node():parent(NULL), l_c(NULL), r_c(NULL), height(0), axis(0), depth(0){}
    node(T e, node&amp;lt;T&amp;gt;* p=NULL, node&amp;lt;T&amp;gt;* lc=NULL, node&amp;lt;T&amp;gt;* rc = NULL, int h=0):data(e),parent(p),l_c(lc),r_c(rc),height(h),axis(0),depth(0){}

    node&amp;lt;T&amp;gt;* insertLc(T const&amp;amp;);
    node&amp;lt;T&amp;gt;* insertRc(T const&amp;amp;);
};

//两个插入的实现
template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* node&amp;lt;T&amp;gt;::insertLc(T const&amp;amp; e){
    return l_c = new node(e, this);
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* node&amp;lt;T&amp;gt;::insertRc(T const&amp;amp; e){
    return r_c = new node(e, this);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.bintree.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;node.h&amp;quot;
#include &amp;lt;queue&amp;gt;

template &amp;lt;typename T&amp;gt;
class Bintree{
    node&amp;lt;T&amp;gt;* _root;
    int _size;

public:
    //构造
    Bintree():_root(NULL),_size(0){}

    //更新高度、深度
    void updateHight(node&amp;lt;T&amp;gt; *x);
    void updateDepth(node&amp;lt;T&amp;gt;* x);
    void updateHD(node&amp;lt;T&amp;gt; *x);

    //节点插入e
    node&amp;lt;T&amp;gt;* insertAsRoot (T const&amp;amp; e);
    node&amp;lt;T&amp;gt;* insertAsLc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e);
    node&amp;lt;T&amp;gt;* insertAsRc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e); 

    //获得节点指针
    node&amp;lt;T&amp;gt;* getRoot();
    // node&amp;lt;T&amp;gt;* getLc(node&amp;lt;T&amp;gt;* x);
    // node&amp;lt;T&amp;gt;* getRc(node&amp;lt;T&amp;gt;* x);
    //上面这两个没有用了....

    //大小
    int size(){ return _size;}

    //表达
    void treeShow();

    // void createBlank(int n);
};



template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::updateHight(node&amp;lt;T&amp;gt;* x){
    x-&amp;gt;height = 1 + (stature(x-&amp;gt;l_c) &amp;gt; stature(x-&amp;gt;r_c) ? stature(x-&amp;gt;l_c) : stature(x-&amp;gt;r_c));
}

template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::updateDepth(node&amp;lt;T&amp;gt;* x){
    if(x == _root)  return;
    x-&amp;gt;depth = 1 + x-&amp;gt;parent-&amp;gt;depth;
    
}
template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::updateHD(node&amp;lt;T&amp;gt;* x){
    node&amp;lt;T&amp;gt;* y = x;
    while(x){
        updateHight(x);
        x = x-&amp;gt;parent;
    }
    queue&amp;lt; node&amp;lt;T&amp;gt;* &amp;gt; tmp;
    if(y){
        tmp.push(y);
        while(!tmp.empty()){
            updateDepth(tmp.front());
            if(tmp.front()-&amp;gt;l_c)
                tmp.push(tmp.front()-&amp;gt;l_c);
            if(tmp.front()-&amp;gt;r_c)
                tmp.push(tmp.front()-&amp;gt;r_c);
            tmp.pop();
        }
    }
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::insertAsRoot(T const&amp;amp; e){
    _size = 1;
    return _root = new node&amp;lt;T&amp;gt;(e);
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::insertAsLc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e){
    _size++;
    x-&amp;gt;insertLc(e);
    updateHD(x);
    return x-&amp;gt;l_c;
}   

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::insertAsRc(node&amp;lt;T&amp;gt;* x, T const&amp;amp; e){
    _size++;
    x-&amp;gt;insertRc(e);
    updateHD(x);
    return x-&amp;gt;r_c;
}

template &amp;lt;typename T&amp;gt;
node&amp;lt;T&amp;gt;* Bintree&amp;lt;T&amp;gt;::getRoot(){
    return _root;
}

template &amp;lt;typename T&amp;gt;
void Bintree&amp;lt;T&amp;gt;::treeShow(){
    int num = 1;
    int  n = _root-&amp;gt;height;  //获得高度
    while(n--){ num *= 2;}

    //层遍历
    queue&amp;lt; node&amp;lt;T&amp;gt;* &amp;gt; tmp;
    node&amp;lt;T&amp;gt;* curr;
    int last_axis = 0, last_depth = 0;
    if(_root)
        tmp.push(_root);
    while(!tmp.empty()){
        // if(last != tmp.front()-&amp;gt;parent){
        //     num /=2;
        //     cout &amp;lt;&amp;lt; endl;
        //     for(int i = 0; i &amp;lt; num; i++)
        //         cout &amp;lt;&amp;lt; &#39; &#39;;
        // }
        // else
        //     for(int i = 0; i &amp;lt; 2*num-1; i++)
        //         cout &amp;lt;&amp;lt; &#39; &#39;;
        //改为从父亲那里得到横坐标

        //新的一层 改变num 同时last_axis清零  (通过比较深度)
        curr = tmp.front();
        if(last_depth != curr-&amp;gt;depth){
            num/=2;
            last_axis = 0;
            cout &amp;lt;&amp;lt; endl;
        }
            
        if(curr == _root)
            _root-&amp;gt;axis = num;
        else{
            if(IsLc(curr))
                curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis - num;
            else
                curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis + num; 
        }


        //输出空格 需要减一
        for(int i = 0; i &amp;lt; curr-&amp;gt;axis - last_axis - 1; i++) 
            cout &amp;lt;&amp;lt; &#39; &#39;;
        cout &amp;lt;&amp;lt; curr-&amp;gt;data;
        last_depth = curr-&amp;gt;depth;
        last_axis = curr-&amp;gt;axis;

        if(curr -&amp;gt; l_c)
            tmp.push(curr-&amp;gt;l_c);
        if(curr -&amp;gt; r_c)
            tmp.push(curr-&amp;gt;r_c);
        tmp.pop();
    }

    return ;
}

// template &amp;lt;typename T&amp;gt;
// void Bintree&amp;lt;T&amp;gt;::createBlank(int n){
//     while(n--)
//         cout &amp;lt;&amp;lt; &#39; &#39;;
//     return ;
// }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.main.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;bintree.h&amp;quot;
#include &amp;lt;string&amp;gt;
#include &amp;lt;stack&amp;gt;


//从中缀表达式构建
void create_from_infix(Bintree&amp;lt;char&amp;gt;&amp;amp; my_tree){
    string strs, res;
    stack&amp;lt;char&amp;gt; tmp;    //运算符
    
    cout &amp;lt;&amp;lt; &amp;quot;Input infix expression :&amp;quot; &amp;lt;&amp;lt; endl;
    cin &amp;gt;&amp;gt; strs;
    

    for(int i = 0; i &amp;lt; strs.size(); i++){
        if(strs[i] &amp;gt;= &#39;0&#39;)
            res += strs[i];
        else if(strs[i] == &#39;(&#39;)
            tmp.push(strs[i]);
        else if(strs[i] == &#39;)&#39;){
            while(tmp.top() != &#39;(&#39;){
                res += tmp.top();
                tmp.pop();
            }
            tmp.pop();  //清除多余的&#39;(&#39;
        }
        else if(strs[i] == &#39;+&#39; || strs[i] == &#39;-&#39;){
            while(!tmp.empty()){
                if(tmp.top() == &#39;(&#39;)
                    break;  //左括号额外注意
                res += tmp.top();
                tmp.pop();
            }
            tmp.push(strs[i]);     //当前操作的运算符入栈
        }
        else if(strs[i] == &#39;*&#39; || strs[i] == &#39;/&#39;){
            while(!tmp.empty()){
                if(tmp.top() == &#39;(&#39; || tmp.top()  == &#39;+&#39; || tmp.top()  == &#39;-&#39;)
                    break;  //不能全部输出
                res += tmp.top();
                tmp.pop();
            }
            tmp.push(strs[i]);     //入栈当前运算符
        }
    }

    //栈中多余运算符
    while(!tmp.empty()){
        res += tmp.top();
        tmp.pop();
    }

    cout &amp;lt;&amp;lt; &amp;quot;Postfix expression is :&amp;quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; res &amp;lt;&amp;lt; endl;

    //开始造树
    my_tree.insertAsRoot(res[res.size()-1]);
    node&amp;lt;char&amp;gt;* x = my_tree.getRoot();
    stack&amp;lt;node&amp;lt;char&amp;gt;*&amp;gt; nodes;
    nodes.push(x);  //防止最后一个操作数访问错误
    for(int i = res.size()-2; i &amp;gt;= 0; i--){
        if(res[i] &amp;gt;= &#39;0&#39;){
            //数字或者字母作为左孩子插入时需要向上返回
            if(x-&amp;gt;r_c){
                my_tree.insertAsLc(x, res[i]);
                x = nodes.top();
                nodes.pop();
            }
            else
                my_tree.insertAsRc(x, res[i]);
        }
        else{
            //字符一定会移动
            
            if(x-&amp;gt;r_c)
                x = my_tree.insertAsLc(x, res[i]);
            else{
                nodes.push(x);
                x = my_tree.insertAsRc(x, res[i]);
            }
        }
    }
}


int main(){
    Bintree&amp;lt;char&amp;gt; my_tree;
    create_from_infix(my_tree);
    cout &amp;lt;&amp;lt; &amp;quot;Tree is:&amp;quot;&amp;lt;&amp;lt;endl;
    my_tree.treeShow();
}

//封装的意义只是为了自动更新高度？删除更加方便？
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;qt图形化界面&#34;&gt;QT图形化界面&lt;/h2&gt;

&lt;p&gt;初次接触QT，花费了较多的时间来了解Qt的使用。对QpaintEvent理解的不是很透彻，实现的时候参考了网上的一些代码。程序使用了此前编写的二叉树类，中缀表达式转化为二叉树部分也与控制台程序一致。&lt;/p&gt;

&lt;h3 id=&#34;程序实现&#34;&gt;程序实现&lt;/h3&gt;

&lt;p&gt;Qt项目使用了此前编写的二叉树头文件，draw.cpp、main.cpp、draw.h实现如下：&lt;/p&gt;

&lt;p&gt;1.draw.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#ifndef DRAW_H
#define DRAW_H

#include &amp;lt;QMainWindow&amp;gt;
#include &amp;lt;QPaintEvent&amp;gt;
#include &amp;quot;bintree.h&amp;quot;

namespace Ui {
class draw;
}

class draw : public QMainWindow
{
    Q_OBJECT

public:
    Bintree&amp;lt;char&amp;gt; my_tree;
    QPaintEvent * tmp;
    explicit draw(QWidget *parent = nullptr);
    ~draw();
    void createTree();
    void paintEvent(QPaintEvent *);

private:
    Ui::draw *ui;
signals:

public slots:
//    void paintEvent(QPaintEvent *);
//    void createTree();
    //void showTree(bool checked);
    void createClicked();

};

#endif // DRAW_H
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.draw.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;draw.h&amp;quot;
#include &amp;quot;ui_draw.h&amp;quot;
#include &amp;lt;QPainter&amp;gt;
#include &amp;lt;string&amp;gt;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;QString&amp;gt;
#include &amp;lt;QtDebug&amp;gt;
#include &amp;lt;QChar&amp;gt;
#include &amp;lt;QtCore&amp;gt;

draw::draw(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::draw)
{

    ui-&amp;gt;setupUi(this);
    //this-&amp;gt;connect(ui-&amp;gt;pushButton, SIGNAL(clicked(bool)), this, SLOT(createTree()));
    this-&amp;gt;connect(ui-&amp;gt;huizhi, SIGNAL(clicked(bool)), this, SLOT(createClicked()));
}

draw::~draw()
{
    delete ui;
}

void draw::createClicked(){
    createTree();
    paintEvent(tmp);
    update();

}
void draw::paintEvent(QPaintEvent *)
{
    QPainter painter(this);
    node&amp;lt;char&amp;gt;* x = my_tree.getRoot();
    node&amp;lt;char&amp;gt;* curr;
    if(x){
        //层遍历第一遍
        int last_axis = 0, last_depth = 0;
        int num = 1, n = x-&amp;gt;height;
        while(n--)  num *= 2;

        queue&amp;lt;node&amp;lt;char&amp;gt;* &amp;gt; tmp;

        //画线
        tmp.push(x);
        while(!tmp.empty()){
            curr = tmp.front();
            if(last_depth != curr-&amp;gt;depth){
                        num/=2;
                        last_axis = 0;
             }
            if(curr == x)
                        curr-&amp;gt;axis = num;
             else{
                        if(IsLc(curr))
                            curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis - num;
                        else
                            curr-&amp;gt;axis = curr-&amp;gt;parent-&amp;gt;axis + num;
             }

            last_depth = curr-&amp;gt;depth;
            last_axis = curr-&amp;gt;axis;
            if(curr-&amp;gt;l_c)
                tmp.push(curr-&amp;gt;l_c);
            if(curr-&amp;gt;r_c)
                tmp.push(curr-&amp;gt;r_c);
            tmp.pop();

            if(x == curr)
                continue;   //根节点不用画线
            painter.drawLine(30*curr-&amp;gt;axis+30, 130+100*curr-&amp;gt;depth, 30*curr-&amp;gt;parent-&amp;gt;axis+30, 130+100*curr-&amp;gt;parent-&amp;gt;depth);

       }

        //层遍历第二遍 画节点
        tmp.push(x);
        while(!tmp.empty()){
            curr = tmp.front();
            painter.setBrush(Qt::green);
            painter.drawEllipse(30*curr-&amp;gt;axis, 100+100*curr-&amp;gt;depth,60,60);
            painter.drawText(30*curr-&amp;gt;axis+25, 100*curr-&amp;gt;depth+135, QChar(curr-&amp;gt;data));
            qDebug()&amp;lt;&amp;lt;QChar(curr-&amp;gt;data)&amp;lt;&amp;lt;endl;

            if(curr-&amp;gt;l_c)
                tmp.push(curr-&amp;gt;l_c);
            if(curr-&amp;gt;r_c)
                tmp.push(curr-&amp;gt;r_c);
            tmp.pop();
        }
    }
}

void draw::createTree()
{
    //QString str = ui-&amp;gt;line-&amp;gt;toPlainText().toStdString().data();    //我佛了
      QString str = ui-&amp;gt;line-&amp;gt;text();
//    QString res;
    std::string res;
    std::string strs = str.toStdString();
    stack&amp;lt;char&amp;gt; tmp;

    for(int i = 0; i &amp;lt; strs.size(); i++){
            if(strs[i] &amp;gt;= &#39;0&#39;)
                res += strs[i];
            else if(strs[i] == &#39;(&#39;)
                tmp.push( strs[i]);
            else if(strs[i] == &#39;)&#39;){
                while(tmp.top() != &#39;(&#39;){
                    res += tmp.top();
                    tmp.pop();
                }
                tmp.pop();  //清除多余的&#39;(&#39;
            }
            else if(strs[i] == &#39;+&#39; || strs[i] == &#39;-&#39;){
                while(!tmp.empty()){
                    if(tmp.top() == &#39;(&#39;)
                        break;  //左括号额外注意
                    res += tmp.top();
                    tmp.pop();
                }
                tmp.push(strs[i]);     //当前操作的运算符入栈
            }
            else if(strs[i] == &#39;*&#39; || strs[i] == &#39;/&#39;){
                while(!tmp.empty()){
                    if(tmp.top() == &#39;(&#39; || tmp.top()  == &#39;+&#39; || tmp.top()  == &#39;-&#39;)
                        break;  //不能全部输出
                    res += tmp.top();
                    tmp.pop();
                }
                tmp.push(strs[i]);     //入栈当前运算符
            }
        }

        //栈中多余运算符
        while(!tmp.empty()){
            res += tmp.top();
            tmp.pop();
        }

        //开始造树
        my_tree.insertAsRoot(res[res.size()-1]);
            node&amp;lt;char&amp;gt;* x = my_tree.getRoot();
            stack&amp;lt;node&amp;lt;char&amp;gt;*&amp;gt; nodes;
            nodes.push(x);
            for(int i = res.size()-2; i &amp;gt;= 0; i--){
                if(res[i] &amp;gt;= &#39;0&#39;){
                    //数字或者字母作为左孩子插入时需要向上返回
                    if(x-&amp;gt;r_c){
                        my_tree.insertAsLc(x, res[i]);
                        x = nodes.top();
                        nodes.pop();
                    }
                    else
                        my_tree.insertAsRc(x, res[i]);
                }
                else{
                    //字符一定会移动

                    if(x-&amp;gt;r_c)
                        x = my_tree.insertAsLc(x, res[i]);
                    else{
                        nodes.push(x);
                        x = my_tree.insertAsRc(x, res[i]);
                    }
                }
            }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.main.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;draw.h&amp;quot;
#include &amp;lt;QApplication&amp;gt;

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    draw w;
    w.show();

    return a.exec();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行效果&#34;&gt;运行效果&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190211.jpg&#34; alt=&#34;样例&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190213.jpg&#34; alt=&#34;非对称树&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/bin-tree/20190503190212.jpg&#34; alt=&#34;一般情况&#34; /&gt;&lt;/p&gt;

&lt;p&gt;两个参考链接：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.itread01.com/content/1541521344.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.itread01.com/content/1541521344.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.yalewoo.com/2016/01/14/binary_tree_graphical_display/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.yalewoo.com/2016/01/14/binary_tree_graphical_display/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;p&gt;这次作业因为事先没有考虑到横坐标的问题，遍历更新横坐标的代码写了两遍，其实这个部分完全可以作为一个成员函数写在类中，不过当我发现这个问题的时候第二遍已经写了一半多了，所以就没有改。大部分时间都去研究Qt了，所以构建树的部分可能会有漏洞。由于时间紧迫Qt程序就没有多做细节处理，另外报告撰写的质量也较低。&lt;/p&gt;

&lt;p&gt;Qt程序不是生成图片，而是调用画笔，所以当深度过大之后会有很大部分看不到，而且经某人测试，层数达到十几层之后程序会直接bug，具体是那个地方越界还没有时间判断。现在有一个无限画布的想法但是还没有尝试去实现。总之收获还是蛮大的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;有时候先画出来流程图简化过程之后再写代码效率会更高。&lt;/li&gt;
&lt;li&gt;面对新领域而又不需要实现特别困难的功能时：犹豫，就会败北，头铁，就会白给。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业五 Compression</title>
      <link>https://wanakiki.github.io/2019/compression/</link>
      <pubDate>Fri, 03 May 2019 14:00:51 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/compression/</guid>
      <description>

&lt;p&gt;图片有损压缩大作业&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;问题分析-解决方案&#34;&gt;问题分析 &amp;amp; 解决方案&lt;/h2&gt;

&lt;p&gt;本次编程任务给出了一个纯英文的PDF文件，较为详细地介绍了图像有损压缩算法的实现方式，通过二叉树的树剪枝达到保留图片细节的目的。任务要求达到的效果如下图所示，可以看出较为复杂的图腾部分得到了很好的保留，而树叶和远处的背景则被明显地压缩成了像素区块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134525.jpg&#34; alt=&#34;示例&#34; /&gt;&lt;/p&gt;

&lt;p&gt;和编程任务一同给出的源码包中已经实现了绝大部分代码，我们需要按照给出的方法对缺失的代码进行补充，从这方面来讲，整个编程任务相当于一个稍微复杂的程序填空题。另外不得不提的一点是，所给的源码格式较为规范，仔细研究代码的整体框架对日后的编程也有一定的好处，也正因其规范性，代码整体阅读难度较低。&lt;/p&gt;

&lt;p&gt;总体来看，整个工程由五个部分组成，其从属关系为：PNG类包含RGBAPixel类，并且通过loadpng中的函数对图片进行最底层的读写。twoDtree通过一个PNG类进行构建，stats在构建的过程中起到辅助作用，加快整个构建过程。程序的宏观框架大致如此，stats中的所有函数都要我们对其进行具体实现，twoDtree中的大部分关键代码都要我们对其进行补充，而其余的三个文件在了解了类的定义方式及大致的成员函数的用法之后便可不必深究。&lt;/p&gt;

&lt;p&gt;不难看出，任务只要求对twoDtree和stats两个部分进行补充，刚好将整个任务分为两个部分，由于twoDtree对stats有一定依赖性，首先处理stats的部分。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;此前已经叙述清楚，任务可以被分为两个部分，接下来对两个部分算法的设计进行说明。&lt;/p&gt;

&lt;h3 id=&#34;stats类函数的实现&#34;&gt;stats类函数的实现&lt;/h3&gt;

&lt;p&gt;从任务说明中可以了解到，stats类是通过对图片各个通道的像素值进行预计算，使生成二叉树时每种分割情况下计算variability measurement 的复杂度降到常数时间，并能够返回指定小矩阵的多种信息。其中最大的难点便是如何进行预计算使下面的公式降低到常数时间。这里，为了计算方便我们使用等式右边的公式。&lt;/p&gt;

&lt;p&gt;$$\sum(x-\bar x)^{2}=\sum x^{2}-\frac{(\sum x)^{2}}{\left| R \right|}$$&lt;/p&gt;

&lt;p&gt;结合stats中已经定义的六个二维矩阵不难想到对整个图片各个通道的颜色值及其平方进行累加，如果我们采用当前点的值等于位于该点上方和左侧的两个值及自身三个值累加的方式对整个图片进行递推计算的话，算到最终结果之后会发现很难对这个生成的二维向量进行高效的利用，因为多次累了重复值，起初不明显，等到面积增大之后就会变成很难处理的问题。&lt;/p&gt;

&lt;p&gt;稍加思考（hhh，花了将近一个小时）之后我们得到了另外的一种方法，既然我们之前的问题是每计算一个点的值都会导致之前的值被重复计算，为了解决它，我们在计算的时候直接减去会被重复计算的点，这样，最终生成的二维向量中的每个值都等于以原点和当前点确定的矩形中的所有点的累加。&lt;/p&gt;

&lt;p&gt;具体实现为：在计算一个点的值的时候，除了加上其上方和左侧的两个点，还要减去左上方的点，按照这个规则进行递推计算，最终的结果就是我们想要的情况。&lt;/p&gt;

&lt;p&gt;对于生成矩阵的利用我们用图形进行解释：如图所示，我们已经得到了我们所需的累加和矩阵，矩阵中的每个点的值都等于该点与原点确定的矩形中所有点的累加和。现在我们想要计算出图中绿色矩形所对应的累加和。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/compression/20190503135249.png&#34; alt=&#34;示例图&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;直观来看，sum = 整体 - 蓝色 - 橙色 - 红色
已知: 整体 = D, 蓝色 = B - A，橙色 = C - A，红色 = A
则不难推出，sum = D - B - C + A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照上述公式我们便可以在常数时间内计算出任何子矩阵对应的累加和。为了方便后续的计算，我在处理矩阵的时候多开辟了额外的空间并存上零，简化了代码。&lt;/p&gt;

&lt;h3 id=&#34;twodtree的探索&#34;&gt;twoDtree的探索&lt;/h3&gt;

&lt;p&gt;twoDtree中主要让我们实现的功能有两个，建树和剪枝，至于从树还原到图片和树的基础操作函数是相对基本的内容，通过课上的学习以及对程序框架的理解应该可以很轻松地写出来，在这里不浪费笔墨一个个进行阐述。&lt;/p&gt;

&lt;h4 id=&#34;建树函数buildtree&#34;&gt;建树函数buildTree&lt;/h4&gt;

&lt;p&gt;通过对程序的阅读我们可以了解到，二叉树是从图片构建来的，而buildTree便是构造树的关键函数，我们可以把树的一般初始化先在构造函数内写出来，提前准备好该函数需要的参数，之后在构造函数中对其进行调用，生成整个树的框架。&lt;/p&gt;

&lt;p&gt;首先审视一下作业PDF中对树的构造方法的解释，我理解的方法是：父节点对应于一个大矩形，如果这个大矩形内有大于两个的像素值，我们就要对它进行分割，划为两个矩形，使两个子矩阵的色彩多样性（我反正这么叫）之和达到最小，这两个矩形就分别对应于左右孩子，这里需要注意左右孩子的顺序。这个过程需要一直执行下去，直到图片中的每个像素都对应于树的叶子节点。&lt;strong&gt;需要注意，由于我们不是对称切分，所以最终生成的树并不会是理想结构，我们只能保证的一点是，这个树是一个真二叉树。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这样我们要做的事情就很清楚了，无非就是从根节点开始这个过程，每到一个节点都假设一条虚拟的线，对这个矩形进行切割，分别计算两个矩形的色彩多样性之和，考虑完所有的横纵情况后选择最好的那种。按着这条线切割后继续进行这个过程，直到分为单个像素点。关于如何在常数时间内计算出一个矩形的色彩多样性，我们在stats相关内容中已经进行了说明。&lt;/p&gt;

&lt;h4 id=&#34;剪枝函数prune&#34;&gt;剪枝函数prune&lt;/h4&gt;

&lt;p&gt;在我看来，这个函数是整个问题最难的点，因为我想不到一个高效的算法只遍历一遍叶子节点。&lt;/p&gt;

&lt;p&gt;如何剪枝？一个子树的根节点像素值便是这个子树对应矩形所有像素值的平均，我们要做的事情是计算出这个矩形中和各通道色值与平均值差的平方的和小于等于tolerance的个数，然后计算这一部分像素占像素总个数的比例，如果大于给定值，就代表这个矩形中像素之间的差异不大，我们就可以将这个子树的枝叶剪掉，只留下根节点。反映到图形上来，就是将这个矩形的颜色涂成了平均值。&lt;/p&gt;

&lt;p&gt;最终的实现方法很简单，先进行层序遍历，对遍历到的每个节点再进行一次遍历，统计满足条件叶子的个数，最后计算比例，判断是否需要删除。但是这个程序中有这么一句话，让我以为有超级简单的算法可以实现这个过程。但是很不幸，最终还是没有找到。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Pruning criteria should be evaluated on the original tree, not on a pruned subtree. (we only expect that trees would be pruned once.)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134502.png&#34; alt=&#34;stats&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134518.png&#34; alt=&#34;建树&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;p&gt;stats.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;quot;stats.h&amp;quot;
using namespace std;
using namespace cs221util;

stats::stats(PNG &amp;amp;im){
    //resize
    unsigned width = im.width();
    unsigned height = im.height();
    sumRed.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumGreen.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumBlue.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumsqRed.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumsqGreen.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));
    sumsqBlue.resize(width+1, vector&amp;lt;long&amp;gt;(height+1, 0));

    RGBAPixel *tmp ;
    // sumRed[0][0] = int(tmp-&amp;gt;r);
    // sumGreen[0][0] = int(tmp-&amp;gt;g);
    // sumBlue[0][0] = int(tmp-&amp;gt;b);
    // sumsqRed[0][0] = int(tmp-&amp;gt;r)*int(tmp-&amp;gt;r);
    // sumsqBlue[0][0] = int(tmp-&amp;gt;b)*int(tmp-&amp;gt;b);
    // sumsqGreen[0][0] = int(tmp-&amp;gt;g)*int(tmp-&amp;gt;g);

    // for(int i = 1; i &amp;lt; im.width; i++){
    //     tmp = im.getPixel(i,0);    
    //     sumRed[i][0] = int(tmp-&amp;gt;r);
    //     sumGreen[i][0] = int(tmp-&amp;gt;g);
    //     sumBlue[i][0] = int(tmp-&amp;gt;b);
    //     sumsqRed[i][0] = int(tmp-&amp;gt;r)*int(tmp-&amp;gt;r);
    //     sumsqBlue[i][0] = int(tmp-&amp;gt;b)*int(tmp-&amp;gt;b);
    //     sumsqGreen[i][0] = int(tmp-&amp;gt;g)*int(tmp-&amp;gt;g);
    // }
    // for(int i = 1; i &amp;lt; im.height; i++){
    //     tmp = im.getPixel(0, i);
    //     sumRed[0][i] = int(tmp-&amp;gt;r);
    //     sumGreen[0][i] = int(tmp-&amp;gt;g);
    //     sumBlue[0][i] = int(tmp-&amp;gt;b);
    //     sumsqRed[0][i] = int(tmp-&amp;gt;r)*int(tmp-&amp;gt;r);
    //     sumsqBlue[0][i] = int(tmp-&amp;gt;b)*int(tmp-&amp;gt;b);
    //     sumsqGreen[0][i] = int(tmp-&amp;gt;g)*int(tmp-&amp;gt;g);
    // }

    for(unsigned int i = 1; i &amp;lt;= width; i++)
    for(unsigned int j = 1; j &amp;lt;= height; j++){
        tmp = im.getPixel(i-1, j-1);
        sumRed[i][j] = (int)(tmp-&amp;gt;r) + sumRed[i-1][j] + sumRed[i][j-1] - sumRed[i-1][j-1];
        sumGreen[i][j] = (int)(tmp-&amp;gt;g) + sumGreen[i-1][j] + sumGreen[i][j-1] - sumGreen[i-1][j-1];
        sumBlue[i][j] = (int)(tmp-&amp;gt;b) + sumBlue[i-1][j] + sumBlue[i][j-1] - sumBlue[i-1][j-1];
        sumsqRed[i][j] = (int)(tmp-&amp;gt;r)*(int)(tmp-&amp;gt;r) + sumsqRed[i-1][j] + sumsqRed[i][j-1] - sumsqRed[i-1][j-1];
        sumsqBlue[i][j] = (int)(tmp-&amp;gt;b)*(int)(tmp-&amp;gt;b) + sumsqBlue[i-1][j] + sumsqBlue[i][j-1] - sumsqBlue[i-1][j-1];
        sumsqGreen[i][j] = (int)(tmp-&amp;gt;g)*(int)(tmp-&amp;gt;g) + sumsqGreen[i-1][j] + sumsqGreen[i][j-1] - sumsqGreen[i-1][j-1];
    }
    //没有必要强转为int...
}

long stats::getSum(char channel, pair&amp;lt;int, int&amp;gt; ul, pair&amp;lt;int, int&amp;gt; lr){
    long ans = 0;
    switch (channel)
    {
    case &#39;r&#39;:
        /* code */
        ans = sumRed[lr.first+1][lr.second+1];
        ans -= sumRed[ul.first][lr.second+1];
        ans -= sumRed[lr.first+1][ul.second];
        ans += sumRed[ul.first][ul.second];
        break;
    case &#39;g&#39;:
        ans = sumGreen[lr.first+1][lr.second+1];
        ans -= sumGreen[ul.first][lr.second+1];
        ans -= sumGreen[lr.first+1][ul.second];
        ans += sumGreen[ul.first][ul.second];
        break;
    case &#39;b&#39;:
        ans = sumBlue[lr.first+1][lr.second+1];
        ans -= sumBlue[ul.first][lr.second+1];
        ans -= sumBlue[lr.first+1][ul.second];
        ans += sumBlue[ul.first][ul.second];
        break;
    default:
        break;
    }
    return ans;
}

long stats::getSumSq(char channel, pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    long ans = 0;
    switch (channel)
    {
    case &#39;r&#39;:
        /* code */
        ans = sumsqRed[lr.first+1][lr.second+1];
        ans -= sumsqRed[ul.first][lr.second+1];
        ans -= sumsqRed[lr.first+1][ul.second];
        ans += sumsqRed[ul.first][ul.second];
        break;
    case &#39;g&#39;:
        ans = sumsqGreen[lr.first+1][lr.second+1];
        ans -= sumsqGreen[ul.first][lr.second+1];
        ans -= sumsqGreen[lr.first+1][ul.second];
        ans += sumsqGreen[ul.first][ul.second];
        break;
    case &#39;b&#39;:
        ans = sumsqBlue[lr.first+1][lr.second+1];
        ans -= sumsqBlue[ul.first][lr.second+1];
        ans -= sumsqBlue[lr.first+1][ul.second];
        ans += sumsqBlue[ul.first][ul.second];
        break;
    default:
        break;
    }
    return ans;
}

long stats::rectArea(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    return (lr.first-ul.first+1)*(lr.second-ul.second+1);
}

RGBAPixel stats::getAvg(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    long sum = rectArea(ul, lr);
    long sum_r, sum_g, sum_b;
    sum_r = getSum(&#39;r&#39;, ul, lr) / sum;
    sum_g = getSum(&#39;g&#39;, ul, lr) / sum;
    sum_b = getSum(&#39;b&#39;, ul, lr) / sum;
    return RGBAPixel(sum_r, sum_g, sum_b);
}

long stats::getScore(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr){
    long sum = rectArea(ul, lr);
    long sum_r, sum_g, sum_b;
    long sumsq_r, sumsq_g, sumsq_b;
    sum_r = getSum(&#39;r&#39;, ul, lr);
    sum_g = getSum(&#39;g&#39;, ul, lr);
    sum_b = getSum(&#39;b&#39;, ul, lr);
    sumsq_r = getSumSq(&#39;r&#39;, ul, lr);
    sumsq_g = getSumSq(&#39;g&#39;, ul, lr);
    sumsq_b = getSumSq(&#39;b&#39;, ul, lr);

    //alpha置一？
    //是否考虑溢出？
    sum_r = sum_r * sum_r / sum;
    sum_g = sum_g * sum_g / sum;
    sum_b = sum_b * sum_b / sum;
    sumsq_r -= sum_r;
    sumsq_g -= sum_g;
    sumsq_b -= sum_b;
    return sumsq_r + sumsq_g + sumsq_b;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;twoDtree.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;/**
 *
 * twoDtree (pa3)
 * slight modification of a Kd tree of dimension 2.
 * twoDtree.cpp
 * This file will be used for grading.
 *
 */

#include &amp;quot;twoDtree.h&amp;quot;
#include &amp;lt;stack&amp;gt;
#include &amp;lt;queue&amp;gt;

/* given */
twoDtree::Node::Node(pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr, RGBAPixel a)
    :upLeft(ul),lowRight(lr),avg(a),left(NULL),right(NULL)
    {}

/* given */
twoDtree::~twoDtree(){
    clear();
}

/* given */
twoDtree::twoDtree(const twoDtree &amp;amp; other) {
    copy(other);
}

/* given */
twoDtree &amp;amp; twoDtree::operator=(const twoDtree &amp;amp; rhs){
    if (this != &amp;amp;rhs) {
        clear();
        copy(rhs);
    }
    return *this;
}

twoDtree::twoDtree(PNG &amp;amp; imIn){ 
    /* your code here */
    height = imIn.height();
    width = imIn.width();
    stats my_stat(imIn);
    pair&amp;lt;int, int&amp;gt; cur_ul, cur_lr;
    cur_ul = make_pair(0,0);
    cur_lr = make_pair(width-1, height-1);  
    //注意坐标从零开始
    
    root = buildTree(my_stat, cur_ul, cur_lr);
}

twoDtree::Node * twoDtree::buildTree(stats &amp;amp; s, pair&amp;lt;int,int&amp;gt; ul, pair&amp;lt;int,int&amp;gt; lr) {
    /* your code here */
    Node *cur = new Node(ul, lr, s.getAvg(ul, lr));

    //遍历所有情况
    //if(s.rectArea(ul,lr) &amp;gt; 1){    条件导致死循环
    if(ul != lr){
        bool flag = 1;  //1 means horizontal 0 means vertical
        int line = 0;
        long tmp;
        long Min = 9999999999;
        for(int i = ul.second; i &amp;lt; lr.second; i++){
            tmp = s.getScore(ul, pair&amp;lt;int,int&amp;gt; (lr.first, i)) + s.getScore(pair&amp;lt;int,int&amp;gt; (ul.first, i+1),lr);
            if(tmp &amp;lt; Min){
                Min = tmp;
                line = i;
            }
        }

        for(int i = ul.first; i &amp;lt; lr.first; i++){
            tmp = s.getScore(ul, pair&amp;lt;int,int&amp;gt; (i,lr.second)) + s.getScore(pair&amp;lt;int,int&amp;gt;(i+1, ul.second), lr);
            if((i == ul.first &amp;amp;&amp;amp; ul.second == ul.first) || tmp &amp;lt; Min){
                flag = 0;
                Min = tmp;
                line = i;
            }
        }
        
        if(flag){
            cur-&amp;gt;left = buildTree(s, ul, pair&amp;lt;int,int&amp;gt;(lr.first, line));
            cur-&amp;gt;right = buildTree(s, pair&amp;lt;int,int&amp;gt;(ul.first, line+1), lr);
        }
        else{
            cur-&amp;gt;left = buildTree(s, ul, pair&amp;lt;int,int&amp;gt;(line, lr.second));
            cur-&amp;gt;right = buildTree(s, pair&amp;lt;int,int&amp;gt;(line+1,ul.second), lr);
        }
    }
    else{
        cur-&amp;gt;left = NULL;
        cur-&amp;gt;right = NULL;
    }
    return cur;
}

PNG twoDtree::render(){
    /* your code here */
    PNG res(width, height);
    renderHelper(res, root);
    return res;
}

void twoDtree::renderHelper(PNG&amp;amp; res, Node* cur_node){
    if(!cur_node) return;   //稍微多余

    if(cur_node-&amp;gt;left == cur_node-&amp;gt;right){
        //只有两个都是空也就是叶子节点才会进行操作
        for(int i = cur_node-&amp;gt;upLeft.first; i &amp;lt;= cur_node-&amp;gt;lowRight.first; i++)
        for(int j = cur_node-&amp;gt;upLeft.second; j &amp;lt;= cur_node-&amp;gt;lowRight.second; j++){
            *res.getPixel(i, j) = cur_node-&amp;gt;avg;
        }
        return ;
    }
    else{
        renderHelper(res, cur_node-&amp;gt;left);
        renderHelper(res, cur_node-&amp;gt;right);
    }
}




void twoDtree::prune(double pct, int tol){
    /* your code here */
    //先逐层遍历，对每个节点判断是否需要剪枝
    queue&amp;lt;Node*&amp;gt; traverse_save;
    Node* cur;
    int sum, total; //小于tol个数，矩形像素数
    double rate;
    traverse_save.push(root);
    while(!traverse_save.empty()){
        cur = traverse_save.front();
        traverse_save.pop();

        if(cur == NULL)
            continue;
        sum = pruneHelper(cur, tol, cur-&amp;gt;avg);
        total = (cur-&amp;gt;lowRight.first-cur-&amp;gt;upLeft.first+1)*(cur-&amp;gt;lowRight.second-cur-&amp;gt;upLeft.second+1);
        rate = sum / total;

        if(rate &amp;gt;= pct){
            removeNode(cur-&amp;gt;left);
            cur-&amp;gt;left = NULL;
            removeNode(cur-&amp;gt;right);
            cur-&amp;gt;right = NULL;
        }
        else{
            traverse_save.push(cur-&amp;gt;left);
            traverse_save.push(cur-&amp;gt;right);
        }
    }
}

int twoDtree::pruneHelper(Node* cur, int tol, RGBAPixel avg){
    if(!cur)
        return 0;
    
    //只计算叶子
    if(cur-&amp;gt;left == NULL &amp;amp;&amp;amp; cur-&amp;gt;right == NULL){
        long diff = (avg.r - cur-&amp;gt;avg.r)*(avg.r - cur-&amp;gt;avg.r) + (avg.g - cur-&amp;gt;avg.g)*(avg.g - cur-&amp;gt;avg.g) + (avg.b - cur-&amp;gt;avg.b);
        if(diff &amp;lt;= tol)
            return 1;
        else return 0;
    }
    return pruneHelper(cur-&amp;gt;left, tol, avg) + pruneHelper(cur-&amp;gt;right, tol, avg);
}
void twoDtree::clear() {
    /* your code here */
    removeNode(root);
    root = NULL;
}

void twoDtree::removeNode(Node * x){
    if(!x) return ;
    removeNode(x-&amp;gt;left);
    removeNode(x-&amp;gt;right);
    delete x;
    return ;
}

void twoDtree::copy(const twoDtree &amp;amp; orig){
    /* your code here */
    //已经对copy进行了说明，不需要进行空间释放
    //本程序中仅有两次调用，调用之前都保证空间已经被初始化
    height = orig.height;
    width = orig.width;
    root = copyNode(orig.root);
}

twoDtree::Node*  twoDtree::copyNode(const Node* x){
    if(!x) return NULL;
    Node *tmp = new Node(x-&amp;gt;upLeft, x-&amp;gt;lowRight, x-&amp;gt;avg);
    tmp-&amp;gt;left = copyNode(x-&amp;gt;left);
    tmp-&amp;gt;right = copyNode(x-&amp;gt;right);
    return tmp;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;p&gt;程序在wsl下编译完成，在main函数中添加了显示时间的部分代码，从编译到程序结束的整个过程如下图，对wsl用户名进行了一下处理，不过不影响观察。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134416.png&#34; alt=&#34;编译运行&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面简单说一下图片的生成情况，自己程序生成的图片和示例图片取得了大体一致的效果，但在细节保留方面以及图片美观程度上稍逊一筹。两个人像画都能做到近乎一致的保留，但稍加观察便可发现细节保留上的差距，下图右侧嘴唇部分处理远不如左侧（效果示例）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/20190503134507.png&#34; alt=&#34;人像对比&#34; /&gt;&lt;/p&gt;

&lt;p&gt;两组图腾的图片，细节较多的图片效果直在几处微小处出现了不同，因为大多数像素都被保留不具备较大的对比价值，在这里不进行详细对比。而另一张则表现出了极大的差别。很容易看出，树丛的细节在我的程序中删除的程度较重，误差最大的一部分甚至直接出现了较大的单色矩形块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/compression/20190503142116.png&#34; alt=&#34;图腾对比&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;简单分析&#34;&gt;简单分析&lt;/h3&gt;

&lt;p&gt;我个人认为我的代码实现没有太大的问题，都满足了题目的要求。所给代码中给定的pct和tol值可能适合于跑出示例图片的代码，对我的代码达到不了较好的保存程度。这点是可以理解的。&lt;/p&gt;

&lt;p&gt;不同人有不同的实现方式，不同的实现会带来不同的效果，横切还是竖切的选择，数据的计算表达式的书写方式等因素都会带来影响，涉及到浮点数，计算机内部采用的是近似计算，起初微小的误差经历后续计算之后可能会放大很多倍。所以效果有偏差是情理之中的事情。&lt;/p&gt;

&lt;p&gt;对于最后图腾图片的较大色块问题，假如参数真的一致，那就应该是我的算法有一些漏洞，细节处理时有一定的问题。&lt;/p&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;p&gt;我用了一周的时间去想高效的剪枝遍历解决方式，失败之后采用我起初认为最笨最麻烦的方式实现了剪枝函数，最终的运行时间另我很意外，我感觉我一直都在低估自己电脑的运算能力，大多数情况都只停留于感觉，没有进行较为科学的判断和推理，今后应该加强自己这方面的估算能力。另外如果可以的话，我想知道有没有更高效的算法，因为四张图片17秒的速度还是很慢。😕&lt;/p&gt;

&lt;p&gt;另外在帮别人调试代码的时候发现了win和linux下long型所占内存的不同，这导致两种环境下long型对应的最大值也不同，在win下编译出来的程序在计算过程中会直接越界，需要换用long long 类型。这次编程因为之前没有用vscode建过工程所以使用wsl进行的编译。程序中有部分代码直接在win下编译也会有一点点小问题，这难道也是linux的优势🐎？&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业三 列车调度</title>
      <link>https://wanakiki.github.io/2019/train/</link>
      <pubDate>Sun, 21 Apr 2019 10:41:45 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/train/</guid>
      <description>

&lt;p&gt;本次作业不需提交报告。
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2 id=&#34;题目描述&#34;&gt;题目描述&lt;/h2&gt;

&lt;p&gt;Input&lt;/p&gt;

&lt;p&gt;共两行。&lt;/p&gt;

&lt;p&gt;第一行为两个整数n，m。&lt;/p&gt;

&lt;p&gt;第二行为以空格分隔的n个整数，保证为{1, 2, &amp;hellip;, n}的一个排列，表示待判断可行性的驶出序列{a1，a2，&amp;hellip;，an}。&lt;/p&gt;

&lt;p&gt;Output&lt;/p&gt;

&lt;p&gt;若驶出序列可行，则输出操作序列，其中push表示车厢从A进入S，pop表示车厢从S进入B，每个操作占一行。&lt;/p&gt;

&lt;p&gt;若不可行，则输出No。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;Sample Input 1 

5 2
1 2 3 5 4
Sample Output 1

push
pop
push
pop
push
pop
push
push
pop
pop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码&#34;&gt;代码&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
using namespace std;

int main(){
    int n, m;
    int B[10000];   //B队列
    bool step[20005];   //记录操作 0压入 1弹出
    bool flag = false;  //标记是否出现错误
    cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
    stack&amp;lt;int&amp;gt; s;   //代表中转端
    
    for(int i = 0; i &amp;lt; n; i++){
        cin &amp;gt;&amp;gt; B[i];
    }

    int i = 1, j = 0, k = 0;  //当前数字i 操作步骤标记j B队列索引k
    while(i &amp;lt;= n){
        if(s.empty()){
            s.push(i++);
            step[j++] = 0;
        }
        else{
            if(s.top() == B[k]){
                s.pop();
                step[j++] = 1;
                k++;
            }
            else{
                s.push(i++);
                step[j++] = 0;
                if(s.size() &amp;gt; m){
                    flag = 1;
                    break;
                }
            }
        }
    }

    //剩余元素的弹出讨论
    while(!s.empty()){
        if(s.top() != B[k]){
            flag = 1;
            break;
        }
        else{
            s.pop();
            step[j++] = 1;
            k++;
        }
    }

    if(flag)
        cout &amp;lt;&amp;lt; &amp;quot;no&amp;quot;;
    else{
        for(int l = 0; l &amp;lt; j; l++){
            if(step[l])
                cout &amp;lt;&amp;lt; &amp;quot;pop&amp;quot;;
            else
                cout &amp;lt;&amp;lt; &amp;quot;push&amp;quot;;
            cout &amp;lt;&amp;lt; endl;
        }
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb39a396b3.png&#34; alt=&#34;测试&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业二 List ADT</title>
      <link>https://wanakiki.github.io/2019/list-adt/</link>
      <pubDate>Sat, 20 Apr 2019 20:22:40 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/list-adt/</guid>
      <description>

&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;

&lt;p&gt;题目要求自行实现list ADT，并在此基础上实现PrintLots函数并且实现懒惰删除功能。对于PrintLots函数，题目要求分析运行时间；对于懒惰删除功能，除编写实现外，题目还要求列出懒惰删除的优点和缺点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PrintLots(L,P)&lt;/strong&gt;：有两个链表L和P, 他们包含以升序排列的整数，操作PrintLots(L,P)将打印L中那些由P所指定位置上的元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;懒惰删除（lazy deletion）&lt;/strong&gt;：为了删除一个元素，我们只标记上该元素被删除。表中被删除和非被删除元素的个数作为数据结构的一部分被保留。如果被删除元素和非被删除元素一样多，我们遍历整个表，对所有被标记的节点执行标准的删除算法。&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;设计list ADT，准备好PrintLots函数所需要的接口。主文件引用自己编写的list ADT，并在主文件中完成对PrintLots函数的实现，懒惰删除则可以直接封装在ADT中。由于本次实验缺乏示例输入输出，因此还要对输入输出部分稍微加以设计，在此不多赘述。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;list ADT的实现大体可以按照课本所给的框架来初步构建，之后对其进行丰富，首先实现节点类，再进一步实现List类。考虑到懒惰删除的需要，在实现节点类的时候我在其中加入了是否删除的标志，实现List类时增加了用于统计伪删除元素个数的变量。为了更进一步贴合标准模板库的操作，相对多此一举地加入了迭代器子类。（实践证明，我对迭代器相关知识的了解并不充分&amp;hellip;😕）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb39389ad9.jpg&#34; alt=&#34;结构示意&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;printlots函数&#34;&gt;PrintLots函数&lt;/h3&gt;

&lt;p&gt;因为两个链表的元素都是升序排列的，所以L的迭代器可以一直向一个方向移动，整个函数的实现降低了一些难度。定义一个整形变量用来记录当前L的迭代器指向位置的编号，编号若与P的迭代器指向的元素相同则进行输出，同时两个迭代器向后移动。若编号与P当前元素不同，则指向L的迭代器向后移动。函数的终止条件为链表P遍历结束。&lt;/p&gt;

&lt;h4 id=&#34;复杂度分析&#34;&gt;复杂度分析&lt;/h4&gt;

&lt;p&gt;从整体上来看，PrintLots函数只是两个链表的单向遍历输出，只是细节方面稍微复杂，但引入的均为常数时间可以完成的操作。因为P的元素个数不可能超过L的元素个数，所以最坏情况便是输出了L的所有元素。时间复杂度为O(n)。&lt;/p&gt;

&lt;h3 id=&#34;懒惰删除&#34;&gt;懒惰删除&lt;/h3&gt;

&lt;p&gt;函数参数为指向要删除元素的迭代器，函数通过迭代器访问该元素内部的删除标志，并对其进行修改。修改之后检查当前伪删除元素的总数，大于总元素一般对整个链表进行遍历删除。总体实现相对简单。&lt;/p&gt;

&lt;h4 id=&#34;懒惰删除优缺点分析&#34;&gt;懒惰删除优缺点分析&lt;/h4&gt;

&lt;p&gt;优点：误删数据有恢复的空间，未被释放的空间可以进行二次利用，减少了资源消耗较大的删除过程的需求次数（链表中体现不明显）。
缺点：记录元素伪删除需要额外的操作和空间，被删除的节点不及时释放增加了空间的占用，也提高了部分操作所需的时间。&lt;/p&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb3959aa95.jpg&#34; alt=&#34;lazy deletion&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;p&gt;共编写了三个文件：listnode.h、my_list.h、main.cpp&lt;/p&gt;

&lt;p&gt;1.listnode.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;    #include&amp;lt;iostream&amp;gt;
    using namespace std;

    //定义列表的节点
    template &amp;lt;typename T&amp;gt; struct ListNode
    {
        T data;
        ListNode&amp;lt;T&amp;gt;* pred;
        ListNode&amp;lt;T&amp;gt;* succ;
        bool need_remove;   //need_remove为了方便懒惰消除

        ListNode() : need_remove(false) {}
        ListNode(T e, ListNode&amp;lt;T&amp;gt;* p = NULL, ListNode&amp;lt;T&amp;gt;* s = NULL)
            : data(e), pred(p), succ(s), need_remove(false) {}

        ListNode&amp;lt;T&amp;gt;* insertAsPred(T const&amp;amp; e);
        ListNode&amp;lt;T&amp;gt;* insertAsSucc(T const&amp;amp; e);
    };

    //前插入
    template &amp;lt;typename T&amp;gt;
    ListNode&amp;lt;T&amp;gt;* ListNode&amp;lt;T&amp;gt;::insertAsPred(T const&amp;amp; e){
        ListNode&amp;lt;T&amp;gt;* x = new ListNode(e, pred, this);
        pred-&amp;gt;succ = x;
        pred = x;
        return x;
    }

    //后插入
    template &amp;lt;typename T&amp;gt;
    ListNode&amp;lt;T&amp;gt;* ListNode&amp;lt;T&amp;gt;::insertAsSucc(T const&amp;amp; e){
        ListNode&amp;lt;T&amp;gt;* x = new ListNode(e, this, succ);
        succ-&amp;gt;pred = x;
        succ = x;
        return x;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.my_list.h&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;listnode.h&amp;quot;

template &amp;lt;typename T&amp;gt;
class List
{
  private:
    int _size;
    int _num;
    ListNode&amp;lt;T&amp;gt; *header;
    ListNode&amp;lt;T&amp;gt; *trailer;

  protected:
    void init();
    void copyNodes(ListNode&amp;lt;T&amp;gt; *, int);
    //只写出了有可能用到的函数

  public:
    List() { init(); } //默认构造
    List(List&amp;lt;T&amp;gt; const &amp;amp;L);
    List(List&amp;lt;T&amp;gt; const &amp;amp;L, int r, int n);
    List(ListNode&amp;lt;T&amp;gt; *p, int n);
    int clear();

    ~List(); //析构

    class Iterator{
      public:
        ListNode&amp;lt;T&amp;gt; *ptr;

        Iterator() : ptr(NULL) {}
        Iterator(ListNode&amp;lt;T&amp;gt; *tmp) : ptr(tmp) {}

        T operator*(){
            return ptr-&amp;gt;data;
            //为空时如何抛出错误？
        }

        bool operator==(Iterator const &amp;amp;x) { return ptr == x.ptr; }
        bool operator!=(Iterator const &amp;amp;x) { return ptr != x.ptr; }
        Iterator operator++(int){
            //不能在这里访问trailer，那么标准的迭代器是怎么操作的呢
            Iterator tmp(ptr);
            while(1){
                if(ptr-&amp;gt;succ != NULL)
                    ptr = ptr-&amp;gt;succ;
                if(!ptr-&amp;gt;need_remove)   //不需要继续访问，跳出循环
                    break;
            }
            return tmp;
        }
        Iterator operator--(int){
            Iterator tmp(ptr);
            while(1){
                if (ptr-&amp;gt;pred != NULL)
                    ptr = ptr-&amp;gt;pred;
                if(!ptr-&amp;gt;need_remove)
                    break;
            }
            return tmp;
        }
        Iterator&amp;amp; operator++(){
            while(1){
                if(ptr-&amp;gt;succ != NULL)
                    ptr = ptr-&amp;gt;succ;
                if(!ptr-&amp;gt;need_remove)   //不需要继续访问，跳出循环
                    break;
            }
            return *this;
        }
        Iterator&amp;amp; operator--(){
            while(1){
                if (ptr-&amp;gt;pred != NULL)
                    ptr = ptr-&amp;gt;pred;
                if(!ptr-&amp;gt;need_remove)
                    break;
            }
            return *this;
        }
    };

    bool empty() const { return _size &amp;lt;= 0; }
    int size() const { return _size-_num; }
    ListNode&amp;lt;T&amp;gt; *insertAsFirst(T const &amp;amp;e);
    ListNode&amp;lt;T&amp;gt; *insertAsLast(T const &amp;amp;e);
    Iterator begin() { return ++Iterator(header); }
    Iterator end() { return Iterator(trailer); }
    ListNode&amp;lt;T&amp;gt; *first() const { return header-&amp;gt;succ; } //first和begin完全没必要
    ListNode&amp;lt;T&amp;gt; *last() const { return trailer-&amp;gt;pred; }
    T remove(ListNode&amp;lt;T&amp;gt; *p);
    void lazy_deletion(Iterator i);
    void show();
    void Advance(Iterator &amp;amp;i, int n);
};

template &amp;lt;typename T&amp;gt; //列表初始化
void List&amp;lt;T&amp;gt;::init()
{
    header = new ListNode&amp;lt;T&amp;gt;;
    trailer = new ListNode&amp;lt;T&amp;gt;;
    header-&amp;gt;succ = trailer;
    header-&amp;gt;pred = NULL;
    trailer-&amp;gt;pred = header;
    trailer-&amp;gt;succ = NULL;
    _size = 0;
    _num = 0;
}

//复制自p开始的n项
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::copyNodes(ListNode&amp;lt;T&amp;gt; *p, int n)
{
    init();
    while (n--)
    {
        insertASLast(p-&amp;gt;data);
        p = p-&amp;gt;succ;
    }
}

//Clear()
template &amp;lt;typename T&amp;gt;
int List&amp;lt;T&amp;gt;::clear()
{
    int num = _size;
    if (_size)
    {
        ListNode&amp;lt;T&amp;gt; *p = header-&amp;gt;succ;
        ListNode&amp;lt;T&amp;gt; *tmp;
        while (p != trailer)
        {
            tmp = p-&amp;gt;succ;
            delete p;
            p = tmp;
        }
    }
    _size = 0;
    _num = 0;
    return num;
}

//构造函数
template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(List&amp;lt;T&amp;gt; const &amp;amp;L) { copyNodes(L.first(), L.size()); }

template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(List&amp;lt;T&amp;gt; const &amp;amp;L, int r, int n)
{
    ListNode&amp;lt;T&amp;gt; *tmp = L.first();
    while (--r)
        tmp = tmp-&amp;gt;succ;
    copyNodes(tmp, n);
}

template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::List(ListNode&amp;lt;T&amp;gt; *p, int n) { copyNodes(p, n); }

//析构函数
template &amp;lt;typename T&amp;gt;
List&amp;lt;T&amp;gt;::~List()
{
    clear();
    delete trailer;
    delete header;
}

template &amp;lt;typename T&amp;gt;
ListNode&amp;lt;T&amp;gt; *List&amp;lt;T&amp;gt;::insertAsFirst(T const &amp;amp;e)
{
    _size++;
    return header-&amp;gt;insertAsSucc(e);
}

template &amp;lt;typename T&amp;gt;
ListNode&amp;lt;T&amp;gt; *List&amp;lt;T&amp;gt;::insertAsLast(T const &amp;amp;e)
{
    _size++;
    return trailer-&amp;gt;insertAsPred(e);
}

//删除
template &amp;lt;typename T&amp;gt;
T List&amp;lt;T&amp;gt;::remove(ListNode&amp;lt;T&amp;gt; *p)
{
    T tmp= p-&amp;gt;data;
    _size--;
    p-&amp;gt;pred-&amp;gt;succ = p-&amp;gt;succ;
    p-&amp;gt;succ-&amp;gt;pred = p-&amp;gt;pred;
    delete p;
    return tmp;
}

template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::lazy_deletion(Iterator i){
    _num++;
    ListNode&amp;lt;T&amp;gt;* tmp = i.ptr;
    tmp-&amp;gt;need_remove = true;

    //数量大于一半开始全部删除
    if(_num &amp;gt;= _size/2){
        _num = 0;
        ListNode&amp;lt;T&amp;gt; *p = header-&amp;gt;succ;
        while(trailer != p){
            if(!p-&amp;gt;need_remove){
                p = p-&amp;gt;succ;
                continue;
            }
                
            tmp = p-&amp;gt;succ;
            remove(p);
            p = tmp;       
        }
    }
    return ;
}

//输出格式化
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::show(){
    if(_size == 0){
        cout &amp;lt;&amp;lt; &amp;quot;None&amp;quot; &amp;lt;&amp;lt; endl;
        return ;
    }
    ListNode&amp;lt;T&amp;gt;* p = header;
    while(trailer != (p = p-&amp;gt;succ)){
        if(p == header-&amp;gt;succ){
            cout &amp;lt;&amp;lt; p-&amp;gt;data;
            continue;
        }
        if(p-&amp;gt;pred-&amp;gt;need_remove &amp;amp;&amp;amp; p-&amp;gt;need_remove)    cout &amp;lt;&amp;lt; &amp;quot;____&amp;quot;;
        else if(p-&amp;gt;need_remove)     cout &amp;lt;&amp;lt; &amp;quot;--__&amp;quot;;
        else if(p-&amp;gt;pred-&amp;gt;need_remove)   cout &amp;lt;&amp;lt; &amp;quot;__-&amp;gt;&amp;quot;;
        else    cout &amp;lt;&amp;lt; &amp;quot;---&amp;gt;&amp;quot;;
        cout &amp;lt;&amp;lt; p-&amp;gt;data;
    }
    return ;
}

//用于迭代器的移动
template &amp;lt;typename T&amp;gt;
void List&amp;lt;T&amp;gt;::Advance(Iterator &amp;amp; i, int n){
    if(n &amp;gt;= 0){
        while(n--)
            i.ptr = i.ptr-&amp;gt;succ;
    }
    else{
        while(n++)
            i.ptr = i.ptr-&amp;gt;pred;
    }
}
//如果向容器里面放个pair？
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.main.cpp&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;quot;my_list.h&amp;quot;


void PrintLots(List&amp;lt;int&amp;gt;&amp;amp; L, List&amp;lt;int&amp;gt;&amp;amp; P){
    int current = 1;

    //是否存在空序列
    if(L.empty() || P.empty())  {   cout&amp;lt;&amp;lt;&amp;quot;Error, input is empty&amp;quot;&amp;lt;&amp;lt;endl; return ;}

    List&amp;lt;int&amp;gt;::Iterator l = L.begin();
    List&amp;lt;int&amp;gt;::Iterator p = P.begin();
    while(1){
        if(L.size() &amp;lt; *p){  
            cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;quot;Error, the number of P is bigger than the size of L&amp;quot; &amp;lt;&amp;lt; endl;  
            break;
        }

        if(current++ == *p){
            cout &amp;lt;&amp;lt; *l &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
            p++;
        }

        //输出结束
        if(p == P.end()){  
                cout &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; &amp;quot;Finished!&amp;quot; &amp;lt;&amp;lt; endl;
                break;
        }
        l++;
    }
    return ;
}

int main(){
    int m, n, tmp, last;
    int select = 0;
    while(1){
        cout &amp;lt;&amp;lt; &amp;quot;Choose function(0 means lazy_deletion, 1 means PrintLots):&amp;quot;;
        cin &amp;gt;&amp;gt; select;
        if(select){
            List&amp;lt;int&amp;gt; L, P;
            cout &amp;lt;&amp;lt; &amp;quot;Input the size of L and P: &amp;quot;;
            cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; n;
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of L: &amp;quot; &amp;lt;&amp;lt; endl;
            while (m--){
                cin &amp;gt;&amp;gt; tmp;
                L.insertAsLast(tmp);
            }
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of P: &amp;quot; &amp;lt;&amp;lt; endl;
            while (n--){
                cin &amp;gt;&amp;gt; tmp;
                P.insertAsLast(tmp);
            }
            PrintLots(L, P);
        }
        else{
            List&amp;lt;int&amp;gt; L;
            cout &amp;lt;&amp;lt; &amp;quot;Input the size of L: &amp;quot;;
            cin &amp;gt;&amp;gt; m;
            cout &amp;lt;&amp;lt; &amp;quot;Input the elements of L:&amp;quot; &amp;lt;&amp;lt; endl;
            for(int j = 0; j &amp;lt; m; j++){
                cin &amp;gt;&amp;gt; tmp;
                L.insertAsLast(tmp);
            }
            cout &amp;lt;&amp;lt; &amp;quot;L is: &amp;quot;;
            L.show();
            cout&amp;lt;&amp;lt;endl;


            List&amp;lt;int&amp;gt;::Iterator i = L.begin();
            last = 1;
            cout &amp;lt;&amp;lt; &amp;quot;How many elements do you want to delete? &amp;quot;;
            cin &amp;gt;&amp;gt; n;
            cout &amp;lt;&amp;lt; &amp;quot;Input them(from 1 to &amp;quot; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &amp;quot;)&amp;quot; &amp;lt;&amp;lt; endl;
            while(n--){
                cin &amp;gt;&amp;gt; tmp;
                L.Advance(i, tmp-last);
                last = tmp;
                L.lazy_deletion(i);
            }
            cout &amp;lt;&amp;lt; &amp;quot;Now L is: &amp;quot;;
            L.show();
            cout &amp;lt;&amp;lt; endl;
        } 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;p&gt;PrintLots进行了四组测试，从测试结果可以看出对错误情况进行了有效的判断，并且能够处理一般情况。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb396983b0.jpg&#34; alt=&#34;PrintLots测试&#34; /&gt;&lt;/p&gt;

&lt;p&gt;为了方便懒惰删除的查看，设置了一个函数用来表现链表当前的情况，同时进行了三种样例的测试，能够代表所有类型的满足要求的输入情况。可以很容易的看出当删除元素过半时按要求完成了操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb3979a5b2.jpg&#34; alt=&#34;懒惰删除测试&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;深刻感觉到自己的宏观思维有极大的欠缺，自己设计出的类中的函数不能很好地衔接，编程思维有问题。&lt;/li&gt;
&lt;li&gt;自己写的迭代器可能称不上是迭代器，只是稍微包装了一下指针。自己测试的时候发现在iterator已经被定义，意识到平时所用的迭代器并不是定义在容器的头文件中。&lt;/li&gt;
&lt;li&gt;边界等特殊情况没有得到很好的处理，不过能够保证在输入规范的情况下得到良好的结果，代码总体有待完善。（总之还是对标准模板库特殊情况处理方式不够了解📌&lt;/li&gt;
&lt;li&gt;很多用不到的东西也进行了实现，导致代码量相对较大😓&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>数据结构作业一 Zuma List</title>
      <link>https://wanakiki.github.io/2019/zuma-list/</link>
      <pubDate>Sat, 20 Apr 2019 19:41:55 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/zuma-list/</guid>
      <description>

&lt;p&gt;数据结构第一次作业。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;

&lt;p&gt;题目要求书写程序对祖玛消除过程进行回放，输入为原始珠子序列以及玩家所做的一系列操作，要求我们按照游戏规则计算出每次操作后的珠子序列并进行输出。&lt;/p&gt;

&lt;p&gt;祖玛游戏规则：有三个或更多同色珠子变成相邻就会立即消失，并且可能会发生连锁反应。&lt;strong&gt;需要注意，原始情况中出现的三个或更多相邻同色珠子，在没有新珠子或者连锁反应影响时是不会消除的。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;将新的珠子插入到原有序列，在插入位置向两侧判断同色珠子个数，满足条件则进行删除。考虑到删除后的连锁反应，需要将判断的过程循环执行到无法继续删除。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;考虑到整个过程需要多次插入删除的操作，并且查找过程只需要从插入的具体位置向两侧进行判断，所以使用list对珠子序列进行存储。&lt;/p&gt;

&lt;p&gt;插入过程只需要简单的insert函数与advance函数相配合就可以了，使用advance函数使迭代器指到插入位置，之后再用insert函数进行插入。&lt;/p&gt;

&lt;p&gt;比较难的地方在于是否消除的判断上，考虑到迭代器的特殊性，为了避免不必要的麻烦，当list中的元素少于三个的时候直接不进行判断。对三个以上的元素判断时，需要从插入元素的位置向两侧查找相同颜色，可以用&lt;code&gt;end()&lt;/code&gt;和&lt;code&gt;begin()&lt;/code&gt;来判断是否到达了查找的两端，当然，如果在查找过程中就发现了不同的珠子就可以直接停止查找过程。查找结束之后直接对查找到的区间进行删除，同时保留左开右闭区间的右端点作为下次查找过程的起始位置。&lt;/p&gt;

&lt;p&gt;数据的输入和结果输出过程按照题目的要求进行编写即可。&lt;/p&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb38e8cb30.jpg&#34; alt=&#34;流程图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

void bang(list&amp;lt;char&amp;gt; &amp;amp; beads, int id, char bead){
    list&amp;lt;char&amp;gt;::iterator i, r, l;
    int num = 0;    /*计数*/
    i = beads.begin();
    advance(i, id);
    beads.insert(i, bead);  /*插入元素*/

    /*考虑到多次消除的可能，使用while循环进行消除*/
    while(1){
        if(beads.size() &amp;lt; 3)
            break;
        
        num = 0;
        r = i--;    
        /*这步操作之后r指向被插入元素以后，i指向被插入元素*/
        
        for(; r != beads.end(); r++){
            if(*r == *i)    num ++;
            else    break;
        }           /*向右判断*/

        l = i;          
        /*if(i != beads.begin()){
            l--;
            while (1){
                if(*l != *i){   l++;break;} //l需要加加
                else    num ++;
                
                if(l == beads.begin())  break;
                else    l--;    
            }
        }   //向左判断*/

        /*由流程图发现的简化方法*/
        while(l != beads.begin()){
            l--;
            if(*l != *i){   l++; break;}
            else    num++;
        }


        /*删除部分*/
        if(num &amp;gt; 1){
            beads.erase(l, r);
            i = r;
        }
        else
            break;
    }


    /*输出*/
    if(beads.empty())
        cout &amp;lt;&amp;lt; &#39;-&#39; &amp;lt;&amp;lt; endl;
    else{
        for(i = beads.begin(); i != beads.end(); i++)
            cout &amp;lt;&amp;lt; *i;
        cout &amp;lt;&amp;lt; endl;
    }
    return ;
}
int main(){
    int n, id;
    char bead;
    string initial_beads;
    list&amp;lt;char&amp;gt; beads;

    getline(cin, initial_beads);
    for(int i = 0; i &amp;lt; initial_beads.size(); i++){
        beads.push_back(initial_beads[i]);
    }
    /*构造初始状态*/

    cin &amp;gt;&amp;gt; n;
    while(n--){
        cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; bead;
        bang(beads, id, bead);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb38f267db.jpg&#34; alt=&#34;测试1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://i.loli.net/2019/05/03/5ccbb39060e21.jpg&#34; alt=&#34;测试2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上，经过测试，程序完成要求，并且能够处理初始序列为空的情况。👍&lt;/p&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;增加了对erase函数的了解：

&lt;ol&gt;
&lt;li&gt;当参数只有一个的时候，原迭代器指向的位置被删除，迭代器无效化，不能对其继续进行操作，否则会造成错误，但函数会返回原位置之后的迭代器，所以可以利用这个特性进行区间删除（省略++步骤）。&lt;/li&gt;
&lt;li&gt;当有两个参数的时候，函数结束之后前一个迭代器会无效化，而后一个迭代器因为删除区间为左闭右开的特点，其指向的位置不会被删除。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;迭代器是一个很玄学的东西，使用不规范很容易带来错误，查错的时候可以优先考虑。&lt;/li&gt;
&lt;li&gt;流程图可以帮忙理清逻辑结构！！！😀&lt;/li&gt;
&lt;li&gt;写程序尽量一次性写完&amp;hellip;&amp;hellip;🤧&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>