<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wanakiki`s Blog on Wanakiki`s Blog</title>
    <link>https://wanakiki.github.io/</link>
    <description>Recent content in Wanakiki`s Blog on Wanakiki`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 01 Jul 2020 12:17:49 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>IIC总线协议</title>
      <link>https://wanakiki.github.io/2020/about-iic/</link>
      <pubDate>Wed, 01 Jul 2020 12:17:49 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2020/about-iic/</guid>
      <description>

&lt;p&gt;之前做收音机的时候用到了IIC总线协议，因为用的是别人封装好的库，对协议的具体执行方式不是很了解，于是花了点时间查了一下。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;IIC协议大致有下面几个特点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;双向串行通信&lt;/li&gt;
&lt;li&gt;两根线：数据线SDA，时钟线SCL，且支持挂载多个设备&lt;/li&gt;
&lt;li&gt;传递四种信号：起始信号、8bit数据、响应信号、结束信号&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;起始信号&lt;/strong&gt;：SCL时钟线保持高电平，SDA数据信号由高变低便代表开始信号。当总线上的设备检测到这个开始信号后便知道即将发送数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;停止信号&lt;/strong&gt;：SCL时钟线保持高电平，SDA数据信号由低变高便代表停止信号。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8bit数据与响应信号&lt;/strong&gt;：发送数据时，接收方在SCL为高电平时读取SDA数据，因此SCL时钟线变为低电平时SDA数据才能发生变化。输出到SDA上的数据一组有八位，传输组数不受限制，但每发送八位后需要接收来自接收方的确认信号才能继续发送下一组数据。数据从高位传输。&lt;/p&gt;

&lt;h4 id=&#34;在多设备的情况下-一次通信过程可以如下描述&#34;&gt;在多设备的情况下，一次通信过程可以如下描述：&lt;/h4&gt;

&lt;p&gt;发送方发出起始信号、发送方发送目标设备地址、发送方接收目标设备响应、发送方传输第一组数据、发送方接收目标设备响应、发送方传输第二组数据、发送方接收目标设备响应&amp;hellip;&amp;hellip;发送方发出停止信号&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Linux C语言系统编程作业</title>
      <link>https://wanakiki.github.io/2020/linux-c/</link>
      <pubDate>Sat, 06 Jun 2020 23:06:09 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2020/linux-c/</guid>
      <description>

&lt;p&gt;跟着别人简单学了下Linux下的系统编程，把做过的几个作业简单记录一下。作业的内容都是针对的具体的知识点，实现难度并不高。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;进程间通信&#34;&gt;进程间通信&lt;/h2&gt;

&lt;p&gt;设计一个程序，打开一个匿名管道，然后生成一个子进程，主进程向管道中写入信息“Hello XXX”,子进程从管道中读取数据，将读取到的信息在屏幕上显示。&lt;/p&gt;

&lt;p&gt;主要考察&lt;code&gt;fork&lt;/code&gt;、&lt;code&gt;pipe&lt;/code&gt;两个函数的使用，实现代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;stdlib.h&amp;gt;
#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;unistd.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/wait.h&amp;gt;

#define STRING &amp;quot;Hello wanakiki&amp;quot;
int main(){
    int pipefd[2];
    pid_t pid;
    char buf[BUFSIZ];

    if(pipe(pipefd) == -1){
        perror(&amp;quot;pipe()&amp;quot;);
        exit(1);
    }

    pid = fork();
    if(pid == -1){
        perror(&amp;quot;fork()&amp;quot;);
        exit(1);
    }

    if(pid == 0){
        // 子进程
        printf(&amp;quot;Child pid is: %d\n&amp;quot;, getpid());
        
        if(read(pipefd[0], buf, BUFSIZ) &amp;lt; 0){
            perror(&amp;quot;write()&amp;quot;);
            exit(1);
        }
        
        printf(&amp;quot;%s\n&amp;quot;, buf);
    }
    else{
        // 父进程
        printf(&amp;quot;Parent pid is: %d\n&amp;quot;, getpid());

        if (write(pipefd[1], STRING, strlen(STRING) + 1) &amp;lt; 0)
        {
            perror(&amp;quot;write()&amp;quot;);
            exit(1);
        }
        wait(NULL);
    }

    exit(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;多进程&#34;&gt;多进程&lt;/h2&gt;

&lt;p&gt;设计一个程序，运行后显示“开始计算”后，生成两个子进程。在主进程计算1+3+5+7+…+99的值，并将结果显示出来；在第一个子进程计算2+4+6+…+100的值，并将结果显示出来；第二个子进程中计算1+2+3+4+…+100的值，并将结果显示。&lt;/p&gt;

&lt;p&gt;当需要创建的子进程数较少时，可以手动书写代码创建进程，在生成一个进程之后的父进程代码中再次调用&lt;code&gt;fork&lt;/code&gt;生成进程。但是当需要创建的子进程较多时此种方法实现起来较为麻烦，可以用循环方式生成。本实验我采用了手动创建的方案，循环创建子进程的代码可以在最后综合实验中找到。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;sys/types.h&amp;gt;
#include&amp;lt;unistd.h&amp;gt;

int main(){
    int p1, p2;
    int res;    // 保存计算结果
    int num = 0;
    while((p1 = fork()) == -1);     // 创建子进程

    if(p1 == 0){
        res = 0;
        for(int i = 2; i &amp;lt; 101; i++){
            res += i;
        }
        printf(&amp;quot;第一个子进程计算结果 %d\n&amp;quot;, res);
        printf(&amp;quot;第一个子进程%d&amp;quot;, ++num);
    }
    else{
        while((p2 = fork()) == -1);     // 创建子进程

        if(p2 == 0){
            res = 0;
            for(int i = 1; i &amp;lt; 101; i++){
                res += i;
            }
            printf(&amp;quot;第二个子进程计算结果 %d\n&amp;quot;, res);
            printf(&amp;quot;第二个子进程%d&amp;quot;, ++num);
        }
        else{
            res = 0;
            for(int i = 0; i &amp;lt; 100; i++){
                res += i;
            }
            printf(&amp;quot;主进程计算结果 %d\n&amp;quot;, res);
            printf(&amp;quot;第三个子进程%d&amp;quot;, ++num);
        }
    }
    printf(&amp;quot;end&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;信号&#34;&gt;信号&lt;/h2&gt;

&lt;p&gt;编写一个程序，接受发送给自己的信号（30和31），收到信号后显示信号的内容。没收到信号时循环显示提示信息。&lt;/p&gt;

&lt;p&gt;程序给自己发送信号可以通过调用&lt;code&gt;raise&lt;/code&gt;函数实现，在代码当中为了方便观察到发送信号的情况，对题目要求的两个信号的处理方法进行了设置。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;signal.h&amp;gt;
#include&amp;lt;unistd.h&amp;gt;

void show_sig(int sig){
    printf(&amp;quot;Get a signal: %d\n&amp;quot;, sig);
}

int main(){
    signal(SIGPWR, show_sig);   // 设置信号处理方法
    signal(SIGSYS, show_sig);

    for(int i = 0; i &amp;lt; 8; i++){
        printf(&amp;quot;系统将会在3秒和5秒发送30 31信号，当前时间为: %d\n&amp;quot;, i);
        if(i == 3){
            raise(30);
        }
        if(i == 5){
            raise(31);
        }
        sleep(1);
    }
    return 0;
}

// https://blog.csdn.net/thanksgining/article/details/41824475
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;综合作业&#34;&gt;综合作业&lt;/h2&gt;

&lt;p&gt;有一个文件夹，下面有许多个C语言源程序。要求编写一个程序，统计所有C语言源程序中，下列系统函数的被调用次数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;printf  open  close  read  write  fork  signal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;统计结果输出到myresult.txt文件按中，格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;printf  49
open    13
close   13
read    24
write   16
fork     8
signal   0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;建议（非强制，遵守下列建议会得到一个较好分数）：
1. 对每个.c文件，生成一个子进程（或者启动一个线程）统计，统计结果存入合适的文本文件中，最后再汇总结果
2. 对每个函数，生成一个子进程（或者启动一个线程）统计，统计结果存入合适的文本文件中，最后再汇总结果。
3. 访问文件使用Linux系统IO，如open, close, read, write。
4. 编写出合适的makefile
5. 可以生成多个可执行文件，通过一个主文件启动工作。
6. 可以带Shell脚本&lt;/p&gt;

&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;

&lt;p&gt;程序的整体逻辑还是比较清楚的，读取文件夹内所有c文件，然后统计函数的调用次数，最后汇总到一个文件当中。如果不考虑多进程的话，实现起来并不复杂，但是题目要求使用多进程的方案，所以统计方式需要一定的变化。&lt;/p&gt;

&lt;p&gt;我最开始的实现思路是对于每个C文件创建一个子进程来统计各个函数的使用次数，但实现的时候发现这样统计数据的保存不是很方便。如果每个文件都生成一个结果文件，当源文件数目较多时，生成的结果文件也会变得很多，汇总起来比较麻烦。如果是把每个文件的统计结果保存到一个文件当中，由于各个进程的执行时间不同，最后保存时还要进行额外的处理。&lt;/p&gt;

&lt;p&gt;考虑到这些，我选择了一个比较简单的方案，对每个函数创建一个子进程，统计当前目录下所有源文件中该函数的调用次数，最后保存到结果文档当中，在程序结束之后用shell脚本对统计结果进行合并。&lt;/p&gt;

&lt;p&gt;C程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;#include &amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
#include &amp;lt;sys/types.h&amp;gt;
#include &amp;lt;sys/stat.h&amp;gt;
#include &amp;lt;fcntl.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;dirent.h&amp;gt; // 文件目录
#include &amp;lt;string.h&amp;gt;

/*struct dirent
{
   long d_ino; // inode number 索引节点号
   off_t d_off; // offset to this dirent 在目录文件中的偏移
   unsigned short d_reclen; // length of this d_name 文件名长
   unsigned char d_type; // the type of d_name 文件类型
   char d_name [NAME_MAX+1]; // file name (null-terminated) 文件名，最长255字符
}
其中d_type表明该文件的类型：文件(8)、目录(4)、链接文件(10)等
*/

// 文件操作相关 https://blog.csdn.net/u014650722/article/details/51563679
char *aims[] = {&amp;quot;printf&amp;quot;, &amp;quot;open&amp;quot;, &amp;quot;close&amp;quot;, &amp;quot;read&amp;quot;, &amp;quot;write&amp;quot;, &amp;quot;fork&amp;quot;, &amp;quot;signal&amp;quot;};


int helper(char *filename, int id)
{
    int fd = open(filename, O_RDONLY); // 只读模式打开文件
    char buf[1024];
    int count = 0;
    while (read(fd, buf, 1024))
    {
        // strstr函数判断是否为子串
        char * tmp = strstr(buf, aims[id]);
        while(tmp != NULL)
        {
            count++;
            tmp += strlen(aims[id]);    //找到后必须移动，不然死循环
            tmp = strstr(tmp, aims[id]);
        }
    }
    close(fd);
    return count;
}

void savefile(int id, int count){
    // 保存结果
    char buf[1024];
    char *savename = (char *)malloc(strlen(aims[id]) + 4);
    sprintf(savename, &amp;quot;%s.txt&amp;quot;, aims[id]);

    int fd = open(savename, O_CREAT | O_RDWR, S_IWUSR);
    int len = sprintf(buf, &amp;quot;%s %d\n&amp;quot;, aims[id], count);
    write(fd, buf, len);
    close(fd);
}

int main()
{
    int i = 0;
    int p = 0;
    for(i = 0; i &amp;lt; 7; i++){
        p = fork();
        if(p == 0){
            break;
        }
    }

    if (p == 0)
    {
       
        // 获取目录下所有.c文件
        DIR *directory_pointer;
        struct dirent *entry;

        if ((directory_pointer = opendir(&amp;quot;.&amp;quot;)) == NULL)
        {
            printf(&amp;quot;Error open\n&amp;quot;);
            return 0;
        }
        else
        {
            int count = 0;
            while ((entry = readdir(directory_pointer)) != NULL)
            {
                int len = strlen(entry-&amp;gt;d_name);
                if (entry-&amp;gt;d_name[len - 1] == &#39;c&#39; &amp;amp;&amp;amp; entry-&amp;gt;d_name[len - 2] == &#39;.&#39;)
                {
                    count += helper(entry-&amp;gt;d_name, i);
                }
            }
            savefile(i, count);
        }
    }
    else
    {
        return  0;   //主进程不做处理
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;shell脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash

funname=(&amp;quot;printf&amp;quot; &amp;quot;open&amp;quot; &amp;quot;close&amp;quot; &amp;quot;read&amp;quot; &amp;quot;write&amp;quot; &amp;quot;fork&amp;quot; &amp;quot;signal&amp;quot;)

gcc final.c -o final    # c文件名为final.c
./final
rm final    # 运行结束后删除

rm res.txt  # 删除原有结果文本

for fun in ${funname[@]}
do
    cat $fun.txt &amp;gt;&amp;gt; res.txt
    rm $fun.txt
done
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Flask&#43;MongoDB CURD微实战</title>
      <link>https://wanakiki.github.io/2020/mongodb-demo/</link>
      <pubDate>Sat, 30 May 2020 11:07:16 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2020/mongodb-demo/</guid>
      <description>

&lt;p&gt;做SRDP的过程中发现关系型数据库在实现问卷效果时比较困难，所以找了个时间熟悉了一下非关系型数据库，做了一个todo小demo。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1654y1D7jN/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;视频演示地址&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;过程记录&#34;&gt;过程记录&lt;/h2&gt;

&lt;p&gt;下载安装&lt;a href=&#34;https://www.mongodb.com/download-center/community&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;mongodb&lt;/a&gt;，注意安装的时候不要勾选compass，我勾选之后直接卡住了。&lt;/p&gt;

&lt;p&gt;安装Flask相关扩展：&lt;code&gt;pip install Flask-PyMongo&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Flask-PyMongo&lt;/code&gt;是在&lt;code&gt;PyMongo&lt;/code&gt;基础上进行的封装，令其满足扩展的习惯性使用方式，具体操作需要查看&lt;code&gt;PyMongo&lt;/code&gt;中的相关内容。两个扩展的文档：&lt;a href=&#34;http://www.pythondoc.com/flask-pymongo/index.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Flask-PyMongo&lt;/a&gt;、&lt;a href=&#34;https://pymongo.readthedocs.io/en/stable/tutorial.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;PyMongo&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;过程中参考的两个博客：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.bjhee.com/flask-ext5.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.bjhee.com/flask-ext5.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://towait.com/blog/flask-mongodb-crud/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://towait.com/blog/flask-mongodb-crud/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;过程中需要注意mongodb使用$配合其它关键字实现不同更新数据方式的方法。实现代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from flask import Flask, render_template, abort, redirect, url_for, request
from flask_bootstrap import Bootstrap
from flask_pymongo import PyMongo
from flask_wtf import FlaskForm
from wtforms import StringField, SubmitField
from wtforms.validators import DataRequired
from bson.objectid import ObjectId

from time import time

app = Flask(__name__)
# app配置

app.config[&#39;MONGO_DBNAME&#39;] = &#39;flask&#39;  # 数据库名
app.config[&#39;MONGO_URI&#39;] = &#39;mongodb://localhost:27017/flask&#39;
# 暂时不涉及用户名与密码
app.config[&#39;SECRET_KEY&#39;] = &#39;balabala&#39;  # wtf

mongo = PyMongo(app)
bootstrap = Bootstrap(app)


# 表单
class ContentForm(FlaskForm):
    content = StringField(&#39;Content&#39;, validators=[DataRequired()])
    submit = SubmitField(&#39;提交&#39;)

class DeleteForm(FlaskForm):
    submit = SubmitField(&#39;Delete&#39;)

class FinishForm(FlaskForm):
    submit = SubmitField(&#39;Finish&#39;)


# 数据模型
def create(content: str):
    body = {
        &#39;content&#39;: content,
        &#39;time&#39;: time(),
        &#39;finished&#39;: False,
        &#39;finished_time&#39;: None
    }
    return body


@app.route(&#39;/&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;])
def index():
    form = ContentForm()
    form_d = DeleteForm()
    form_f = FinishForm()
    if form.validate_on_submit():
        cur = create(form.content.data)     # 不需要要定义数据模型
        mongo.db.todos.insert_one(cur)
    res = mongo.db.todos.find()
    return render_template(&#39;index.html&#39;, records=res, form=form, form_d=form_d, form_f=form_f)


@app.route(&#39;/delete/&amp;lt;obj_id&amp;gt;&#39;, methods=[&#39;POST&#39;])
def delete_record(obj_id):
    form = DeleteForm()
    if form.validate_on_submit():
        mongo.db.todos.delete_one({&#39;_id&#39;: ObjectId(obj_id)})
    else:
        abort(400)
    return redirect(url_for(&#39;index&#39;))


@app.route(&#39;/finish/&amp;lt;obj_id&amp;gt;&#39;, methods=[&#39;POST&#39;])
def finish_record(obj_id):
    form = FinishForm()
    if form.validate_on_submit():
        print(&#39;dd&#39;)
        mongo.db.todos.update_one({&#39;_id&#39;: ObjectId(obj_id)}, {
            &#39;$set&#39;: {
                &#39;finished&#39;: True,
                &#39;finished_time&#39;: time()
            }
        })
    else:
        abort(400)
    return redirect(url_for(&#39;index&#39;))

@app.route(&#39;/search&#39;, methods=[&#39;GET&#39;])
def search_records():
    content = request.args.get(&#39;content&#39;, None)

    form = ContentForm()
    form_d = DeleteForm()
    form_f = FinishForm()
    if content is not None:
        res = mongo.db.todos.find(
            {&#39;content&#39;: {&amp;quot;$regex&amp;quot;: content}}
        )
    else:
        res = mongo.db.todos.find()
    return render_template(&#39;index.html&#39;, records=res, form=form, form_d=form_d, form_f=form_f)

if __name__ == &#39;__main__&#39;:
    app.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;页面模板文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{% extends &amp;quot;bootstrap/base.html&amp;quot; %}

{% block title %}To Do {% endblock %}

{% block content %}
    &amp;lt;h2&amp;gt;To Do List&amp;lt;/h2&amp;gt;
    &amp;lt;form method=&amp;quot;get&amp;quot; action=&amp;quot;{{ url_for(&#39;search_records&#39;, content=content) }}&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;content&amp;quot;&amp;gt; &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;搜索&amp;quot;&amp;gt;
    &amp;lt;/form&amp;gt;
    &amp;lt;br&amp;gt;
    &amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;{{ url_for(&#39;index&#39;)}}&amp;quot;&amp;gt;
    {{ form.csrf_token }}
    {{ form.content() }}
    {{ form.submit() }}
    &amp;lt;/form&amp;gt;
    &amp;lt;h3&amp;gt;记录列表&amp;lt;/h3&amp;gt;
    &amp;lt;ul&amp;gt;
    {% for record in records %}
    &amp;lt;li&amp;gt;
    &amp;lt;p&amp;gt;内容：{{ record[&#39;content&#39;] }}&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;创建时间：{{ record[&#39;time&#39;] }}&amp;lt;/p&amp;gt;
    {% if record[&#39;finished&#39;] %}
        &amp;lt;p&amp;gt;状态：Finished&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;完成时间 {{ record[&#39;finished_time&#39;] }}&amp;lt;/p&amp;gt;
    {% else %}
        &amp;lt;p&amp;gt;状态：Unfinished&amp;lt;/p&amp;gt;
    {% endif %}
    {% set p = record[&#39;_id&#39;]~&#39;&#39; %}
    &amp;lt;form method=&amp;quot;post&amp;quot; style=&amp;quot;float: left&amp;quot; action=&amp;quot;{{ url_for(&#39;delete_record&#39;, obj_id=p) }}&amp;quot;&amp;gt;
        {{ form_d.csrf_token }}
        {{ form_d.submit() }}
    &amp;lt;/form&amp;gt;
    &amp;lt;form method=&amp;quot;post&amp;quot; action=&amp;quot;{{ url_for(&#39;finish_record&#39;, obj_id=p) }}&amp;quot;&amp;gt;
        {{ form_f.csrf_token }}
        {{ form_f.submit() }}
    &amp;lt;/form&amp;gt;
    &amp;lt;/li&amp;gt;
    {% endfor %}
    &amp;lt;/ul&amp;gt;
{% endblock %}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>百度翻译爬虫</title>
      <link>https://wanakiki.github.io/2020/baidufanyi/</link>
      <pubDate>Mon, 18 May 2020 20:44:50 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2020/baidufanyi/</guid>
      <description>

&lt;p&gt;典型的js加密爬虫实战，本文章内容仅作学习交流。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;首先放一下参考文章：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/76239929&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;爬虫JS破解经典案例之百度翻译&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果没有这篇文章的话，我可能要花很多功夫才能找到具体的js代码位置。&lt;/p&gt;

&lt;h2 id=&#34;页面加载分析&#34;&gt;页面加载分析&lt;/h2&gt;

&lt;h3 id=&#34;初步探索&#34;&gt;初步探索&lt;/h3&gt;

&lt;p&gt;打开&lt;a href=&#34;https://fanyi.baidu.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;百度翻译&lt;/a&gt;，然后右键、检查、network，刷新页面即可看到网页的加载过程。具体的图示可以在之前的&lt;a href=&#34;../leetcode-spider&#34;&gt;leetcode爬虫&lt;/a&gt;中找到。&lt;/p&gt;

&lt;p&gt;在输入任意查询内容点击翻译后，在&lt;code&gt;XHR&lt;/code&gt;项中可以看到&lt;code&gt;langdetect&lt;/code&gt;、&lt;code&gt;v2transapi?form &amp;amp; to&lt;/code&gt;两个请求。检查内容不难发现，前者的作用是语言检查， 后者才是真正的翻译。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;from: en
to: zh
query: hello everyone
transtype: translang
simple_means_flag: 3
sign: 58244.262325
token: 440bdb196410660e636b3223ebb83a94
domain: common
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面是我以&amp;rdquo;hello everyone&amp;rdquo;作为待翻译文本发起请求的表单内容，&lt;code&gt;from&lt;/code&gt;、&lt;code&gt;to&lt;/code&gt;、&lt;code&gt;query&lt;/code&gt;这三项意义很明确，其余项无法直接判断出具体的作用。&lt;/p&gt;

&lt;h3 id=&#34;深入挖掘&#34;&gt;深入挖掘&lt;/h3&gt;

&lt;p&gt;多输入几组数据，可以发现&lt;code&gt;sign&lt;/code&gt;会随着&lt;code&gt;query&lt;/code&gt;的值发生变化，而&lt;code&gt;token&lt;/code&gt;项却不会发生改变。&lt;/p&gt;

&lt;p&gt;这里我参考了别人的方式，搜索&amp;rdquo;sign:&amp;ldquo;很快找到了这个请求的发起代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;h={from:p.fromLang,to:p.toLang,query:n,transtype:r,simple_means_flag:3,sign:y(n),token:window.common.token,domain:w.getCurDomain()}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外这里的&lt;code&gt;token&lt;/code&gt;也可以通过搜索&amp;rdquo;window[&amp;lsquo;common&amp;rsquo;]&amp;ldquo;找到，发现他其实位于html代码中，是一个固定的值，可以直接用正则表达式解析html代码获取。所以现在需要解决的问题就是&lt;code&gt;sign&lt;/code&gt;的产生。&lt;/p&gt;

&lt;h2 id=&#34;js破解&#34;&gt;JS破解&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;sign&lt;/code&gt;通过y函数产生，另外通过观察可以发现y函数的传参实际上是待查询的内容，所以只要找到y函数，理论上我们可以获得任意输入的&lt;code&gt;sign&lt;/code&gt;值。那么怎么才能找到y函数呢？第一个想法当然是继续搜索，但实际上一搜索就会发现，因为特征太少无法确定具体是哪一个搜索结果。这里需要使用一个很关键的技术：&lt;code&gt;JS调试&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;js调试&#34;&gt;JS调试&lt;/h3&gt;

&lt;p&gt;先说一下调试的具体步骤，如果没有相关基础的话直接上手还是会有点问题的。&lt;/p&gt;

&lt;p&gt;首先找到代码所在行，对于复杂网页，一行内可能有多条语句，这时候如果直接点击想要调试的函数的话，实际上不会添加断点。正确的操作应该是像Python代码那样，先点击这一行的最左侧的行号，点击行号之后在把鼠标移动到想要调试的函数上，这时候会发现函数可以被点击，点击函数名便能添加断点。（当然也可以直接点击代码框左下角的花括号，直接把代码格式化，我当时找了很久没找到😣）&lt;/p&gt;

&lt;p&gt;在添加完断点之后，继续输入内容，点击翻译，可以发现网站停止加载，并且返回调试界面可以看到变量名及其对应的值，将鼠标放到函数名上可以跳转到函数的具体位置，这样就能找到y函数的真正位置了。其具体内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function e(r) {
    var o = r.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g);
    if (null === o) {
        var t = r.length;
        t &amp;gt; 30 &amp;amp;&amp;amp; (r = &amp;quot;&amp;quot; + r.substr(0, 10) + r.substr(Math.floor(t / 2) - 5, 10) + r.substr(-10, 10))
    } else {
        for (var e = r.split(/[\uD800-\uDBFF][\uDC00-\uDFFF]/), C = 0, h = e.length, f = []; h &amp;gt; C; C++)&amp;quot;&amp;quot; !== e[C] &amp;amp;&amp;amp; f.push.apply(f, a(e[C].split(&amp;quot;&amp;quot;))), C !== h - 1 &amp;amp;&amp;amp; f.push(o[C]);
        var g = f.length; g &amp;gt; 30 &amp;amp;&amp;amp; (r = f.slice(0, 10).join(&amp;quot;&amp;quot;) + f.slice(Math.floor(g / 2) - 5, Math.floor(g / 2) + 5).join(&amp;quot;&amp;quot;) + f.slice(-10).join(&amp;quot;&amp;quot;))
    }
    var i = null;   // 直接执行会提示i没有定义 所以加了一行
    var u = void 0, l = &amp;quot;&amp;quot; + String.fromCharCode(103) + String.fromCharCode(116) + String.fromCharCode(107); 
    u = null !== i ? i : (i = window[l] || &amp;quot;&amp;quot;) || &amp;quot;&amp;quot;;
    for (var d = u.split(&amp;quot;.&amp;quot;), m = Number(d[0]) || 0, s = Number(d[1]) || 0, S = [], c = 0, v = 0; v &amp;lt; r.length; v++) {
        var A = r.charCodeAt(v); 128 &amp;gt; A ? S[c++] = A : (2048 &amp;gt; A ? S[c++] = A &amp;gt;&amp;gt; 6 | 192 : (55296 === (64512 &amp;amp; A) &amp;amp;&amp;amp; v + 1 &amp;lt; r.length &amp;amp;&amp;amp; 56320 === (64512 &amp;amp; r.charCodeAt(v + 1)) ? (A = 65536 + ((1023 &amp;amp; A) &amp;lt;&amp;lt; 10) + (1023 &amp;amp; r.charCodeAt(++v)), S[c++] = A &amp;gt;&amp;gt; 18 | 240, S[c++] = A &amp;gt;&amp;gt; 12 &amp;amp; 63 | 128) : S[c++] = A &amp;gt;&amp;gt; 12 | 224, S[c++] = A &amp;gt;&amp;gt; 6 &amp;amp; 63 | 128), S[c++] = 63 &amp;amp; A | 128)
    } for (var p = m, F = &amp;quot;&amp;quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(97) + (&amp;quot;&amp;quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(54)), D = &amp;quot;&amp;quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(51) + (&amp;quot;&amp;quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(98)) + (&amp;quot;&amp;quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(102)), b = 0; b &amp;lt; S.length; b++)p += S[b], p = n(p, F);
    return p = n(p, D), p ^= s, 0 &amp;gt; p &amp;amp;&amp;amp; (p = (2147483647 &amp;amp; p) + 2147483648), p %= 1e6, p.toString() + &amp;quot;.&amp;quot; + (p ^ m)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到这段代码还是比较复杂的，如果懂js的话，可以稍微解读一下，因为这段代码还没有混淆到完全没办法看的程度（把所有的字符都用括号或者下划线之类的替代）。&lt;/p&gt;

&lt;p&gt;这里讲三个后续执行代码的时候才会发现的点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;代码使用了全局的&lt;code&gt;window&lt;/code&gt;变量，js函数当中未作定义，通过调试可以发现实际上是为了获取该变量的&lt;code&gt;gtk&lt;/code&gt;值，该值也是写在html当中的，可以直接正则获得，获得之后对js代码进行稍微修改即可。&lt;/li&gt;
&lt;li&gt;i变量未定义，没有找到i变量的具体位置，但是查看之后其没有很突出的作用，于是自己加了一条语句，对i变量进行了定义。&lt;/li&gt;
&lt;li&gt;函数内部调用了另外的函数n😑，具体的调用可以在函数的return位置，如果不仔细看过，第一遍是不会发现这个点的。找到n的方法也很简单，直接打断点就好了，这里不做详细解释。n的代码会在最后给出。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;python执行js代码&#34;&gt;Python执行JS代码&lt;/h3&gt;

&lt;p&gt;前面我们已经获得了&lt;code&gt;sign&lt;/code&gt;生成函数的具体代码，但是我们的爬虫语言是Python，如果把js代码翻译成Python就太麻烦了，还好有已经封装好的第三方库可以执行。&lt;/p&gt;

&lt;p&gt;能够实现上述功能的第三方库有很多，我这里使用了&lt;code&gt;pyexecjs&lt;/code&gt;，需要注意该模块需要安装node.js配合使用。假设我们已经把生成函数放在了fanyi.js当中，可以通过下面的方式进行调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import execjs

query = &amp;quot;待翻译语句&amp;quot;
fh = open(&#39;fanyi.js&#39;, &#39;r&#39;)
fun = execjs.compile(fh.read())
print(fun.call(&#39;e&#39;, query))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;代码实现&#34;&gt;代码实现&lt;/h2&gt;

&lt;p&gt;在做完前面的准备工作之后，便能开始具体的代码书写，整体思路如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;请求百度翻译首页&lt;/li&gt;
&lt;li&gt;解析html获得&lt;code&gt;token&lt;/code&gt;、&lt;code&gt;gtk&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用得到的&lt;code&gt;gkt&lt;/code&gt;替换js代码中的对应内容&lt;/li&gt;
&lt;li&gt;编译js代码并执行，获得&lt;code&gt;sign&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求具体的语言检测、翻译网址，得到结果&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在实现爬虫时，我又对查询请求做了进一步分析，发现在提交的众多cookie当中，最关键的是&lt;code&gt;BAIDUID&lt;/code&gt;这一项，而访问百度翻译首页刚好可以获得这个cookie。&lt;/p&gt;

&lt;p&gt;这样便能直接用一个session，先访问百度翻译首页，获得cookie的同时解析html得到&lt;code&gt;token&lt;/code&gt;和&lt;code&gt;gtk&lt;/code&gt;，进行下一步的操作。到这里代码已经很清晰了，但是写完之后却发现不能成功执行，服务端报错998😭&lt;/p&gt;

&lt;p&gt;看到错误之后以为是js代码出了问题，调整了很久，但是最后还是不行，于是又求助了百度，在&lt;a href=&#34;https://www.cnblogs.com/jason-Gan/p/10567018.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;找到了一个解决办法，先访问一下百度首页，带着百度首页的cookie访问百度翻译，这样就不会报错。&lt;/p&gt;

&lt;p&gt;具体的原理我到现在还不清楚，我之前进行测试的时候，如果不先访问百度首页的话，访问百度翻译解析出来的&lt;code&gt;token&lt;/code&gt;是一个一成不变的值，我起初认为是js代码有错误，就一直进行了测试，半个多小时&lt;code&gt;token&lt;/code&gt;的值都没有变化。&lt;code&gt;token&lt;/code&gt;是在html当中写死的，有问题只能出在服务端上，所以我认为先访问百度首页的目的就是在访问百度翻译的时候带着一个cookie，让服务器返回html的时候生成正确的&lt;code&gt;token&lt;/code&gt;。至于具体是不是这个原因，等学的更多了才知道。&lt;/p&gt;

&lt;p&gt;下面是我的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import re
import requests
import execjs
import json


js_content = r&amp;quot;&amp;quot;&amp;quot;function e(r) {
    var o = r.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g);
    if (null === o) {
        var t = r.length;
        t &amp;gt; 30 &amp;amp;&amp;amp; (r = &amp;quot;&amp;quot; + r.substr(0, 10) + r.substr(Math.floor(t / 2) - 5, 10) + r.substr(-10, 10))
    } else {
        for (var e = r.split(/[\uD800-\uDBFF][\uDC00-\uDFFF]/), C = 0, h = e.length, f = []; h &amp;gt; C; C++)&amp;quot;&amp;quot; !== e[C] &amp;amp;&amp;amp; f.push.apply(f, a(e[C].split(&amp;quot;&amp;quot;))), C !== h - 1 &amp;amp;&amp;amp; f.push(o[C]);
        var g = f.length; g &amp;gt; 30 &amp;amp;&amp;amp; (r = f.slice(0, 10).join(&amp;quot;&amp;quot;) + f.slice(Math.floor(g / 2) - 5, Math.floor(g / 2) + 5).join(&amp;quot;&amp;quot;) + f.slice(-10).join(&amp;quot;&amp;quot;))
    }
    var i = null 
    var u = void 0, l = &amp;quot;&amp;quot; + String.fromCharCode(103) + String.fromCharCode(116) + String.fromCharCode(107); 
    u = null !== i ? i : (i = window[l] || &amp;quot;&amp;quot;) || &amp;quot;&amp;quot;;
    for (var d = u.split(&amp;quot;.&amp;quot;), m = Number(d[0]) || 0, s = Number(d[1]) || 0, S = [], c = 0, v = 0; v &amp;lt; r.length; v++) {
        var A = r.charCodeAt(v); 128 &amp;gt; A ? S[c++] = A : (2048 &amp;gt; A ? S[c++] = A &amp;gt;&amp;gt; 6 | 192 : (55296 === (64512 &amp;amp; A) &amp;amp;&amp;amp; v + 1 &amp;lt; r.length &amp;amp;&amp;amp; 56320 === (64512 &amp;amp; r.charCodeAt(v + 1)) ? (A = 65536 + ((1023 &amp;amp; A) &amp;lt;&amp;lt; 10) + (1023 &amp;amp; r.charCodeAt(++v)), S[c++] = A &amp;gt;&amp;gt; 18 | 240, S[c++] = A &amp;gt;&amp;gt; 12 &amp;amp; 63 | 128) : S[c++] = A &amp;gt;&amp;gt; 12 | 224, S[c++] = A &amp;gt;&amp;gt; 6 &amp;amp; 63 | 128), S[c++] = 63 &amp;amp; A | 128)
    } for (var p = m, F = &amp;quot;&amp;quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(97) + (&amp;quot;&amp;quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(54)), D = &amp;quot;&amp;quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(51) + (&amp;quot;&amp;quot; + String.fromCharCode(94) + String.fromCharCode(43) + String.fromCharCode(98)) + (&amp;quot;&amp;quot; + String.fromCharCode(43) + String.fromCharCode(45) + String.fromCharCode(102)), b = 0; b &amp;lt; S.length; b++)p += S[b], p = n(p, F);
    return p = n(p, D), p ^= s, 0 &amp;gt; p &amp;amp;&amp;amp; (p = (2147483647 &amp;amp; p) + 2147483648), p %= 1e6, p.toString() + &amp;quot;.&amp;quot; + (p ^ m)
}

function n(r, o) {
    for (var t = 0; t &amp;lt; o.length - 2; t += 3) {
        var a = o.charAt(t + 2); a = a &amp;gt;= &amp;quot;a&amp;quot; ? a.charCodeAt(0) - 87 : Number(a), a = &amp;quot;+&amp;quot; === o.charAt(t + 1) ? r &amp;gt;&amp;gt;&amp;gt; a : r &amp;lt;&amp;lt; a, r = &amp;quot;+&amp;quot; === o.charAt(t) ? r + a &amp;amp; 4294967295 : r ^ a
    } return r
}
&amp;quot;&amp;quot;&amp;quot;


class TransMachine():
    def __init__(self):
        self.session = requests.session()

    def get_token_and_gtk(self):
        user_agent = &amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4133.0 Safari/537.36 Edg/84.0.508.0&amp;quot;
        headers = {
            &#39;User-Agent&#39;: user_agent
        }
        res = self.session.get(&amp;quot;https://www.baidu.com/&amp;quot;, headers=headers)     # 神也不知道为什么访问百度首页就能避免998
        print(res.cookies)
        url = &#39;https://fanyi.baidu.com/&#39;
        res = self.session.get(url, headers=headers)
        print(res.cookies)
        res = res.text
        # fh = open(&#39;res.html&#39;, &#39;wb&#39;)
        # fh.write(res.encode())
        # fh.close()

        token = re.findall(&amp;quot;token: &#39;(.*?)&#39;&amp;quot;, res)[0]
        gtk = re.findall(&amp;quot;.gtk = &#39;(.*?)&#39;&amp;quot;, res)[0]

        return token, gtk


    def get_trans(self, words, token, sign):
        check_res = self.session.post(
            &amp;quot;https://fanyi.baidu.com/langdetect&amp;quot;, data={&#39;query&#39;: words})
        check_json = json.loads(check_res.text)
        lan = check_json[&#39;lan&#39;]

        if lan == &#39;zh&#39;:
            lan_from = &#39;zh&#39;
            lan_to = &#39;en&#39;
        elif lan == &#39;en&#39;:
            lan_from = &#39;en&#39;
            lan_to = &#39;zh&#39;
        else:
            return &#39;语言检测错误&#39;

        url = &#39;https://fanyi.baidu.com/v2transapi&#39;
        form_data = {
            &#39;from&#39;: lan_from,
            &#39;to&#39;: lan_to,
            &#39;query&#39;: words,
            &#39;transtype&#39;: &#39;realtime&#39;,
            &#39;simple_means_flag&#39;: 3,
            &#39;sign&#39;: sign,
            &#39;token&#39;: token,
            &#39;domain&#39;: &#39;common&#39;
        }

        user_agent = &amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/84.0.4133.0 Safari/537.36 Edg/84.0.508.0&amp;quot;
        headers = {
            &#39;User-Agent&#39;: user_agent,
            &#39;origin&#39;: &#39;https://fanyi.baidu.com&#39;,
            &#39;referer&#39;: &#39;https://fanyi.baidu.com/&#39;
        }

        res = self.session.post(url, data=form_data, headers=headers).content.decode()
        res_json = json.loads(res)
        res = res_json[&#39;trans_result&#39;][&#39;data&#39;][0][&#39;dst&#39;]
        return &#39;翻译结果：&#39; + res


if __name__ == &#39;__main__&#39;:
    TM = TransMachine()
    token, gtk = TM.get_token_and_gtk()
    print(&#39;token:&#39;, token, &#39;gtk:&#39;, gtk)

    # 方括号需要加\
    js_content = re.sub(r&amp;quot;window\[l\]&amp;quot;, &#39;&amp;quot;&#39; + gtk + &#39;&amp;quot;&#39;, js_content)
    fh = open(&#39;res.js&#39;, &#39;w&#39;)
    fh.write(js_content)
    fh.close()
    fun = execjs.compile(js_content)

    while True:
        print(&#39;=========================================&#39;)
        words = input(&#39;输入要翻译的内容（中文或英文，输入空白退出）:&#39;)
        if words == &amp;quot;&amp;quot;:
            break
        sign = fun.call(&#39;e&#39;, words)
        print(TM.get_trans( words, token, sign))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面为了cookie花了超级久的功夫，但实际上，可以直接手动访问一次，把cookie复制到代码里面，看到这个做法之后人直接傻了🙃&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>爬虫获取力扣题目信息并转为Markdown</title>
      <link>https://wanakiki.github.io/2020/leetcode-spider/</link>
      <pubDate>Sat, 02 May 2020 14:38:46 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2020/leetcode-spider/</guid>
      <description>

&lt;p&gt;很早就接触了leetcode，在上面做了不少题，每次整理的时候复制题目信息是个很麻烦的过程，于是便想着要用爬虫来解决这个问题，今天终于实现了这个功能，简单记录。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;写在前面&#34;&gt;写在前面&lt;/h2&gt;

&lt;p&gt;我自己用得比较多的两个语言是C++和Python，爬虫是去年五一假期简单入门的，到现在刚好过了一年。这一年里面也写了点小的爬虫脚本，比如查询图书馆某本书的借阅状态、学校官网信息的收集。之前访问的网站都是偏老的网站，界面都是一些静态界面，不需要动态加载，一般都是简单访问页面之后解析数据就能获得想要的信息。但是leetcode网页的加载方式跟之前那些网站不一样，它的绝大部分内容都是动态加载出来的，首次请求只会返回一个基本的网页模板，之后会自动发起（或者用户调用）请求获得页面更详细的信息。&lt;/p&gt;

&lt;p&gt;最近我也在做我的SRDP项目，对网站的基本知识也有了一定的了解，按照现在的发展趋势，像Leetcode这样的网站构建方式会逐渐成为主流，前后端分离、数据动态加载，这样后续跨平台制作客户端或者小程序会非常方便。所以在我看来，这次Leetcode爬取是很有意义的。&lt;/p&gt;

&lt;p&gt;在正式开始之前，先介绍一下其他人的一篇文章：&lt;a href=&#34;https://www.jianshu.com/p/199881dc86e2&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Python爬取 LeetCode 题目及 AC 代码&lt;/a&gt;，从这篇文章当中我接触到了一些新的知识，也参考了原文章中的一些代码。但有一点，现在leetcode的登陆方式发生了变化，我不确定这篇文章里面的代码是否可用。&lt;/p&gt;

&lt;h2 id=&#34;基本知识&#34;&gt;基本知识&lt;/h2&gt;

&lt;p&gt;首先要知道，网页的动态加载方式是通过Ajax技术实现的，关于这项技术具体的操作我们可以暂时不用了解，但需要知道下面这点信息：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Ajax在工作的时候，会创建一个XHR（或是Fetch）对象，然后利用XHR对象来实现服务器和浏览器之间传输数据。在这里，XHR和Fetch并没有本质区别，只是Fetch出现得比XHR更晚一些，所以对一些开发人员来说会更好用，但作用都是一样的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通过浏览器自带的&lt;code&gt;右键-&amp;gt;检查-&amp;gt;network&lt;/code&gt;，可以知道网页的请求过程，选择&lt;code&gt;XHR&lt;/code&gt;便能看到所有的动态加载信息，分析加载过程。下面就是leetcode首页的情况：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/leetcode-spider/20200502151203.png&#34; alt=&#34;leetcode首页&#34; /&gt;&lt;/p&gt;

&lt;p&gt;点开每条内容可以看到具体信息，可以查看其对应的响应内容。&lt;/p&gt;

&lt;h2 id=&#34;问题页面分析&#34;&gt;问题页面分析&lt;/h2&gt;

&lt;p&gt;访问&lt;a href=&#34;https://leetcode-cn.com/problemset/all/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;问题列表&lt;/a&gt;（不需要登陆），再随便打开一个问题页面，重复上面提到的检查过程，对得到的所有XHR对象进行检索，可以发现在某个请求里面含有题目信息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/leetcode-spider/20200502152530.png&#34; alt=&#34;具体查看位置&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来检查这个请求的其他信息，可以发现这是一个POST请求，请求头当中有很特殊的一项&lt;code&gt;Request Payload&lt;/code&gt;，点开可以看到很多信息。在左边也能看到XHR类型的请求名字都是一样的，在分析内容的时候，我就很好奇这些请求的名字为什么都是&lt;code&gt;graphql&lt;/code&gt;，于是就搜了一下，get到了一个新的知识点。(我很庆幸当时直接搜索了，省了很多麻烦)&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;GraphQL 是一种用于 API 的查询语言，是由 Facebook 开源的一种用于提供数据查询服务的抽象框架。在服务端 API 开发中，很多时候定义一个接口返回的数据相对固定，因此要获得更多信息或者只想得到某部分信息时，基于 RESTful API 的接口就显得不那么灵活。而 GraphQL 对 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。&lt;br /&gt;
来源：&lt;a href=&#34;https://blog.csdn.net/qq_42564846/article/details/81127469&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;以LeetCode为例——如何发送GraphQL Query获取数据&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;搜索过程中也发现了别人是如何提交这份信息的，实现过程跟普通的请求没有太大的区别，只要把查询参数封装好传递过去就可以了，实现的时候我参考了开始那篇文章里面的代码。&lt;/p&gt;

&lt;p&gt;这里讲一点题外话，在后面的分析中，我发现Leetcode的绝大部分数据都是采用这种方式获取的，甚至登陆都是通过这种方式将用户名密码传递到服务器，再设置带有用户信息的cookie。因为这点，我怀疑之前参考的那份简书的文章里面的代码应该不再适用了。&lt;/p&gt;

&lt;h2 id=&#34;具体实现&#34;&gt;具体实现&lt;/h2&gt;

&lt;p&gt;整体来说没有太多复杂的地方，需要注意的有两点。第一是graphql的查询内容的格式在封装的时候要注意保证格式的正确，因为查询代码的缩进很重要。&lt;/p&gt;

&lt;p&gt;网页上直接复制来的信息只有一行，需要对其进行稍微的处理，替换掉不必要的换行符，代码的缩进也要注意。我直接在VSCode上安装了一个插件，对查询代码进行了格式化，下面是我处理后的代码，可以看到正常的查询内容还是很多的。使用的时候需要注意把&lt;code&gt;variables: {titleSlug: &amp;quot;merge-two-sorted-lists&amp;quot;}&lt;/code&gt;这一行的titleSlug变量值换成想要查询的题目。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gql&#34;&gt;{
  operationName: &amp;quot;questionData&amp;quot;
  query: &amp;quot;query questionData($titleSlug: String!) {
  question(titleSlug: $titleSlug) {
    questionId
    questionFrontendId
    boundTopicId
    title
    titleSlug
    content
    translatedTitle
    translatedContent
    isPaidOnly
    difficulty
    likes
    dislikes
    isLiked
    similarQuestions
    contributors {
      username
      profileUrl
      avatarUrl
      __typename
    }
    langToValidPlayground
    topicTags {
      name
      slug
      translatedName
      __typename
    }
    companyTagStats
    codeSnippets {
      lang
      langSlug
      code
      __typename
    }
    stats
    hints
    solution {
      id
      canSeeDetail
      __typename
    }
    status
    sampleTestCase
    metaData
    judgerAvailable
    judgeType
    mysqlSchemas
    enableRunCode
    envInfo
    book {
      id
      bookName
      pressName
      source
      shortDescription
      fullDescription
      bookImgUrl
      pressImgUrl
      productUrl
      __typename
    }
    isSubscribed
    isDailyQuestion
    dailyRecordStatus
    editorType
    ugcQuestionId
    __typename
  }
}
&amp;quot;
  variables: {titleSlug: &amp;quot;merge-two-sorted-lists&amp;quot;}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二点需要注意的是Graphql查询的灵活度很高，在使用的时候不必要的查询内容完全可以忽略掉，我在实现的时候就只保留了我想要的查询信息。下面是我的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;import requests, json

def get_problem_content(slug):
    user_agent = &amp;quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.122 Safari/537.36&amp;quot;
    session = requests.Session()
    url = &amp;quot;https://leetcode-cn.com/graphql&amp;quot;
    params = {&#39;operationName&#39;: &amp;quot;getQuestionDetail&amp;quot;,
              &#39;variables&#39;: {&#39;titleSlug&#39;: slug},
              &#39;query&#39;: &#39;&#39;&#39;query getQuestionDetail($titleSlug: String!) {
            question(titleSlug: $titleSlug) {
                questionId
                translatedTitle
                translatedContent
            }
        }&#39;&#39;&#39;
    }
    json_data = json.dumps(params).encode(&#39;utf8&#39;)   

    headers = {&#39;User-Agent&#39;: user_agent, &#39;Connection&#39;:
               &#39;keep-alive&#39;, &#39;Content-Type&#39;: &#39;application/json&#39;,
               &#39;Referer&#39;: &#39;https://leetcode-cn.com/problems/&#39; + slug}
    resp = session.post(url, data=json_data, headers=headers, timeout=10)
    resp.encoding = &#39;utf8&#39;
    content = resp.json()

    # 题目详细信息
    print(content)
    question = content[&#39;data&#39;][&#39;question&#39;]
    fh = open(&#39;res.md&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)
    # fh.writelines(question[&#39;translatedContent&#39;])
    fh.writelines(convert(question[&#39;translatedContent&#39;]))
    fh.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;html转化为markdown&#34;&gt;html转化为Markdown&lt;/h3&gt;

&lt;p&gt;通过上面的函数可以获得题目的详细内容，但这个内容给出的方式是html代码，我之前在做笔记的时候都是用Markdown格式记录题目信息的，于是又写了一个函数用正则表达式对html标签进行了修改替换。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;import re

Remove = [
    &amp;quot;&amp;lt;/?p&amp;gt;&amp;quot;
]
Replace = [
    [&amp;quot;&amp;lt;/?code&amp;gt;&amp;quot;, &amp;quot;``&amp;quot;],
    [&amp;quot;&amp;lt;/?strong&amp;gt;&amp;quot;, &amp;quot;**&amp;quot;],
    [&amp;quot;&amp;lt;pre&amp;gt;&amp;quot;, &amp;quot;```\n&amp;quot;],
    [&amp;quot;&amp;lt;/pre&amp;gt;&amp;quot;, &amp;quot;```&amp;quot;],
    [&amp;quot;&amp;amp;nbsp;&amp;quot;, &amp;quot; &amp;quot;],
    [&amp;quot;&amp;amp;quot;&amp;quot;, &#39;&amp;quot;&#39;]
]

def convert(src):
    # pre内部预处理
    def remove_label_in_pre(matched):
        tmp = matched.group()
        tmp = re.sub(&amp;quot;&amp;lt;[^&amp;gt;p]*&amp;gt;&amp;quot;, &amp;quot;&amp;quot;, tmp)   # 不匹配&amp;gt;与p
        return tmp
    src = re.sub(&amp;quot;&amp;lt;pre&amp;gt;[\s\S]*?&amp;lt;/pre&amp;gt;&amp;quot;, remove_label_in_pre, src)   # 注意此处非贪心匹配，因为可能有多个示例

    # 可以直接删除的标签
    for curPattern in Remove:
        src = re.sub(curPattern, &amp;quot;&amp;quot;, src)

    # 需要替换内容的标签
    for curPattern, curRepl in Replace:
        src = re.sub(curPattern, curRepl, src)
    return src
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为题目内容里面的标签都是辅助标记类的标签，所以整体上不需要有很大的操作。通过分析可以发现，有些标签是可以直接去掉的，比如&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签，它标记了段落，直接删除之后在Markdown当中视觉效果相同。而另外大部分标签都需要替换成Markdown中对应的标识符，比如&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;标签需要替换成两个星号。这两种标签都可以直接用&lt;code&gt;re.sub&lt;/code&gt;函数进行替换，需要删除的标签可以直接替换为空字符串，其他标签替换为对应的标识符。&lt;/p&gt;

&lt;p&gt;实现过程中我发现&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;标签内部的标签不能做简单的处理，因为在一般的Markdown语法当中，代码块当中的内容是不会有加粗、斜体之类的特殊标记的，所以在对加粗、斜体等标签进行替换时，需要提前做处理，把代码块里面所有的标签都删掉。我在实现的时候使用了&lt;code&gt;re.sub&lt;/code&gt;函数的高级用法，替换字符串更改为了函数，具体的内容可以自行百度理解。&lt;/p&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;p&gt;对于我来说，做到这些基本已经足够了，接下来可能会让代码访问剪切板直接把题目信息设置到剪切板当中，结合utools方便自己的操作。关于用户登陆这里也有一点小的想法，实现过程需要创建一个session，找到并构造登陆用户的&lt;code&gt;Graphql&lt;/code&gt;语句发起请求，获得cookie，然后进行其他的查询操作。我暂时没有相关的需要，就不作进一步的探索了。🤔&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用异或找到数组中不重复出现的数字</title>
      <link>https://wanakiki.github.io/2020/xor/</link>
      <pubDate>Thu, 30 Apr 2020 10:51:11 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2020/xor/</guid>
      <description>

&lt;p&gt;找一个数很简单，但找两个数呢？&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;最近做leetcode上面的题目的时候，遇到了一个&lt;a href=&#34;https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;面试题&lt;/a&gt;，需要找到数组中两个只出现过一次的数（其余数均出现过两次），感觉很有意思，简单记录一下。&lt;/p&gt;

&lt;h2 id=&#34;基本知识&#34;&gt;基本知识&lt;/h2&gt;

&lt;p&gt;异或（&lt;code&gt;xor&lt;/code&gt;）是一种非常常见的位运算，其计算特点是“相同为0，不同为1”，计算符号是⊕，有时也用&lt;code&gt;a^b&lt;/code&gt;表示。一般使用异或时会用到下面的规律：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;任何数和本身的异或为0&lt;/li&gt;
&lt;li&gt;任何数与0的异或结果是自身&lt;/li&gt;
&lt;li&gt;异或满足交换律，&lt;code&gt;a^b^c = c^b^a&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;有了这些基本概念之后就能尝试去解决这个题目了。&lt;/p&gt;

&lt;h2 id=&#34;求解思路&#34;&gt;求解思路&lt;/h2&gt;

&lt;p&gt;关于如何用异或查找到数组中唯一出现的数字（其他数字均出现过两次），有一个很简单的解法：设置初始值为0，然后将这个值与数组中的所有数进行异或运算，最终的结果就是唯一出现的数字。&lt;/p&gt;

&lt;p&gt;看到这个题目，最开始想到的做法是亦或，但仔细考虑之后发现由于有两个数字都只出现了一次，所以对整个数组进行异或的最终结果是两个只出现过一次的数的异或。很明显这样不能解决问题，但如果能够把整个数组划分为两组，确保两个只出现过一次的数不在同一组内，并且相同的数一定在同一组当中这一条件，对两组内容各进行一次异或便能得到最终的结果。&lt;/p&gt;

&lt;p&gt;但是怎么划分呢？这里有一个很巧妙的做法，由于不相等的两个数进行异或之后一定有一位的值为1，可以通过这点将所有数据划分为两组：对整个数组的数据进行判断，将该位为0的数据分到一组，该位为1的数据分到一组。这样便能满足相同的数都会被分在一组当中，两个只出现过一次的数也会被分到不同的两组当中。&lt;/p&gt;

&lt;p&gt;在代码实现的过程中，并不需要显式的分组，只要对指定位进行判断，分别与两个不同的数进行异或即可。另外找到二进制中为1的某一位可以通过将1逐步左移的方式实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;class Solution {
public:
    vector&amp;lt;int&amp;gt; singleNumbers(vector&amp;lt;int&amp;gt;&amp;amp; nums) {
        int tmp = 0;
        for(int i = 0; i &amp;lt; nums.size(); i++){
            tmp ^= nums[i];
        }

        // 找到值为1的二进制位
        int index = 1;
        while(!(tmp&amp;amp;index)){
            index &amp;lt;&amp;lt;= 1;
        }

        int num1 = 0, num2 = 0;
        for(int i = 0; i &amp;lt; nums.size(); i++){
            if(nums[i] &amp;amp; index){
                num1 ^= nums[i];
            }
            else{
                num2 ^= nums[i];
            }
        }
        return vector&amp;lt;int&amp;gt;{num1, num2};
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;

&lt;p&gt;在这个题目的题解区看到了别人总结的力扣位运算题目：136、137、260、645，感兴趣可以深入了解一下。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Flutter 词典APP</title>
      <link>https://wanakiki.github.io/2020/special-dictionary/</link>
      <pubDate>Tue, 21 Apr 2020 09:43:32 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2020/special-dictionary/</guid>
      <description>

&lt;p&gt;对自己写的flutter APP的简单记录。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;怕自己忘了之前看过的flutter教程，所以趁周末写了这个APP，功能很简单，涉及到的都是基本知识，写的时候稍微花了点时间学习数据库和文件读写。界面不怎么漂亮，过渡动画之类的还没有了解过，flutter的坑要很久才能填上。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV19f4y1U7bH/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;演示视频地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;背景及大体设计&#34;&gt;背景及大体设计&lt;/h3&gt;

&lt;p&gt;因为很久之前用《单词城堡》APP背单词的时候，里面有一项内容要求用户把乱序单词排序，因为没有任何提示，做起来很吃力，于是在海科展当志愿者的时候趁着空闲时间写了一个python版的查乱序单词的脚本。脚本的实现思路很简单，就是对用户输入的字母进行全排列，对每种可能的情况在json文件中查找对应的汉语（json文件是在Github上找到的）。&lt;/p&gt;

&lt;p&gt;之后一段时间都把脚本下载到手机上，用termux执行进行查找，但是这样每次查一个单词都要打开termux然后输入命令，用户体验不是很好，慢慢就有了直接写一个APP的想法，这也是我学习flutter的原因之一。之后在寒假用了两周的时间把基本教程看了一遍，开学后发现有一堆事情等着我去做，暂时没时间对flutter进一步研究，于是趁着周六的空闲用了一天的时间把APP写了出来。&lt;/p&gt;

&lt;p&gt;有三个界面，分别是联网查询界面、本地json查询界面、收藏展示界面。为了简单直接使用一个&lt;code&gt;BottomNavigationBar&lt;/code&gt;处理，不需要很复杂的路由。另外本地查询的结果带有收藏选项，勾选后能在收藏展示界面查看。&lt;/p&gt;

&lt;h3 id=&#34;过程概述&#34;&gt;过程概述&lt;/h3&gt;

&lt;p&gt;首先创建项目，我使用的编辑器是VSCode，安装相关插件之后对flutter的支持很友好，因为电脑性能有限便用自己的手机进行相关调试。在VSCode中创建项目很简单，按下&lt;code&gt;Ctrl+Shift+P&lt;/code&gt;打开命令面板，输入flutter之后选择&lt;code&gt;Flutter: New Project&lt;/code&gt;，输入项目名后按下回车，之后选择项目位置，项目便会自动创建。&lt;/p&gt;

&lt;p&gt;首先写出来具体的程序框架，实现三个空白的页面，之后再对每个页面进行补充。&lt;/p&gt;

&lt;h4 id=&#34;联网查询&#34;&gt;联网查询&lt;/h4&gt;

&lt;p&gt;联网查询界面本来计划调用百度的API，但是发现dart有已经封装好的&lt;a href=&#34;https://pub.flutter-io.cn/packages/translator#-example-tab&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;第三方库&lt;/a&gt;，任务得到了简化，。示例中有多种语言的相互翻译，我只简单实现了中译英，代码很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;String _inputWords, _res;   // 输入单词 翻译结果
  
// 异步获取单词翻译结果
void _getRes() async{
  final translator = GoogleTranslator();
  translator.baseUrl = &amp;quot;https://translate.google.cntranslate_a/single&amp;quot;;
  var res = await translator.translate(_inputWords, to:&#39;zh-cn&#39;);
  setState(() {
    _res = res;
  });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;code&gt;TextField&lt;/code&gt;获取用户输入，之后用一个按钮触发上面的异步过程就能获得翻译结果并对相应部件进行重绘。&lt;/p&gt;

&lt;h4 id=&#34;本地查询&#34;&gt;本地查询&lt;/h4&gt;

&lt;p&gt;因为我已经有一个现成的json文件，只要把它读入再对用户的输入进行查询就能实现这个功能，用户输入、字典查询都很简单，对于我来说比较难的点是如何读取json资源。&lt;/p&gt;

&lt;p&gt;首先要明白一点，打包到程序安装包中的json是&lt;code&gt;assets&lt;/code&gt;，需要在项目当中对其进行指定，之后项目构建过程中会将其放到&lt;code&gt;asset bundle&lt;/code&gt;存档当中，应用程序可以在运行时进行读取。&lt;/p&gt;

&lt;p&gt;这要与用户设备中保存的文件进行区分，我在实现的时候搜索了很久flutter如何读取本地文件，用&lt;code&gt;path_provider&lt;/code&gt;插件实现之后却发现自己根本在项目里面找不到对应的目录放json文件，白花了很多时间。对于每个设备当中的文件，一定要先进行创建之后才能读取。&lt;/p&gt;

&lt;p&gt;接下来简单介绍一下我添加资源并进行读取的过程。&lt;/p&gt;

&lt;p&gt;将资源放在项目当中的某个文件夹内（通常是assets文件夹），之后在&lt;code&gt;pubspec.yaml&lt;/code&gt;文件当中添加文件及路径，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;flutter:
  assets:
    - assets/data.json
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后在程序当中使用&lt;code&gt;DefalutAssetBundle.of()&lt;/code&gt;获取资源，我读入json的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;Future&amp;lt;Map&amp;gt; _loadFile() async{
    String tmp = await DefaultAssetBundle.of(context).loadString(&#39;assets/data.json&#39;);
    return json.decode(tmp);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重写&lt;code&gt;initState()&lt;/code&gt;函数，在里面调用上面的异步过程便能将json文件加载到内存。几个相关链接：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://flutterchina.club/assets-and-images/#%E6%8C%87%E5%AE%9A-assets&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Flutter中文网：在Flutter中添加资源和图片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://flutterchina.club/reading-writing-files/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Flutter中文网：文件读写&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://flutter.dev/docs/cookbook/persistence/reading-writing-files&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Flutter官方：文件读写&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后简单提一下全排列的实现方式：将字母与包括自身在内的所有剩余字母交换顺序，然后递归调用，到达字符串末尾输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;void helper(String str, int pos){
    if(pos == str.length){
        print(str);
        return ;
    }
    else{
        for(int i = pos, i &amp;lt; str.length; i++){
            if(str[pos] == str[i] &amp;amp;&amp;amp; pos != i)
                continue;   // 与非自身的相同字母交换无意义
            var tmp = str[i];
            str[i] = str[pos];
            str[pos] = tmp;
            helper(str, pos+1, end);
            tmp = str[i];
            str[i] = str[pos];
            str[pos] = tmp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;收藏展示-sqlite数据库&#34;&gt;收藏展示（SQLite数据库)&lt;/h4&gt;

&lt;p&gt;这个界面的功能是对已经收藏过的数据进行展示，数据的保存方式可以是json或者使用数据库，因为搜索界面已经实现过文件读写了（虽然最后没用上），所以最终我使用了数据库保存数据。介绍之前先放两个链接：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://flutter.dev/docs/cookbook/persistence/sqlite&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Flutter官方：用SQLite保存数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.jianshu.com/p/3995ca566d9b&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;简书sirai：Flutter数据库Sqflite&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里强推官方的教程，只要有一定的数据库基础，按照官方教程一步步来会很清楚的了解具体的使用方法。官方教程的唯一遗憾是没有给出具体的调用方式，像我一样的初学者可能没办法直接想到合适的解决方法。在实现过程中我找到了上面简书的文章，里面讲到了通过封装一个&lt;code&gt;SqlManager&lt;/code&gt;类来实现部件中相关功能的调用。下面是我的具体实现，数据库很简单，只有一个表，表中只有单词、翻译两列内容。下面是我的实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;import &#39;package:sqflite/sqflite.dart&#39;;
import &#39;dart:async&#39;;
import &#39;package:path/path.dart&#39;;

class MyWord {
  final String word;
  final String translation;

  MyWord({this.word, this.translation});

  Map&amp;lt;String, dynamic&amp;gt; toMap() {
    return {
      &#39;word&#39;: word,
      &#39;translation&#39;: translation,
    };
  }
}

class SqlManager {
  static Database database;

  SqlManager(){
    print(&#39;初始化&#39;);
    init();
  }
  void init() async {
    database = await openDatabase(
      join(await getDatabasesPath(), &amp;quot;english_words.db&amp;quot;),
      onCreate: (db, version) {
        return db.execute(
            &amp;quot;CREATE TABLE words(word TEXT PRIMARY KEY, translation TEXT)&amp;quot;);
      },
      version: 1,
    );
  }
  
  Future&amp;lt;Database&amp;gt; getDatabase() async{
    if(database == null){
      await init();
    }
    return database;
  }

  // 插入单词
  Future&amp;lt;void&amp;gt; insertWord(MyWord word) async {
    print(&#39;插入&#39;);
    final Database db = await getDatabase();
    await db.insert(&#39;words&#39;, word.toMap(),
        conflictAlgorithm: ConflictAlgorithm.replace);
  }

  // 获取数据库内容
  Future&amp;lt;List&amp;lt;MyWord&amp;gt;&amp;gt; words() async {
    final Database db = await getDatabase();
    final List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt; maps = await db.query(&#39;words&#39;);
    return List.generate(maps.length, (index) {
      return MyWord(
          word: maps[index][&#39;word&#39;],
          translation: maps[index][&#39;translation&#39;]);
    });
  }

  // 检索是否已经收藏
  Future&amp;lt;bool&amp;gt; haveStore(String word) async{
    final db = await getDatabase();
    final List&amp;lt;Map&amp;lt;String, dynamic&amp;gt;&amp;gt; maps = await db.query(&amp;quot;words&amp;quot;,where: &amp;quot;word=?&amp;quot;, whereArgs: [word]);
    if(maps == null || maps.length == 0)
      return false;
    else
      return true;
  }

  // 更新记录
  Future&amp;lt;void&amp;gt; updateWord(MyWord record) async {
    final db = await getDatabase();
    await db
        .update(&#39;words&#39;, record.toMap(), where: &amp;quot;word = ?&amp;quot;, whereArgs: [record.word]);
  }

  // 删除单词
  Future&amp;lt;void&amp;gt; deleteWordBys(String word) async{
    final db = await getDatabase();
    int res = await db.delete(&#39;words&#39;, where: &amp;quot;word=?&amp;quot;,whereArgs: [word]);
    print(res);
  }
  
  // 删除表
  Future&amp;lt;void&amp;gt; deleteWords()async{
    final db = await getDatabase();
    int res =await db.delete(&#39;words&#39;);
    print(&#39;删除$res&#39;);
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单概括一下，想要使用sqlite数据库，需要sqflite、async、path三个库。需要对每个表的数据类进行封装，至少写出构造函数和字典转化函数（插入数据的参数格式为字典），之后封装一个SqlManager类，把自己想要实现的功能都准备好，在部件中创建该类的示例便能进行相关调用。&lt;/p&gt;

&lt;p&gt;这里对于数据库的初始化稍微有些不明白，在我的实现当中，有两个部件内部定义了数据库管理类的示例，但是他们能够使用相同的数据库，没有任何冲突。这可能和创建数据库时&lt;code&gt;onCreate&lt;/code&gt;参数或者sqflite的内部实现有关系。&lt;/p&gt;

&lt;h3 id=&#34;简单总结&#34;&gt;简单总结&lt;/h3&gt;

&lt;p&gt;在学习flutter的过程中，我首次接触到了异步的概念，当时只是做了简单的了解，但是在实现这个简单的APP的过程中，我的算法没有花费多少时间，大部分时间都在考虑异步的过程该怎么实现。感觉对&lt;code&gt;Future&lt;/code&gt;的理解还远远不够，之后如果还有机会需要加强这方面的理解。&lt;/p&gt;

&lt;p&gt;总之在这个领域只是个初学者，这个简单的APP也只是对前面所学知识的简单总结，还有很多深入工作要做。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VHDL设计 秒表</title>
      <link>https://wanakiki.github.io/2020/vhdl-miaobiao/</link>
      <pubDate>Wed, 01 Jan 2020 21:50:14 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2020/vhdl-miaobiao/</guid>
      <description>

&lt;p&gt;VHDL课程作业，设计一个带存储功能的秒表。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;演示视频：&lt;a href=&#34;https://www.bilibili.com/video/av79725799/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;https://www.bilibili.com/video/av79725799/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;秒表由以下模块组成：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;按键消抖 xd&lt;/li&gt;
&lt;li&gt;分频器 clock_gen&lt;/li&gt;
&lt;li&gt;计数器 cnt&lt;/li&gt;
&lt;li&gt;译码器 dec&lt;/li&gt;
&lt;li&gt;串行扫描 scan&lt;/li&gt;
&lt;li&gt;寄存器 reg&lt;/li&gt;
&lt;li&gt;蜂鸣器 ling&lt;/li&gt;
&lt;li&gt;顶层秒表 miaobiao&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;连接示意图，画的很垃圾😑&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/vhdl/20200101215905.png&#34; alt=&#34;示意图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;引脚分配图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/vhdl/20200101220658.jpg&#34; alt=&#34;引脚分配图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;顶层模块&#34;&gt;顶层模块&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-vhdl&#34;&gt;library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

entity miaobiao is
    port(
        clk, k1, k2, k3: in std_logic;
        selector: out std_logic_vector(3 downto 0);
        num: out std_logic_vector(7 downto 0);
        ling_out: out std_logic
    );
end entity miaobiao;

architecture rtl of miaobiao is
    
    component clock_gen is
        port(
            clk     : IN STD_LOGIC; 
            clk_us     : OUT STD_LOGIC;
            clk_ms 	   : OUT STD_LOGIC;
            clk_10ms   : OUT STD_LOGIC;
            clk_100ms 	   : OUT STD_LOGIC;
            clk_500ms   : OUT STD_LOGIC;
            clk_second : OUT STD_LOGIC
        );
    end component;

    component cnt is
        port(
            reset, clk: in std_logic;
            carry: out std_logic;
            nums: out std_logic_vector(3 downto 0)
        );
    end component cnt;

    component cnt6 is
        port(
            reset, clk: in std_logic;
            carry: out std_logic;
            nums: out std_logic_vector(3 downto 0)
        );
    end component cnt6;

    component dec is
        port(
            nums : in std_logic_vector(3 downto 0);
            res : out std_logic_vector(7 downto 0)
        );
    end component dec;

    component dec_node is
        port(
            nums : in std_logic_vector(3 downto 0);
            res : out std_logic_vector(7 downto 0)
        );
    end component dec_node;

    component ling is
        port(
            enable, clk1, clk2: in std_logic;
            clk_out : out std_logic
        );
    end component;

    component reg is
        port(
            clk, clear, enable, st:in std_logic;
            data: in std_logic_vector(15 downto 0);
            l_st: out std_logic;
            out_num0, out_num1, out_num2, out_num3: out std_logic_vector(3 downto 0)
        );
    end component reg;

    component scan is
        port(
            num0, num1, num2, num3: in std_logic_vector(7 downto 0);
            clk, clk_l, st: in std_logic;
            selector : out std_logic_vector(3 downto 0);
            nums: out std_logic_vector(7 downto 0)
        );
    end component scan;

    component xd is
        generic(n:integer:=30);
        port(clk,k1:in std_logic;
             y :out std_logic);
    end component xd;
--===================================================
    signal vcc, st, clear: std_logic;
    signal k1_xd, k2_xd, k3_xd, clk_10ms, clk_l, clk_xd, clk_cnt: std_logic;
    signal c0, c1, c2, c3: std_logic;       --cnt
	 signal num0, num1, num2, num3: std_logic_vector(3 downto 0);
    signal nums:std_logic_vector(15 downto 0);      --reg
    signal di_num0, di_num1, di_num2, di_num3: std_logic_vector(3 downto 0);      --decoder
    signal sc_num0, sc_num1, sc_num2, sc_num3: std_logic_vector(7 downto 0);   --scan
	 signal l_st:std_logic;
    signal push: std_logic;
begin
    vcc &amp;lt;= &#39;1&#39;;
    u0: clock_gen port map(clk=&amp;gt;clk, clk_10ms=&amp;gt;clk_cnt, clk_us=&amp;gt;open, clk_ms=&amp;gt;clk_xd, clk_100ms=&amp;gt;clk_l, clk_500ms=&amp;gt;open, clk_second=&amp;gt;open);
    u1: xd port map(clk=&amp;gt;clk_xd, k1=&amp;gt;k1, y=&amp;gt;k1_xd);
    u2: xd port map(clk=&amp;gt;clk_xd, k1=&amp;gt;k2, y=&amp;gt;k2_xd);
    u3: xd port map(clk=&amp;gt;clk_xd, k1=&amp;gt;k3, y=&amp;gt;k3_xd);
    
    c0 &amp;lt;= clk_cnt and st;
    clear &amp;lt;= st or k2_xd;
    u4: cnt port map(reset=&amp;gt;clear, clk=&amp;gt;c0, carry=&amp;gt;c1, nums=&amp;gt;num0);
    u5: cnt port map(reset=&amp;gt;clear, clk=&amp;gt;c1, carry=&amp;gt;c2, nums=&amp;gt;num1);
    u6: cnt port map(reset=&amp;gt;clear, clk=&amp;gt;c2, carry=&amp;gt;c3, nums=&amp;gt;num2);
    u7: cnt6 port map(reset=&amp;gt;clear, clk=&amp;gt;c3, carry=&amp;gt;open, nums=&amp;gt;num3);

    nums&amp;lt;= num3 &amp;amp; num2 &amp;amp; num1 &amp;amp; num0;
    u8: reg port map(clk=&amp;gt;k3_xd, clear=&amp;gt;clear, enable=&amp;gt;vcc, st=&amp;gt;st, data=&amp;gt;nums, l_st=&amp;gt;l_st,out_num0=&amp;gt;di_num0, out_num1=&amp;gt;di_num1, out_num2=&amp;gt;di_num2, out_num3=&amp;gt;di_num3);
    
    u9: dec port map(nums=&amp;gt;di_num0, res=&amp;gt;sc_num0);
    u10: dec port map(nums=&amp;gt;di_num1, res=&amp;gt;sc_num1);
    u11: dec_node port map(nums=&amp;gt;di_num2, res=&amp;gt;sc_num2);
    u12: dec port map(nums=&amp;gt;di_num3, res=&amp;gt;sc_num3);
    
    u13: scan port map(num0=&amp;gt;sc_num0, num1=&amp;gt;sc_num1, num2=&amp;gt;sc_num2, num3=&amp;gt;sc_num3, clk=&amp;gt;clk_xd, clk_l=&amp;gt;clk_l, st=&amp;gt;l_st, selector=&amp;gt;selector, nums=&amp;gt;num);
    
    push &amp;lt;= k1_xd and k2_xd and k3_xd;
    u14: ling port map(enable=&amp;gt; push, clk1=&amp;gt;clk_l, clk2=&amp;gt;clk_xd, clk_out=&amp;gt;ling_out);
    
    --zhuangtaikongzhi
    process(k1_xd)
    begin
        if k1_xd&#39;event and k1_xd = &#39;0&#39; then
            if st = &#39;0&#39; then
                st &amp;lt;= &#39;1&#39;;
            else
                st &amp;lt;= &#39;0&#39;;
            end if;
        end if;
    end process;
end architecture rtl;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;消抖模块&#34;&gt;消抖模块&lt;/h2&gt;

&lt;p&gt;通常情况下，消抖时间为20ms。以下代码同样由老师提供，时钟输入为1ms。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vhdl&#34;&gt;library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

entity xd is
generic(n:integer:=30);
port(clk,k1:in std_logic;
     y :out std_logic);
end xd;

architecture a of xd is
begin
process(clk)
variable sum:integer range 1 to n;
begin
if clk&#39;event and clk = &#39;0&#39; then 
	if k1=&#39;0&#39; then 
		if sum=n then 
			sum:=sum; 
		else
			sum:=sum+1;
		end if;
		
		if sum=n then 
			y&amp;lt;=&#39;0&#39;;
		else 
			y&amp;lt;=&#39;1&#39;;
		end if;
		
	else 
		sum:=1;
		y&amp;lt;=&#39;1&#39;;
	end if;
end if;
end process;
end;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;分频器模块&#34;&gt;分频器模块&lt;/h2&gt;

&lt;p&gt;由老师直接提供，能够产生的频率见引脚定义处。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vhdl&#34;&gt;LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
USE ieee.STD_LOGIC_ARITH.all;

------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
ENTITY clock_gen IS
PORT(
	clk     : IN STD_LOGIC; 
	clk_us     : OUT STD_LOGIC;
	clk_ms 	   : OUT STD_LOGIC;
	clk_10ms   : OUT STD_LOGIC;
	clk_100ms 	   : OUT STD_LOGIC;
	clk_500ms   : OUT STD_LOGIC;
	clk_second : OUT STD_LOGIC
	);
END clock_gen;
------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------
ARCHITECTURE  behav OF clock_gen IS
    CONSTANT shake_constant :integer:=10;    -- shake wait for shake_constant us
    signal q_1us :integer range 0 to 50;    --us��Ƶϵ��
	signal q_1ms :integer range 0 to 1000;  --ms��Ƶϵ��
	signal q_10ms:integer range 0 to 10;    --10ms��Ƶϵ��
	signal q_100ms :integer range 0 to 10;  --100ms��Ƶϵ��
	signal q_500ms:integer range 0 to 5;    --500ms��Ƶϵ��	
	signal q_1s :integer range 0 to 1;   --����Ƶϵ��
	
	SIGNAL sig_second : STD_LOGIC;
	SIGNAL sig_500ms : STD_LOGIC;	
	SIGNAL sig_100ms : STD_LOGIC;	
	SIGNAL sig_ms : STD_LOGIC;
	SIGNAL sig_10ms : STD_LOGIC;
	SIGNAL sig_us : STD_LOGIC;
    
-------------------------------------------------------------------------------------------
begin

output_clock:process(clk)                     
begin	
	if 	clk&#39;event and clk=&#39;1&#39; then
		clk_us     &amp;lt;= sig_us;	
		clk_ms     &amp;lt;= sig_ms;
		clk_10ms   &amp;lt;= sig_10ms;clk_100ms   &amp;lt;= sig_100ms;
		clk_second &amp;lt;= sig_second;
	end if;

end process;

-------------------------------------------------------------------------------------------
----**************��Ƶ�� 1 us clock*******************	
u_second:process(clk)         
begin	
	if 	clk&#39;event and clk=&#39;1&#39; then
        if  q_1us &amp;lt; 49	then
			q_1us &amp;lt;=  q_1us+1;
			sig_us &amp;lt;= &#39;0&#39;;
		else  
			q_1us &amp;lt;= 0;
			sig_us &amp;lt;= &#39;1&#39;;
			
		end if;
	end if;
end process;
-------------------------------------------------------------------------------------------
----**************��Ƶ�� 1 ms clock*******************
m_second:process(sig_us)                    
begin
	if sig_us&#39;event and sig_us=&#39;1&#39; then
		if  q_1ms &amp;lt; 999 then
			q_1ms &amp;lt;=  q_1ms+1;
			sig_ms &amp;lt;= &#39;0&#39;;
		else
			q_1ms &amp;lt;= 0;
			sig_ms &amp;lt;= &#39;1&#39;; 
		end if;
	end if;
end process;

-------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
----**************��Ƶ�� 10 ms clock*******************
m_second10:process(sig_ms)                    
begin
	if sig_ms&#39;event and sig_ms=&#39;1&#39; then
		if  q_10ms &amp;lt; 9 then
			q_10ms &amp;lt;=  q_10ms+1;
			sig_10ms &amp;lt;= &#39;0&#39;;
		else
			q_10ms &amp;lt;= 0;
			sig_10ms &amp;lt;= &#39;1&#39;; 
		end if;
	end if;
end process;

-------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
----**************��Ƶ�� 100 ms clock*******************
m_second100:process(sig_10ms)                    
begin
	if sig_10ms&#39;event and sig_10ms=&#39;1&#39; then
		if  q_100ms &amp;lt; 9 then
			q_100ms &amp;lt;=  q_100ms+1;
			sig_100ms &amp;lt;= &#39;0&#39;;
		else
			q_100ms &amp;lt;= 0;
			sig_100ms &amp;lt;= &#39;1&#39;; 
		end if;
	end if;
end process;

-------------------------------------------------------------------------
-------------------------------------------------------------------------------------------
----**************��Ƶ�� 500 ms clock*******************
m_second500:process(sig_100ms)                    
begin
	if sig_100ms&#39;event and sig_100ms=&#39;1&#39; then
		if  q_500ms &amp;lt; 4 then
			q_500ms &amp;lt;=  q_500ms+1;
			sig_500ms &amp;lt;= &#39;0&#39;;
		else
			q_500ms &amp;lt;= 0;
			sig_500ms &amp;lt;= &#39;1&#39;; 
		end if;
	end if;
end process;

-------------------------------------------------------------------------
----**************��Ƶ�� 1 second clock*******************
second:process(sig_500ms)                    
begin
	if 	sig_500ms&#39;event and sig_500ms=&#39;1&#39; then
		if  q_1s &amp;lt; 1 then
			q_1s &amp;lt;= q_1s+1;
			sig_second &amp;lt;= &#39;0&#39;;
		else
			q_1s &amp;lt;= 0;
			sig_second &amp;lt;= &#39;1&#39;; 
		end if;
	end if;
end process;
-------------------------------------------------------------------------
END behav;
------------------------------------------------------------------------------------------	
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;计数器模块&#34;&gt;计数器模块&lt;/h2&gt;

&lt;p&gt;十进制计数器，带有复位端、进位端。在实现秒表时，需要将最后一个计数器改为六进制。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vhdl&#34;&gt;library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
entity cnt is
	port(
		reset, clk: in std_logic;
		carry: out std_logic;
		nums: out std_logic_vector(3 downto 0)
	);
end entity cnt;

architecture rtl of cnt is
begin
	process(clk, reset)
	variable temp : std_logic_vector(3 downto 0);
	begin
		if reset = &#39;0&#39; then
			temp := (others =&amp;gt; &#39;0&#39;);
		elsif clk&#39;event and clk = &#39;1&#39; then
			if temp &amp;gt;= &amp;quot;1001&amp;quot; then
				temp := (others =&amp;gt; &#39;0&#39;);
				carry &amp;lt;= &#39;1&#39;;
			else
				temp := temp + 1;
				carry &amp;lt;= &#39;0&#39;;
			end if;
		end if;
		nums &amp;lt;= temp;
	end process;
end architecture rtl;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;译码器模块&#34;&gt;译码器模块&lt;/h2&gt;

&lt;p&gt;输入为四位二进制数，输出为对应的七段译码管数组。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vhdl&#34;&gt;library ieee;
use ieee.std_logic_1164.all;

entity dec is
	port(
		nums : in std_logic_vector(3 downto 0);
		res : out std_logic_vector(7 downto 0)
	);
end entity dec;

architecture rtl of dec is
begin
	process(nums)
	begin
		case nums is
			when &amp;quot;0000&amp;quot; =&amp;gt; res &amp;lt;= B&amp;quot;1100_0000&amp;quot;;
			when &amp;quot;0001&amp;quot; =&amp;gt; res &amp;lt;= B&amp;quot;1111_1001&amp;quot;;
			when &amp;quot;0010&amp;quot; =&amp;gt; res &amp;lt;= B&amp;quot;1010_0100&amp;quot;;
			when &amp;quot;0011&amp;quot; =&amp;gt; res &amp;lt;= B&amp;quot;1011_0000&amp;quot;;
			when &amp;quot;0100&amp;quot; =&amp;gt; res &amp;lt;= B&amp;quot;1001_1001&amp;quot;;
			when &amp;quot;0101&amp;quot; =&amp;gt; res &amp;lt;= B&amp;quot;1001_0010&amp;quot;;
			when &amp;quot;0110&amp;quot; =&amp;gt; res &amp;lt;= B&amp;quot;1000_0011&amp;quot;;
			when &amp;quot;0111&amp;quot; =&amp;gt; res &amp;lt;= B&amp;quot;1111_1000&amp;quot;;
			when &amp;quot;1000&amp;quot; =&amp;gt; res &amp;lt;= B&amp;quot;1000_0000&amp;quot;;
			when &amp;quot;1001&amp;quot; =&amp;gt; res &amp;lt;= B&amp;quot;1001_1000&amp;quot;;
			when others =&amp;gt; res &amp;lt;= B&amp;quot;1111_1111&amp;quot;;
		end case;
	end process;
end architecture rtl;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;串行扫描模块&#34;&gt;串行扫描模块&lt;/h2&gt;

&lt;p&gt;实现串行扫描功能，当st为零时会进入闪烁状态。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vhdl&#34;&gt;library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

entity scan is
	port(
		num0, num1, num2, num3: in std_logic_vector(7 downto 0);
		clk, clk_l, st: in std_logic;
		selector : out std_logic_vector(3 downto 0);
		nums: out std_logic_vector(7 downto 0)
	);
end entity scan;

architecture rtl of scan is
	signal flag :std_logic;
begin
	process(clk_l)
	begin
		if clk_l&#39;event and clk_l = &#39;1&#39; then
			if flag = &#39;1&#39; and  st = &#39;0&#39; then
				flag &amp;lt;= &#39;0&#39;;
			else
				flag &amp;lt;= &#39;1&#39;;
			end if;
		end if;
	end process;
	
	process(clk)
	variable cur : std_logic_vector(1 downto 0);
	begin
		if flag = &#39;1&#39; then
		if clk&#39;event and clk = &#39;1&#39; then
			case cur is
				when &amp;quot;00&amp;quot; =&amp;gt;
					selector &amp;lt;= &amp;quot;1110&amp;quot;;
					nums &amp;lt;= num0;
				when &amp;quot;01&amp;quot; =&amp;gt;
					selector &amp;lt;= &amp;quot;1101&amp;quot;;
					nums &amp;lt;= num1;
				when &amp;quot;10&amp;quot; =&amp;gt;
					selector &amp;lt;= &amp;quot;1011&amp;quot;;
					nums &amp;lt;= num2;
				when others =&amp;gt;
					selector &amp;lt;= &amp;quot;0111&amp;quot;;
					nums &amp;lt;= num3;
			end case;
			cur := cur + 1;
		end if;
		else
			selector &amp;lt;= &amp;quot;1111&amp;quot;;
		end if;
	end process;
end architecture rtl;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;寄存器模块&#34;&gt;寄存器模块&lt;/h2&gt;

&lt;p&gt;当秒表处于计时状态时，按下寄存器控制按键会将秒表当前的时间保存到计数器当中。当秒表处于暂停状态时，按下寄存器控制按键会将寄存器保存的数据逐个显示，在显示寄存器内部数据时，要求串行扫描闪烁。&lt;/p&gt;

&lt;p&gt;寄存器的输入为四个计数器当前的状态，内部能够根据秒表当下工作状态选择对应的数据交给译码器，设计相对复杂。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vhdl&#34;&gt;library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

entity reg is
	port(
		clk, clear, enable, st:in std_logic;
		data: in std_logic_vector(15 downto 0);
		l_st: out std_logic;
		out_num0, out_num1, out_num2, out_num3: out std_logic_vector(3 downto 0)
	);
end entity reg;

architecture rtl of reg is
	signal num0, num1, num2:std_logic_vector(15 downto 0);
begin
	process(clk, clear)
        variable status: integer range 0 to 3;
	begin		
		if clear = &#39;0&#39; then
			num0 &amp;lt;= (others =&amp;gt; &#39;0&#39;);
			num1 &amp;lt;= (others =&amp;gt; &#39;0&#39;);
			num2 &amp;lt;= (others =&amp;gt; &#39;0&#39;);
			status := 0;
		elsif enable = &#39;1&#39; then
            if(clk&#39;event and clk=&#39;1&#39;) then
					if st = &#39;1&#39; then
						num2 &amp;lt;= num1;
						num1 &amp;lt;= num0;
						num0 &amp;lt;= data;
					else
						if status &amp;gt;= 3 then
							status := 0;
						else
							status := status + 1;
						end if;
					end if;
				end if;
		end if;
		
		if st = &#39;1&#39; then
			status := 0;
		end if;
		
		case status is
			when 0 =&amp;gt;
				out_num3 &amp;lt;= data(15 downto 12);
				out_num2 &amp;lt;= data(11 downto 8);
				out_num1 &amp;lt;= data(7 downto 4);
				out_num0 &amp;lt;= data(3 downto 0);
				l_st &amp;lt;= &#39;1&#39;;
			when 1 =&amp;gt;
				out_num3 &amp;lt;= num0(15 downto 12);
				out_num2 &amp;lt;= num0(11 downto 8);
				out_num1 &amp;lt;= num0(7 downto 4);
				out_num0 &amp;lt;= num0(3 downto 0);
				l_st &amp;lt;= &#39;0&#39;;
			when 2 =&amp;gt;
				out_num3 &amp;lt;= num1(15 downto 12);
				out_num2 &amp;lt;= num1(11 downto 8);
				out_num1 &amp;lt;= num1(7 downto 4);
				out_num0 &amp;lt;= num1(3 downto 0);
				l_st &amp;lt;= &#39;0&#39;;
			when 3 =&amp;gt;
				out_num3 &amp;lt;= num2(15 downto 12);
				out_num2 &amp;lt;= num2(11 downto 8);
				out_num1 &amp;lt;= num2(7 downto 4);
				out_num0 &amp;lt;= num2(3 downto 0);
				l_st &amp;lt;= &#39;0&#39;;
			when others=&amp;gt;
				out_num3 &amp;lt;= data(15 downto 12);
				out_num2 &amp;lt;= data(11 downto 8);
				out_num1 &amp;lt;= data(7 downto 4);
				out_num0 &amp;lt;= data(3 downto 0);
				l_st &amp;lt;= &#39;1&#39;;
		end case;
	end process;
end rtl;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;蜂鸣器&#34;&gt;蜂鸣器&lt;/h2&gt;

&lt;p&gt;蜂鸣器的工作方式是当按键按下时鸣叫，当按键松开后，鸣叫会持续0.2秒。在我的设计当中，蜂鸣器使用了两个时钟输入，clk1用于控制蜂鸣器的发声频率，clk2（100ms）用来进行按键松开后的计时。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-vhdl&#34;&gt;library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;

entity ling is
	port(
		enable, clk1, clk2: in std_logic;
		clk_out : out std_logic
	);
end entity;

architecture rtl of ling is
	signal flag: std_logic;
begin
	process(clk2, flag)
	begin
		if flag = &#39;1&#39; then
			clk_out &amp;lt;= clk2;
		end if;
	end process;
	
	process(clk1,enable, clk2)
		variable num: integer range 0 to 2000;
	begin	
		if enable = &#39;0&#39; then
			flag &amp;lt;= &#39;1&#39;;
			num := 0;
        
		elsif clk1&#39;event and clk1 = &#39;1&#39; then
			if flag = &#39;1&#39; then
				if num &amp;gt;= 2 then
					flag &amp;lt;= &#39;0&#39;;
				else
					num := num + 1;
				end if;
			end if;
		end if;
	end process;
end architecture rtl;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Git 及 Github 上手</title>
      <link>https://wanakiki.github.io/2019/use-github/</link>
      <pubDate>Mon, 25 Nov 2019 16:15:58 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/use-github/</guid>
      <description>

&lt;p&gt;记录使用git及GitHub的过程
&lt;!-- more --&gt;&lt;/p&gt;

&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;

&lt;p&gt;在&lt;a href=&#34;https://github.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;GitHub官网&lt;/a&gt;注册账号，之后去&lt;a href=&#34;https://git-scm.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Git官网&lt;/a&gt;下载git并安装。安装完成后打开终端，输入下面的命令，在电脑上设置github邮箱和账户名&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git config --global user.name &amp;quot;用户名&amp;quot;
git config --global user.email &amp;quot;邮箱&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后，输入下面的命令生成SSH key，完成后将公钥添加到GitHub上&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh-keygen -t rsa -C &amp;quot;邮箱&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;存储库的创建&#34;&gt;存储库的创建&lt;/h2&gt;

&lt;p&gt;在个人界面，点击&lt;code&gt;new repository&lt;/code&gt;即可进入创建界面，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/use-github/20191125170027.png&#34; alt=&#34;创建界面&#34; /&gt;&lt;/p&gt;

&lt;p&gt;名称为必填项，存储库的描述为可选项。存储库可分为私有和公有，暂时不做解释。需要注意的是&lt;code&gt;Initialize this repository with a README&lt;/code&gt;选项，假如你想要将本地已经存在的存储库导入进来的话不需要勾选。因为我现在要从零创建一个存储库，所以勾上了这个选项。下方的添加gitignore和license暂时不需要了解。&lt;/p&gt;

&lt;p&gt;完成之后点击创建就会出现下面的界面，整个存储库只有一个&lt;code&gt;README.md&lt;/code&gt;文件，至此创建完成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/use-github/20191125170036.png&#34; alt=&#34;创建完成&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;代码操作&#34;&gt;代码操作&lt;/h2&gt;

&lt;h3 id=&#34;克隆存储库&#34;&gt;克隆存储库&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/use-github/20191125170041.png&#34; alt=&#34;位置&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，点击&lt;code&gt;Clone or download&lt;/code&gt;按钮会出现一个新窗口，复制窗口中的链接，切换到你想要保存存储库的文件夹，打开终端，输入下面的命令即可完成存储库的下载。默认使用ssh，当然也可以使用https。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git clone git@github.com:wanakiki/BiFang.git
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修改及上传&#34;&gt;修改及上传&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;git status&lt;/code&gt;查看存储库状态&lt;br /&gt;
&lt;code&gt;git add -A&lt;/code&gt;提交所有文件&lt;br /&gt;
&lt;code&gt;git commit -m &amp;quot;xxx&amp;quot;&lt;/code&gt;进行提交，其中xxx是对本次更改的说明&lt;br /&gt;
&lt;code&gt;git push&lt;/code&gt;将提交的更改推送到远程库&lt;/p&gt;

&lt;p&gt;输入完上述代码之后即可更新远程仓库。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>🏠班级网站项目</title>
      <link>https://wanakiki.github.io/2019/website/</link>
      <pubDate>Wed, 06 Nov 2019 23:04:39 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/website/</guid>
      <description>

&lt;!-- more --&gt;

&lt;h2 id=&#34;起因&#34;&gt;起因💡&lt;/h2&gt;

&lt;p&gt;本人有两年大学班委的经验，发现学校团委给班级的一般都是信息整理相关的工作。但现在已经是21世纪，完全没有必要因为收集一些个人信息让每个人都填写一遍excel表再发给班委进行汇总。我之前曾经试过利用腾讯文档进行信息收集，但大部分人都不是很适应，加上&lt;strong&gt;目前市面上找不到从excel生成在线表单的工具，每次问卷都需要花一定时间准备&lt;/strong&gt;，于是我有了写一个自己的网站的想法。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;进一步挖掘&#34;&gt;进一步挖掘🤔&lt;/h2&gt;

&lt;h3 id=&#34;更多功能&#34;&gt;更多功能？&lt;/h3&gt;

&lt;p&gt;在这个生成表单的基础上，我进行深入挖掘，又发现了其他的需要：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;班级投票、活动报名统计&lt;/li&gt;
&lt;li&gt;发布班级公告&lt;/li&gt;
&lt;li&gt;班级活动记录&lt;/li&gt;
&lt;li&gt;每个学期可有可无的课表统计&lt;/li&gt;
&lt;li&gt;需要以班级为单位提交的各种实验报告的收集（虽然邮箱也可以）&lt;/li&gt;
&lt;li&gt;对于某一项需要个人完成的班级工作，实时更新的进度排行（可以直观了解到还有哪些人没有完成任务，另外可以根据每次的时间排行计算班级活动参与度，用做学年素质测评的量化指标）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;网站的诱惑力&#34;&gt;网站的诱惑力？&lt;/h3&gt;

&lt;p&gt;那么为了让同学登陆这个网站，这个网站对普通班级成员又能提供什么帮助？我目前认为有以下几点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;提供课表，能够查到本学年所有专业课老师的开课时间&lt;/li&gt;
&lt;li&gt;提供海大的教务信息（直接爬虫动态更新）&lt;/li&gt;
&lt;li&gt;作业提醒（人工添加记录，到期自动删除）&lt;/li&gt;
&lt;li&gt;全海大竞赛信息提供（如果能够做到微信爬虫的话&amp;hellip;）&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;大体规划&#34;&gt;大体规划✨&lt;/h2&gt;

&lt;h4 id=&#34;flask后端&#34;&gt;FLASK后端&lt;/h4&gt;

&lt;p&gt;因为本人没有接触过java，考虑自己有一定的python基础以及python容易上手的特点，抛弃了LAMP架构，后端采用python的flask框架进行搭建。多人合作时难度也相对较低。&lt;/p&gt;

&lt;h4 id=&#34;vue前端框架&#34;&gt;VUE前端框架&lt;/h4&gt;

&lt;p&gt;本人前端知识了解很少，只知道传统的html+css+js，但是查找之后发现VUE是比较流行的解决方案，所有的都要学，那就学个大部分人都说好的。&lt;/p&gt;

&lt;h4 id=&#34;python爬虫&#34;&gt;Python爬虫&lt;/h4&gt;

&lt;p&gt;因为会涉及到一些教务信息，人工进行更新成本较大，还是用爬虫来实现比较方便，而且只爬教务信息的链接的话，实现起来非常简单。微信爬虫实现难度较大，短期不做考虑。&lt;/p&gt;

&lt;h4 id=&#34;数据库&#34;&gt;数据库&lt;/h4&gt;

&lt;p&gt;上面提供的功能根本离不开数据库，个人只会基础的sql查询，具体选用什么数据库还没有进行更深一步的了解。&lt;/p&gt;

&lt;h4 id=&#34;内网搭建&#34;&gt;内网搭建&lt;/h4&gt;

&lt;p&gt;网站主要是服务班级人数较少，初期计划部署在树莓派上，直接用海大校园内网IP地址进行访问。因为个人没有建站经验，无法准确估计出实现上述功能所需要的性能，这是整个项目中比较难解决的问题，也是必须解决的问题。&lt;/p&gt;

&lt;p&gt;内网搭建还需要解决两个问题：如何获取固定IP、如何保证供电&lt;/p&gt;

&lt;h4 id=&#34;one-more-thing&#34;&gt;One more thing&lt;/h4&gt;

&lt;p&gt;APP or 微信小程序，如果能做出来的话，是对自己的一个锻炼😁&lt;/p&gt;

&lt;p&gt;回头看一下自己想要实现的这些功能，基本和目前市面上存在的一些APP的功能类似，但毕竟自己的专业不在这个方面，又需要额外的时间和精力，不能保证最终能够实现。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结😊&lt;/h2&gt;

&lt;p&gt;在真正动手写这份报告的时候，我就清楚地感受到，这个网站其实没有特别大的实用性，也没有什么颠覆的点。对于我来说，更大的意义让自己学一点东西，详细了解一下怎么建立网站、怎么写web服务程序。&lt;/p&gt;

&lt;p&gt;再从宏观一点的角度来考虑，这个所谓的项目划分成几个部分后实现的功能其实并不复杂，实现的难度也不是很高，所以我认为这个网站想法可以作为SRDP项目来申请，锻炼自己的实践能力。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>利用Termux群发短信</title>
      <link>https://wanakiki.github.io/2019/termux-sms/</link>
      <pubDate>Wed, 25 Sep 2019 19:23:03 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/termux-sms/</guid>
      <description>

&lt;p&gt;Termux的简单应用，为了让群发短信有更便捷高效的解决方案。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Termux&lt;/code&gt;是一个Android下一个高级的终端模拟器，开源且不需要root，支持apt管理软件包，十分方便安装软件包，完美支持Python、PHP、Ruby、Go、Nodejs、MySQL等。随着智能设备的普及和性能的不断提升，如今的手机、平板等的硬件标准已达到了初级桌面计算机的硬件标准，用心去打造完全可以把手机变成一个强大的工具。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;关于软件的更多信息及基本配置，可以去看&lt;a href=&#34;https://www.sqlsec.com/2018/05/termux.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;国光的教程&lt;/a&gt;，写得很赞很全面。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：由于谷歌的政策更新，Termux最新版本的API没有访问手机短信内容的权限，想要实现发送短信的功能，需要使用相对较久的0.31版本。在这里给Termux API 0.31版本&lt;a href=&#34;https://pan.baidu.com/s/1toMtUW2MOEHPY7GOtfEYUg&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;下载地址&lt;/a&gt;，提取码：ttx1。API的安装方式在国光的文章中也有给出，不清楚可以去翻看。&lt;/p&gt;

&lt;p&gt;在了解完Termux并安装好API后，我们的教程正式开始。&lt;/p&gt;

&lt;h2 id=&#34;具体实现&#34;&gt;具体实现&lt;/h2&gt;

&lt;p&gt;虽然如今的QQ、微信已经承担了大部分我们的日常通信任务，但是总有一些情况需要电话短信来解决，比如给陌生人传达某些通知。电话是最优的解决方案，但是也会有一部分人倾向于短信。在经历了无数次的折磨之后，我终于发现了&lt;code&gt;Termux&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;假设你现在有一个含有联系人姓名及电话号码的表格，将无用信息删除，只保留姓名和号码两列具体内容后，可以通过&lt;code&gt;文件 -&amp;gt; 另存为 -&amp;gt; 文本文件(制表符分隔)&lt;/code&gt;的方式获得一个格式整齐的文本文档。将其重命名为&lt;code&gt;data.txt&lt;/code&gt;，用记事本打开后选择另存为，在另存为界面调整保存编码为&lt;code&gt;UTF-8&lt;/code&gt;，这步一定要做，不然程序无法正常读取文件。&lt;/p&gt;

&lt;p&gt;将得到的文件用QQ或者TIM发送到你的手机并接受，&lt;strong&gt;按照国光的教程中建立好文件夹链接&lt;/strong&gt;的前提下。以QQ为例，在终端中输入下面几行命令便可下载好程序。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd ~/QQ
wget https://raw.githubusercontent.com/wanakiki/furry/master/termux-sms/messages.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以找到默认的信息语句对其进行修改，以达到我们的目的。修改完毕后执行&lt;code&gt;python messages.py&lt;/code&gt;命令，运行程序。&lt;/p&gt;

&lt;p&gt;python实现代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
import os


def send_sms(aim, text):
    &amp;quot;&amp;quot;&amp;quot;use two argv to send messages
    &amp;quot;&amp;quot;&amp;quot;
    os.system(&#39;termux-sms-send -n &#39; + aim + &#39; &#39; + text)
    return


def fileMessage(fileName):
    &amp;quot;&amp;quot;&amp;quot;send messages form an excel(name, number)
    &amp;quot;&amp;quot;&amp;quot;

    print(&#39;start read file&#39;)
    try:
        fh = open(fileName, encoding=&#39;utf-8&#39;)
    except:
        print(&#39;Can\&#39;t find the data file&#39;)
        return

    # create list (name, number)
    group = []
    for line in fh:
        line = line.split()
        group.append(line)
    fh.close()

    # send message
    words = &amp;quot; hello, this is termux&amp;quot;  # Replace it with your own words
    for people in group:
        send_sms(people[1], people[0] + words)

    print(&#39;finish&#39;)
    return


def sendOne():
    aim = input(&#39;Please input your aim number\n&#39;)
    words = input(&#39;Now you can input your message\n&#39;)

    print(&#39;+=======================+&#39;)
    print(&#39;Please check your input:&#39;)
    print(&#39;number: &#39;, aim)
    print(&#39;words: &#39;, words)
    flag = input(
        &amp;quot;Now, if your input is correct, input &#39;y&#39; or &#39;Y&#39; to send your message: &amp;quot;)
    if (flag == &#39;y&#39; or flag == &#39;Y&#39;):
        send_sms(aim, words)
    return


print(&amp;quot;&amp;quot;&amp;quot;Functions:
1 Only send one message.(Test this program)
2 Send messages form one file.
+============================================+&amp;quot;&amp;quot;&amp;quot;)

flag = input(&#39;Choose the function:&#39;)
if flag == &#39;1&#39;:
    sendOne()
elif flag == &#39;2&#39;:
    fileMessage(&#39;data.txt&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/wanakiki/photo/master/shengsai/20190925205425.png&#34; alt=&#34;运行结果&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>提取小米云服务短信</title>
      <link>https://wanakiki.github.io/2019/short-message/</link>
      <pubDate>Thu, 05 Sep 2019 12:16:09 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/short-message/</guid>
      <description>&lt;p&gt;最近手机刷了AOSIP，原来的短信都没有同步，去小米云服务官网发现没有导出按钮，稍微折腾了下达到了目的，简单记录。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;登陆&lt;a href=&#34;https://i.mi.com/?_locale=zh_CN&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;小米云服务&lt;/a&gt;，进入短信界面，这个界面是动态加载的，需要手动下滑到最底部确定所有短信都已经被加载出来。&lt;/p&gt;

&lt;p&gt;之后按下&lt;code&gt;Ctrl+s&lt;/code&gt;，把整个网页保存下来，保存之后会是一个较大的html文件，用编辑器打开，找到其中短信部分。新建一个html文件，把短信部分的代码直接复制进来，使用文本编辑器自动进行格式化。最终可以得到一个可以正常打开浏览的界面。&lt;/p&gt;

&lt;p&gt;现在基本达到了短信备份的目的，但是我最近刚好计划着换掉原来的手机号，但是又害怕之前注册过的网站密码无法找回。这时候可以用保存好的短信html文件加上简单的python脚本，提取短信内容中被方括号包裹着的信息，将提取出来的公司名输出到一个文件中，可以用来后续的手机换绑。&lt;/p&gt;

&lt;p&gt;超级简单的python脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import re

fw = open(&#39;公司列表.txt&#39;,&#39;w&#39;,encoding=&#39;UTF-8&#39;)  #引号内为输出文件名
fh = open(&#39;网页.html&#39;,encoding=&#39;UTF-8&#39;)     #引号内文件名根据自己情况修改
store = []

for line in fh:
    res = re.findall(&#39;【(.*?)】&#39;, line)
    for nm in res:
        if nm not in store:
            store.append(nm)

for x in store:
    fw.write(x + &#39;\n&#39;)
fw.close()
fh.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面脚本运行结束之后，就能得到想要的公司列表。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>新生の大学分享</title>
      <link>https://wanakiki.github.io/2019/univ-share/</link>
      <pubDate>Fri, 30 Aug 2019 22:54:12 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/univ-share/</guid>
      <description>

&lt;p&gt;可能很多人都会问怎么样才能过好自己的大学生活，但是当我想要去总结自己大学以来的经验，首先想到的大部分都是自己的遗憾，提不出来什么有价值的建议。&lt;/p&gt;

&lt;p&gt;今年的新生由我来带，借此机会整理一下之前在于老师那里听到的分享，希望能对他人带来一些启发。（当然这部分内容对于19级来说是新老生交流一部分。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;blockquote&gt;
&lt;p&gt;文章观点取自于老师的分享，暂时未询问其本人意见。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;总的来看，大学可以分为三个阶段，前三学期为一阶段，大二下及大三上为一阶段，大三下及整个大四为一阶段。&lt;/p&gt;

&lt;h2 id=&#34;大学的前三个学期&#34;&gt;大学的前三个学期&lt;/h2&gt;

&lt;p&gt;从高中来到大学这个小社会，绝大部分学生，尤其是像我一样的山东考生，适应大学着实需要一定的时期。大学的生活和高中有太多不同，步入大学也会发现周围的人有各种各样的追求，如何快速适应新的环境、找到新的目标是这个阶段首要解决的问题。&lt;/p&gt;

&lt;p&gt;从大学的课程设定也可以看出，对于大部分专业的学生来说前三个学期都是打基础的过程，这个时期学习的课程主要是为自身专业化的发展打下基础，为未来的专业课程做准备。&lt;/p&gt;

&lt;p&gt;对于理工科专业，高数真的是步入大学之后最大的难题，本身高中和大学数学课程的交接设定的就不合理，高中课本与大学课本衔接程度不高，而这个时候的大学生们还在享受着自己刚刚拥有的“自由”，高数的学习时间不是很充分。最终自然导致了学习效果较差，对今后的专业课学习也会带来不利影响。这点个人深有体会。&lt;/p&gt;

&lt;p&gt;美国的本科生没有设立医学专业，学医的研究生都是从生物专业的本科生选拔而来，对这部分医学专业的学生来说，他们的适应时期是整个本科。&lt;/p&gt;

&lt;h2 id=&#34;大二下-大三上&#34;&gt;大二下，大三上&lt;/h2&gt;

&lt;p&gt;对于想要走最多人走的路的那些人，这个时期的重点在&lt;strong&gt;科研&lt;/strong&gt;。因为经过了前三个学期的学习，理论上每个人都已经掌握了基本的专业知识，可以试着以本科生的身份加入一些实验室，提前了解实验室。&lt;/p&gt;

&lt;p&gt;最佳的方案是在大二上学期的寒假或者更早就确定好方向，及时地联系老师并进行一定科研知识的学习。但是要注意的是，加入一个实验室是一件很慎重的事情，不能因为自己的一时冲动或者是好奇才去报名。你的动机会决定你最终的成就，如果你没有下好决定不如再进行一定时间的观望。&lt;/p&gt;

&lt;p&gt;进入实验室后，要避免成为工人，在大学最好要学会如何与他人交流，积极主动的人往往会获得更多的机遇。毕竟现在还是本科生，和实验室的研究生总会有一些代沟，你可能过了几个月之后还会独自一人在角落里研究一些常识性的问题。如果有这种情况，不如从一开始就和一个研究生学长学姐保持好关系，很多简单的问题可以去问学长学姐，但不是很适合去问老师。&lt;/p&gt;

&lt;h2 id=&#34;大三下以及大四&#34;&gt;大三下以及大四&lt;/h2&gt;

&lt;p&gt;如果你能够完成此前的计划，这一阶段将会成为收获的阶段。&lt;del&gt;原谅我笑了&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;大家的去向有下面几种：&lt;/p&gt;

&lt;h3 id=&#34;保研&#34;&gt;保研&lt;/h3&gt;

&lt;p&gt;整体推免比例大概有10~15%，分下面几种情况&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;普通推免：满足成绩要求，并且六级达到426分。&lt;/li&gt;
&lt;li&gt;科技竞赛：在本校，要求专业前50%并且通过四级。国二及以上的奖项可用于竞赛保研。但满足推免条件的竞赛具有不确定性。&lt;/li&gt;
&lt;li&gt;特殊学术专长：SI EI第一作者，专业前50%，通过六级。&lt;/li&gt;
&lt;li&gt;研究生支教团：支教一年，对个人的志愿服务经历有要求。&lt;/li&gt;
&lt;li&gt;在职研究生：中共党员+四级&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;考研&#34;&gt;考研&lt;/h3&gt;

&lt;p&gt;考研比例大概占毕业生的35~40%，且有一定数量的二战人员。考研有很多相关的复习计划，在这里不列出。&lt;/p&gt;

&lt;h3 id=&#34;出国&#34;&gt;出国&lt;/h3&gt;

&lt;p&gt;实验室经历可能更有帮助。&lt;/p&gt;

&lt;h3 id=&#34;主动就业&#34;&gt;主动就业&lt;/h3&gt;

&lt;p&gt;在假期参加实习，尽早规划尽早行动。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PY4E 题目整理（下）</title>
      <link>https://wanakiki.github.io/2019/python-assignments/</link>
      <pubDate>Mon, 05 Aug 2019 18:29:25 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/python-assignments/</guid>
      <description>

&lt;p&gt;Coursera中python教程同步题目整理，涉及到网络和数据库编程部分。题目地址：&lt;a href=&#34;https://www.py4e.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;py4e&lt;/a&gt;。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;blockquote&gt;
&lt;p&gt;打开网页的操作步骤，导入urllib库，urllib.requert.urlopen(url).read()
可以直接对字典进行url编码 urllib.parse.urlencode(parms)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;exploring-the-hypert-ext-transport-protocol-探索超文本传输协议&#34;&gt;Exploring the HyperT ext Transport Protocol（探索超文本传输协议）&lt;/h2&gt;

&lt;p&gt;You are to retrieve the following document using the HTTP protocol in a way that you can examine the HTTP Response headers.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://data.pr4e.org/intro-short.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://data.pr4e.org/intro-short.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There are three ways that you might retrieve this web page and look at the response headers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Preferred: Modify the socket1.py program to retrieve the above URL and print out the headers and data. Make sure to change the code to retrieve the above URL - the values are different for each URL.&lt;/li&gt;
&lt;li&gt;Open the URL in a web browser with a developer console or FireBug and manually examine the headers that are returned.&lt;/li&gt;
&lt;li&gt;Use the telnet program as shown in lecture to retrieve the headers and content.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Enter the header values in each of the fields below and press &amp;ldquo;Submit&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;有三种方式查看相应头文件，第一种方式是使用Python脚本，第二种方式是用浏览器打开URL，在控制台查看，第三种方式是使用telnet程序。仅列出了第一种的脚本。&lt;/p&gt;

&lt;p&gt;由于网络的原因这段代码没有成功进行测试，在设定socket命令时的&lt;code&gt;\r\n&lt;/code&gt;也不清楚具体的含义。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import socket

mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
mysock.connect((&#39;data.pr4e.org&#39;, 80))
print(&#39;connected&#39;)
cmd = &#39;GET http://data.pr4e.org/intro-short.txt HTTP/1.0\r\n\r\n&#39;.encode()
mysock.send(cmd)

while True:
    data = mysock.recv(512)
    if len(data) &amp;lt; 1:
        break
    print(data.decode(), end=&#39;&#39;)
mysock.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;scraping-numbers-from-html-using-beautifulsoup&#34;&gt;Scraping Numbers from HTML using BeautifulSoup&lt;/h2&gt;

&lt;p&gt;In this assignment you will write a Python program similar to &lt;a href=&#34;http://www.py4e.com/code3/urllink2.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/urllink2.py&lt;/a&gt;. The program will use urllib to read the HTML from the data files below, and parse the data, extracting numbers and compute the sum of the numbers in the file.&lt;/p&gt;

&lt;p&gt;We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sample data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_42.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_42.html&lt;/a&gt; (Sum=2553)&lt;/li&gt;
&lt;li&gt;Actual data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_275913.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_275913.html&lt;/a&gt; (Sum ends with 37)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You do not need to save these files to your folder since your program will read the data directly from the URL.&lt;/p&gt;

&lt;h3 id=&#34;data-format&#34;&gt;Data Format&lt;/h3&gt;

&lt;p&gt;The file is a table of names and comment counts. You can ignore most of the data in the file except for lines like the following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Modu&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span class=&amp;quot;comments&amp;quot;&amp;gt;90&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Kenzie&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span class=&amp;quot;comments&amp;quot;&amp;gt;88&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;Hubert&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;&amp;lt;span class=&amp;quot;comments&amp;quot;&amp;gt;87&amp;lt;/span&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析网页，计算网页中数字的总和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 抓取网站中的数据并计算数据总和
import urllib.request
import urllib.parse
import urllib.error
from bs4 import BeautifulSoup


url = &#39;http://python-data.dr-chuck.net/comments_275913.html&#39;
html = urllib.request.urlopen(url).read()
soup = BeautifulSoup(html, &#39;html.parser&#39;)

span = soup(&#39;span&#39;)
res = 0
for aspan in span:
    res = res + int(aspan.get_text())

print(&#39;结果为&#39;, res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;following-links-in-python&#34;&gt;Following Links in Python&lt;/h2&gt;

&lt;p&gt;In this assignment you will write a Python program that expands on &lt;a href=&#34;http://www.py4e.com/code3/urllinks.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/urllinks.py&lt;/a&gt;. The program will use urllib to read the HTML from the data files below, extract the href= vaues from the anchor tags, scan for a tag that is in a particular position relative to the first name in the list, follow that link and repeat the process a number of times and report the last name you find.&lt;/p&gt;

&lt;p&gt;We provide two files for this assignment. One is a sample file where we give you the name for your testing and the other is the actual data you need to process for the assignment&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sample problem: Start at &lt;a href=&#34;http://py4e-data.dr-chuck.net/known_by_Fikret.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/known_by_Fikret.html&lt;/a&gt;
Find the link at position 3 (the first name is 1). Follow that link. Repeat this process 4 times. The answer is the last name that you retrieve.
Sequence of names: Fikret Montgomery Mhairade Butchi Anayah
Last name in sequence: Anayah&lt;/li&gt;
&lt;li&gt;Actual problem: Start at: &lt;a href=&#34;http://py4e-data.dr-chuck.net/known_by_Cohen.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/known_by_Cohen.html&lt;/a&gt;
Find the link at position 18 (the first name is 1). Follow that link. Repeat this process 7 times. The answer is the last name that you retrieve.
Hint: The first character of the name of the last page that you will load is: A&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;strategy&#34;&gt;Strategy&lt;/h3&gt;

&lt;p&gt;The web pages tweak the height between the links and hide the page after a few seconds to make it difficult for you to do the assignment without writing a Python program. But frankly with a little effort and patience you can overcome these attempts to make it a little harder to complete the assignment without writing a Python program. But that is not the point. The point is to write a clever Python program to solve the program.&lt;/p&gt;

&lt;h3 id=&#34;sample-execution&#34;&gt;Sample execution&lt;/h3&gt;

&lt;p&gt;Here is a sample execution of a solution:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;$ python3 solution.py
Enter URL: http://py4e-data.dr-chuck.net/known_by_Fikret.html
Enter count: 4
Enter position: 3
Retrieving: http://py4e-data.dr-chuck.net/known_by_Fikret.html
Retrieving: http://py4e-data.dr-chuck.net/known_by_Montgomery.html
Retrieving: http://py4e-data.dr-chuck.net/known_by_Mhairade.html
Retrieving: http://py4e-data.dr-chuck.net/known_by_Butchi.html
Retrieving: http://py4e-data.dr-chuck.net/known_by_Anayah.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The answer to the assignment for this execution is &amp;ldquo;Anayah&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;程序要求：从指定的链接开始，解析html页面，获取所有的herf标签，找到指定位置（position）的链接，重复这个过程指定次数（count)。最终输出找到的人名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 跟踪超链接，找到目标
import urllib.request
import urllib.parse
import urllib.error
from bs4 import BeautifulSoup

# 假定输入规范
count = int(input(&#39;Enter Count:&#39;))
position = int(input(&#39;Enter Position:&#39;)) - 1    #从1开始计算位置
flag = int(input(&#39;&#39;&#39;Select Url:
1: http://py4e-data.dr-chuck.net/known_by_Fikret.html
2: http://py4e-data.dr-chuck.net/known_by_Cohen.html
&#39;&#39;&#39;))

if flag == 1:
    url = &#39;http://py4e-data.dr-chuck.net/known_by_Fikret.html&#39;
else:
    url = &#39;http://py4e-data.dr-chuck.net/known_by_Cohen.html&#39;

while True:
    html = urllib.request.urlopen(url).read()   #打开界面
    soup = BeautifulSoup(html, &#39;html.parser&#39;)   #界面解析


    #界面链接的格式为 ``&amp;lt;a href = &amp;quot;xx.com&amp;quot;&amp;gt;&amp;lt;/a&amp;gt;``
    #应该提取a标签
    a_coll = soup(&#39;a&#39;)    #获取a标签集合 属于beautiful soup中的类型，应该是重载了括号，print(a_coll[0])支持这种访问
    href = a_coll[position].get(&#39;href&#39;, None)
    if href is None:
        print(&#39;runtime error&#39;)
        quit()

    if count &amp;gt; 1:
        count = count - 1
        url = href  # 更新url 以进一步抓取
    else:
        res = a_coll[position].get_text()   #获取内容
        break

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;extracting-data-from-xml&#34;&gt;Extracting Data from XML&lt;/h2&gt;

&lt;p&gt;In this assignment you will write a Python program somewhat similar to &lt;a href=&#34;http://www.py4e.com/code3/geoxml.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/geoxml.py&lt;/a&gt;. The program will prompt for a URL, read the XML data from that URL using urllib and then parse and extract the comment counts from the XML data, compute the sum of the numbers in the file.&lt;/p&gt;

&lt;p&gt;We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sample data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_42.xml&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_42.xml&lt;/a&gt; (Sum=2553)&lt;/li&gt;
&lt;li&gt;Actual data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_275915.xml&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_275915.xml&lt;/a&gt; (Sum ends with 24)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You do not need to save these files to your folder since your program will read the data directly from the URL. Note: Each student will have a distinct data url for the assignment - so only use your own data url for analysis.&lt;/p&gt;

&lt;h3 id=&#34;data-format-and-approach&#34;&gt;Data Format and Approach&lt;/h3&gt;

&lt;p&gt;The data consists of a number of names and comment counts in XML as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;&amp;lt;comment&amp;gt;
  &amp;lt;name&amp;gt;Matthias&amp;lt;/name&amp;gt;
  &amp;lt;count&amp;gt;97&amp;lt;/count&amp;gt;
&amp;lt;/comment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You are to look through all the &lt;code&gt;&amp;lt;comment&amp;gt;&lt;/code&gt; tags and find the &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; values sum the numbers. The closest sample code that shows how to parse XML is geoxml.py. But since the nesting of the elements in our data is different than the data we are parsing in that sample code you will have to make real changes to the code.&lt;/p&gt;

&lt;p&gt;To make the code a little simpler, you can use an XPath selector string to look through the entire tree of XML for any tag named &amp;lsquo;count&amp;rsquo; with the following line of code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;counts = tree.findall(&#39;.//count&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take a look at the Python ElementTree documentation and look for the supported XPath syntax for details. You could also work from the top of the XML down to the comments node and then loop through the child nodes of the comments node.&lt;/p&gt;

&lt;h3 id=&#34;sample-execution-1&#34;&gt;Sample Execution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;$ python3 solution.py
Enter location: http://py4e-data.dr-chuck.net/comments_42.xml
Retrieving http://py4e-data.dr-chuck.net/comments_42.xml
Retrieved 4189 characters
Count: 50
Sum: 2...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序要求：解析XML文件，计算整个文件中count标签的总和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import xml.etree.ElementTree as ET
import urllib.request
import urllib.parse
import urllib.error

url = &#39;http://py4e-data.dr-chuck.net/comments_275915.xml&#39;   # 指定URL
uh = urllib.request.urlopen(url)
data = uh.read()    #获取网页数据

print(&#39;Retrived&#39;, len(data), &#39;characters&#39;)
tree = ET.fromstring(data)
counts = tree.findall(&#39;.//count&#39;)   #查找count标签
# counts = tree.findall(&#39;comments/comment/count&#39;)
# 查找count可以使用上面这行语句

print(&#39;Count:&#39;, len(counts))

res = 0
for count in counts:
    res = res + int(count.text)

print(&#39;Sum:&#39;, res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;extracting-data-from-json&#34;&gt;Extracting Data from JSON&lt;/h2&gt;

&lt;p&gt;In this assignment you will write a Python program somewhat similar to &lt;a href=&#34;http://www.py4e.com/code3/json2.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/json2.py&lt;/a&gt;. The program will prompt for a URL, read the JSON data from that URL using urllib and then parse and extract the comment counts from the JSON data, compute the sum of the numbers in the file and enter the sum below:&lt;/p&gt;

&lt;p&gt;We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sample data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_42.json&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_42.json&lt;/a&gt; (Sum=2553)&lt;/li&gt;
&lt;li&gt;Actual data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/comments_275916.json&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/comments_275916.json&lt;/a&gt; (Sum ends with 15)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You do not need to save these files to your folder since your program will read the data directly from the URL. Note: Each student will have a distinct data url for the assignment - so only use your own data url for analysis.&lt;/p&gt;

&lt;h3 id=&#34;data-format-1&#34;&gt;Data Format&lt;/h3&gt;

&lt;p&gt;The data consists of a number of names and comment counts in JSON as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  comments: [
    {
      name: &amp;quot;Matthias&amp;quot;
      count: 97
    },
    {
      name: &amp;quot;Geomer&amp;quot;
      count: 97
    }
    ...
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The closest sample code that shows how to parse JSON and extract a list is json2.py. You might also want to look at geoxml.py to see how to prompt for a URL and retrieve data from a URL.&lt;/p&gt;

&lt;h3 id=&#34;sample-execution-2&#34;&gt;Sample Execution&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;$ python3 solution.py
Enter location: http://py4e-data.dr-chuck.net/comments_42.json
Retrieving http://py4e-data.dr-chuck.net/comments_42.json
Retrieved 2733 characters
Count: 50
Sum: 2...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解析JSON文件，获得count的总和。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import urllib.request, urllib.error, urllib.parse
import json     #导入json

# - Sample data: http://py4e-data.dr-chuck.net/comments_42.json (Sum=2553)
# - Actual data: http://py4e-data.dr-chuck.net/comments_275916.json (Sum ends with 15)

url = input(&#39;Enter url &#39;)
print(&#39;Retriving&#39;, url)
uh = urllib.request.urlopen(url).read()
print(&#39;Retrived&#39;, len(uh), &#39;characters&#39;)

js = json.loads(uh)
# 观察文档结构，js为字典，js[&#39;comments&#39;]为由字典组成的list

res = 0
for comment in js[&#39;comments&#39;]:
    res = res + comment[&#39;count&#39;]

print(&#39;Sum:&#39;, res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;calling-a-json-api&#34;&gt;Calling a JSON API&lt;/h2&gt;

&lt;p&gt;In this assignment you will write a Python program somewhat similar to &lt;a href=&#34;http://www.py4e.com/code3/geojson.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/geojson.py&lt;/a&gt;. The program will prompt for a location, contact a web service and retrieve JSON for the web service and parse that data, and retrieve the first place_id from the JSON. A place ID is a textual identifier that uniquely identifies a place as within Google Maps.&lt;/p&gt;

&lt;h3 id=&#34;api-end-points&#34;&gt;API End Points&lt;/h3&gt;

&lt;p&gt;To complete this assignment, you should use this API endpoint that has a static subset of the Google Data:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;http://py4e-data.dr-chuck.net/json?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This API uses the same parameter (address) as the Google API. This API also has no rate limit so you can test as often as you like. If you visit the URL with no parameters, you get &amp;ldquo;No address&amp;hellip;&amp;rdquo; response.&lt;/p&gt;

&lt;p&gt;To call the API, you need to provide the address that you are requesting as the address= parameter that is properly URL encoded using the urllib.parse.urlencode() function as shown in &lt;a href=&#34;http://www.py4e.com/code3/geojson.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/geojson.py&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;test-data-sample-execution&#34;&gt;Test Data / Sample Execution&lt;/h3&gt;

&lt;p&gt;You can test to see if your program is working with a location of &amp;ldquo;South Federal University&amp;rdquo; which will have a place_id of &amp;ldquo;ChIJ9e_QQm0sDogRhUPatldEFxw&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;$ python3 solution.py
Enter location: South Federal University
Retrieving http://...
Retrieved 2291 characters
Place id ChIJ9e_QQm0sDogRhUPatldEFxw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用谷歌API查询指定地点的&lt;code&gt;place id&lt;/code&gt;，因为谷歌地图API现在需要验证，所以最好使用PY4E提供的副本。需要注意，使用py4e提供的副本时，需要额外传递一个key参数，这点在作业说明中没有指出，查看代码包中的代码之后才发现这个值为42，&lt;a href=&#34;http://www.py4e.com/code3/geojson.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/geojson.py&lt;/a&gt; 具体见这个链接。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import urllib.error, urllib.request, urllib.parse
import json

target = &#39;http://py4e-data.dr-chuck.net/json?&#39;  #使用这个接口，需要 key参数且值为42
local = input(&#39;Enter location: &#39;)

url = target + urllib.parse.urlencode({&#39;address&#39;: local, &#39;key&#39; : 42})
#对字符串进行url编码，直接传递参数和值构成的字典
print(&#39;Retriving&#39;, url)

data = urllib.request.urlopen(url).read()
print(&#39;Retrived&#39;, len(data), &#39;characters&#39;)

js = json.loads(data)
# print(json.dumps(js, indent = 4)) #查看接收到的文件结构
print(&#39;Place id&#39;, js[&#39;results&#39;][0][&#39;place_id&#39;])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;counting-organizations&#34;&gt;Counting Organizations&lt;/h2&gt;

&lt;p&gt;This application will read the mailbox data (mbox.txt) and count the number of email messages per organization (i.e. domain name of the email address) using a database with the following schema to maintain the counts.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;CREATE TABLE Counts (org TEXT, count INTEGER)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you have run the program on mbox.txt upload the resulting database file above for grading.&lt;/p&gt;

&lt;p&gt;If you run the program multiple times in testing or with dfferent files, make sure to empty out the data before each run.&lt;/p&gt;

&lt;p&gt;You can use this code as a starting point for your application: &lt;a href=&#34;http://www.py4e.com/code3/emaildb.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/emaildb.py&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The data file for this application is the same as in previous assignments: &lt;a href=&#34;http://www.py4e.com/code3/mbox.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/mbox.txt&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Because the sample code is using an UPDATE statement and committing the results to the database as each record is read in the loop, it might take as long as a few minutes to process all the data. The commit insists on completely writing all the data to disk every time it is called.&lt;/p&gt;

&lt;p&gt;The program can be speeded up greatly by moving the commit operation outside of the loop. In any database program, there is a balance between the number of operations you execute between commits and the importance of not losing the results of operations that have not yet been committed.&lt;/p&gt;

&lt;p&gt;此前做过的统计文本文件中每个人发送的邮件数目的升级版，统计各个公司服务器域名发送的邮件总数，将最终找到的结果保存到了数据库中。需要注意，提交sql查询时为了加快速度要放在循环外部。如何使用SQL可见&lt;a href=&#34;https://docs.python.org/zh-cn/3/library/sqlite3.html#module-sqlite3&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlite3

conn = sqlite3.connect(&#39;mail-count.sqlite&#39;)
cur = conn.cursor()

cur.execute(&#39;DROP TABLE IF EXISTS Counts&#39;)  # 如果存在就提前删除表
cur.execute(&#39;&#39;&#39;CREATE TABLE Counts (org TEXT, count INTEGER)&#39;&#39;&#39;)    # 创建表

fh = open(&#39;mbox.txt&#39;)
for line in fh:
    if not line.startswith(&#39;From:&#39;):
        continue
    mail = line.split()[1]
    index = mail.find(&#39;@&#39;)+1
    org = mail[index:]

    # 针对org执行sql后续操作，先查询再决定更新还是插入
    cur.execute(&#39;&#39;&#39;SELECT count FROM Counts WHERE org = ?&#39;&#39;&#39;, (org,) ) #execute函数第二个参数需要是元组
    num = cur.fetchone()    #返回list，查询不到时返回None

    if num is None:
        cur.execute(&#39;INSERT INTO Counts(org, count) VALUES(?, 1)&#39;, (org, ))
    else:
        cur.execute(&#39;UPDATE Counts SET count = ? WHERE org = ?&#39;, (num[0] + 1, org))
        # 在进行更新时可以直接 count = count + 1

conn.commit()   #提交放在循环外加速
cur.execute(&#39;SELECT * FROM Counts ORDER BY count DESC LIMIT 1&#39;)
print(cur.fetchone())
cur.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;musical-track-database&#34;&gt;Musical Track Database&lt;/h2&gt;

&lt;p&gt;This application will read an iTunes export file in XML and produce a properly normalized database with this structure:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE Artist (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name    TEXT UNIQUE
);

CREATE TABLE Genre (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name    TEXT UNIQUE
);

CREATE TABLE Album (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    artist_id  INTEGER,
    title   TEXT UNIQUE
);

CREATE TABLE Track (
    id  INTEGER NOT NULL PRIMARY KEY
        AUTOINCREMENT UNIQUE,
    title TEXT  UNIQUE,
    album_id  INTEGER,
    genre_id  INTEGER,
    len INTEGER, rating INTEGER, count INTEGER
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run the program multiple times in testing or with different files, make sure to empty out the data before each run.&lt;/p&gt;

&lt;p&gt;You can use this code as a starting point for your application: &lt;a href=&#34;http://www.py4e.com/code3/tracks.zip&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/tracks.zip&lt;/a&gt;. The ZIP file contains the Library.xml file to be used for this assignment. You can export your own tracks from iTunes and create a database, but for the database that you turn in for this assignment, only use the Library.xml data that is provided.&lt;/p&gt;

&lt;p&gt;To grade this assignment, the program will run a query like this on your uploaded database and look for the data it expects to see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT Track.title, Artist.name, Album.title, Genre.name
    FROM Track JOIN Genre JOIN Album JOIN Artist
    ON Track.genre_id = Genre.ID and Track.album_id = Album.id
        AND Album.artist_id = Artist.id
    ORDER BY Artist.name LIMIT 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The expected result of the modified query on your database is: (shown here as a simple HTML table with titles)&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Track&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Artist&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Album&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Genre&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Chase the Ace&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AC/DC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Who Made Who&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Rock&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;D.T.&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AC/DC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Who Made Who&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Rock&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;For Those About To Rock (We Salute You)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AC/DC&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Who Made Who&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Rock&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sqlite3
import xml.etree.ElementTree as ET

conn = sqlite3.connect(&#39;music.sqlite&#39;)
cur = conn.cursor()

cur.executescript(&#39;&#39;&#39;
DROP TABLE IF EXISTS Artist;
DROP TABLE IF EXISTS Genre;
DROP TABLE IF EXISTS Album;
DROP TABLE IF EXISTS Track;&#39;&#39;&#39;) 
#如果存在就先删除表
# 执行多条查询需要 executescript

cur.executescript(&#39;&#39;&#39;CREATE TABLE Artist (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name    TEXT UNIQUE
);

CREATE TABLE Genre (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name    TEXT UNIQUE
);

CREATE TABLE Album (
    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    artist_id  INTEGER,
    title   TEXT UNIQUE
);

CREATE TABLE Track (
    id  INTEGER NOT NULL PRIMARY KEY 
        AUTOINCREMENT UNIQUE,
    title TEXT  UNIQUE,
    album_id  INTEGER,
    genre_id  INTEGER,
    len INTEGER, rating INTEGER, count INTEGER
);&#39;&#39;&#39;)  # 执行多行时注意使用三个引号

file_name = &#39;Library.xml&#39;
fh = open(file_name)
tree = ET.fromstring(fh.read())
dicts = tree.findall(&#39;./dict/dict/dict&#39;)

# 查看xml文件，分析目录树结构 需要在/dict/dict/dict内查找字段
# 定义查找函数
def lookup(pare, aim):
    flag = False
    for child in pare:
        if flag:
            return child.text
        if child.tag == &#39;key&#39; and child.text == aim:
            flag = True
    return None

# 通过构建的数据库情况，需要查找的字段为
# Track ID   Name    Artist     Album   Play Count  Rating  Total Time

for entry in dicts:
    if(lookup(entry, &#39;Track ID&#39;) is None):  continue
    name = lookup(entry, &#39;Name&#39;)
    artist = lookup(entry, &#39;Artist&#39;)
    album = lookup(entry, &#39;Album&#39;)
    count = lookup(entry, &#39;Play Count&#39;)
    rating = lookup(entry, &#39;Rating&#39;)
    length = lookup(entry, &#39;Total Time&#39;)
    genre = lookup(entry, &#39;Genre&#39;)

    if name is None or artist is None or album is None or genre is None:
        continue
    print(name, artist, album, count, rating, length)

    # 根据建立数据库的顺序进行插入，并获取外键对应的id值
    # 注意对于唯一元素插入时使用ignore
    cur.execute(&#39;&#39;&#39;INSERT OR IGNORE INTO Artist(name) VALUES(?)&#39;&#39;&#39;, (artist,))
    cur.execute(&#39;SELECT id FROM Artist WHERE name = ?&#39;, (artist,))
    artist_id = cur.fetchone()[0]   # 查询返回的是数组

    cur.execute(&#39;INSERT OR IGNORE INTO Genre(name) VALUES(?)&#39;, (genre,))
    cur.execute(&#39;SELECT id FROM Genre WHERE name = ?&#39;,(genre,))
    genre_id = cur.fetchone()[0]

    cur.execute(&#39;INSERT OR IGNORE INTO Album(artist_id, title) VALUES(?, ?)&#39;,(artist_id, album))
    cur.execute(&#39;SELECT id FROM Album WHERE title = ?&#39;, (album,))
    album_id = cur.fetchone()[0]

    # 至于这里为什么要用replace原因不知
    cur.execute(&#39;&#39;&#39;INSERT OR REPLACE INTO Track(title, album_id, genre_id, len, rating, count) 
    VALUES(?, ?, ?, ?, ?, ?)&#39;&#39;&#39;,(name, album_id, genre_id, length, rating, count))

conn.commit()
cur.execute(&#39;&#39;&#39;SELECT Track.title, Artist.name, Album.title, Genre.name
    FROM Track JOIN Genre JOIN Album JOIN Artist
    ON Track.genre_id = Genre.ID and Track.album_id = Album.id
        AND Album.artist_id = Artist.id
    ORDER BY Artist.name LIMIT 3&#39;&#39;&#39;)
res = cur.fetchall()
for line in res:
    print(line)
cur.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然执行之后结果和示例结果不一样，但是个人认为程序没有错误。&lt;/p&gt;

&lt;h2 id=&#34;make-database-from-json&#34;&gt;Make database from JSON&lt;/h2&gt;

&lt;p&gt;This application will read roster data in JSON format, parse the file, and then produce an SQLite database that contains a User, Course, and Member table and populate the tables from the data file.&lt;/p&gt;

&lt;p&gt;You can base your solution on this code: &lt;a href=&#34;http://www.py4e.com/code3/roster/roster.py&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/roster/roster.py&lt;/a&gt; - this code is incomplete as you need to modify the program to store the &lt;strong&gt;role&lt;/strong&gt; column in the &lt;strong&gt;Member&lt;/strong&gt; table to complete the assignment.&lt;/p&gt;

&lt;p&gt;Each student gets their own file for the assignment. Download this file and save it as &lt;code&gt;roster_data.json&lt;/code&gt;. Move the downloaded file into the same folder as your &lt;code&gt;roster.py&lt;/code&gt; program.&lt;/p&gt;

&lt;p&gt;Once you have made the necessary changes to the program and it has been run successfully reading the above JSON data, run the following SQL command:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT hex(User.name || Course.title || Member.role ) AS X FROM
    User JOIN Member JOIN Course
    ON User.id = Member.user_id AND Member.course_id = Course.id
    ORDER BY X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find the first row in the resulting record set and enter the long string that looks like 53656C696E613333.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import json
import sqlite3

conn = sqlite3.connect(&#39;rosterdb.sqlite&#39;)
cur = conn.cursor()

# 建立数据库
cur.executescript(&#39;&#39;&#39;
DROP TABLE IF EXISTS User;
DROP TABLE IF EXISTS Member;
DROP TABLE IF EXISTS Course;

CREATE TABLE User (
    id     INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    name   TEXT UNIQUE
);

CREATE TABLE Course (
    id     INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,
    title  TEXT UNIQUE
);

CREATE TABLE Member (
    user_id     INTEGER,
    course_id   INTEGER,
    role        INTEGER,
    PRIMARY KEY (user_id, course_id)
)
&#39;&#39;&#39;)


file_name = input(&#39;Enter filename: &#39;)
if(len(file_name) &amp;lt; 1):
    file_name = &#39;roster_data.json&#39;
fh = open(file_name).read()
js = json.loads(fh)

for record in js:
    name = record[0]
    title = record[1]
    role = record[2]

    cur.execute(&#39;INSERT OR IGNORE INTO User(name) VALUES(?)&#39;, (name,))
    cur.execute(&#39;SELECT id FROM User WHERE name = ?&#39;, (name,))
    user_id = cur.fetchone()[0]

    cur.execute(&#39;INSERT OR IGNORE INTO Course(title) VALUES(?)&#39;, (title,))
    cur.execute(&#39;SELECT id FROM Course WHERE title = ?&#39;, (title,))
    course_id = cur.fetchone()[0]

    cur.execute(&#39;INSERT OR REPLACE INTO Member(user_id, course_id, role) VALUES(?,?,?)&#39;, (user_id, course_id, role))

cur.execute(&#39;&#39;&#39;SELECT hex(User.name || Course.title || Member.role ) AS X FROM 
    User JOIN Member JOIN Course 
    ON User.id = Member.user_id AND Member.course_id = Course.id
    ORDER BY X LIMIT 5&#39;&#39;&#39;)
res = cur.fetchall()
for line in res:
    print(line)

conn.commit()
cur.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多对多关系示例。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PY4E 题目整理（上）</title>
      <link>https://wanakiki.github.io/2019/python-assignment/</link>
      <pubDate>Sun, 04 Aug 2019 17:39:49 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/python-assignment/</guid>
      <description>

&lt;p&gt;Coursera中python教程同步题目整理，因为旁听课程不能直接对每章的编程作业进行提交，学到中期之后才发现&lt;a href=&#34;https://www.py4e.com/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;py4e&lt;/a&gt;上有几乎所有题目的在线测试环境，在看完所有的教学视频之后重新刷题，回顾知识点，在此进行整理。分为基础部分和网络及数据库编程部分。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;hello-world&#34;&gt;Hello world&lt;/h2&gt;

&lt;h3 id=&#34;problem&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Write a program that uses a print statement to say &amp;lsquo;hello world&amp;rsquo; as shown in &amp;lsquo;Desired Output&amp;rsquo;.&lt;/p&gt;

&lt;h3 id=&#34;code&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; print(&#39;hello world&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;回顾&#34;&gt;回顾&lt;/h3&gt;

&lt;p&gt;Python中字符串可以用四种引号组合进行标注：&lt;code&gt;&#39; &amp;quot; &#39;&#39;&#39; &amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;，其中单独的单引或者双引可以使引号内部不同的引号不需要进行转义，如&lt;code&gt;&amp;quot;this is &#39;a&#39; test&amp;quot;&lt;/code&gt;中的单引号就不需要进行转义。三个单引号和双引号具有相同的作用，可以保证被定义的字符串原封不动地输出（一般定义多行），在后面执行SQL语句时有用到。同时其中的单引号或者双引号不需要转义。&lt;/p&gt;

&lt;h2 id=&#34;2-3&#34;&gt;2-3&lt;/h2&gt;

&lt;h3 id=&#34;problem-1&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Write a program to prompt the user for hours and rate per hour using input to compute gross pay. Use 35 hours and a rate of 2.75 per hour to test the program (the pay should be 96.25). You should use input to read a string and float() to convert the string to a number. Do not worry about error checking or bad user data.&lt;/p&gt;

&lt;p&gt;根据输入的时间和工资标准计算总工资，并输出。假定时间为35小时，工资标准为2.75每小时，标准结果应为96.25。&lt;/p&gt;

&lt;h3 id=&#34;desired-output&#34;&gt;Desired Output&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;Pay: 96.25
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;code-1&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# This first line is provided for you

hrs = input(&amp;quot;Enter Hours:&amp;quot;)
hrs = float(hrs)

rate = float(input(&amp;quot;Enter Rate:&amp;quot;))
print(&#39;Pay:&#39;, hrs * rate)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-1&#34;&gt;3-1&lt;/h2&gt;

&lt;h3 id=&#34;problem-2&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Write a program to prompt the user for hours and rate per hour using input to compute gross pay. Pay the hourly rate for the hours up to 40 and 1.5 times the hourly rate for all hours worked above 40 hours. Use 45 hours and a rate of 10.50 per hour to test the program (the pay should be 498.75). You should use input to read a string and float() to convert the string to a number. Do not worry about error checking the user input - assume the user types numbers properly.&lt;/p&gt;

&lt;p&gt;根据时长和工资标准计算工资，工作时间大于40小时的部分需要付1.5倍工资，标准输入为45，10.5，标准输出为498.75。&lt;/p&gt;

&lt;h3 id=&#34;code-2&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hrs = input(&amp;quot;Enter Hours:&amp;quot;)
h = float(hrs)

rate = float(input(&amp;quot;Enter Rates:&amp;quot;))
if h &amp;gt; 40:
    res = 40 * rate + (h - 40) * rate * 1.5
else:
    res = rate * 40
print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-3&#34;&gt;3-3&lt;/h2&gt;

&lt;h3 id=&#34;program&#34;&gt;Program&lt;/h3&gt;

&lt;p&gt;Write a program to prompt for a score between 0.0 and 1.0. If the score is out of range, print an error. If the score is between 0.0 and 1.0, print a grade using the following table:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Score&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Grade&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;= 0.9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;A&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;= 0.8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;= 0.7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;C&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;gt;= 0.6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;D&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&amp;lt; 0.6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;F&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If the user enters a value out of range, print a suitable error message and exit. For the test, enter a score of 0.85.&lt;/p&gt;

&lt;p&gt;按照表格输出对应的级别，要求输入在0到1，越界输出错误信息，假定输入为0.85。&lt;/p&gt;

&lt;h3 id=&#34;code-3&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;score = input(&amp;quot;Enter Score: &amp;quot;)
grade = [&#39;D&#39;,&#39;C&#39;,&#39;B&#39;,&#39;A&#39;]

try:
    score = float(score)
except:
    print(&#39;输入不是浮点数&#39;)
    quit()

if score &amp;lt; 0 or score &amp;gt; 1:
    print(&#39;输入不在指定范围&#39;)
    quit()

score = int(score * 10)

if score &amp;lt; 6:
    print(&#39;F&#39;)
elif score &amp;gt; 9:
    print(&#39;A&#39;)
else:
    print(grade[score-6])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;没有用那么多的判断，使用了一个list。&lt;/p&gt;

&lt;h2 id=&#34;4-6&#34;&gt;4-6&lt;/h2&gt;

&lt;h3 id=&#34;problem-3&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Write a program to prompt the user for hours and rate per hour using input to compute gross pay. Pay should be the normal rate for hours up to 40 and time-and-a-half for the hourly rate for all hours worked above 40 hours. Put the logic to do the computation of pay in a function called computepay() and use the function to do the computation. The function should return a value. Use 45 hours and a rate of 10.50 per hour to test the program (the pay should be 498.75). You should use input to read a string and float() to convert the string to a number. Do not worry about error checking the user input unless you want to - you can assume the user types numbers properly. Do not name your variable sum or use the sum() function.&lt;/p&gt;

&lt;p&gt;使用函数计算&lt;a href=&#34;#3-1&#34;&gt;3-1问题&lt;/a&gt;，假定输入规范，测试输入为45h，10.5，标准结果为498.75。&lt;/p&gt;

&lt;h3 id=&#34;code-4&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def computepay(h, r):
    if h &amp;lt;= 40:
        return h * r
    else:
        return 40 * r + (h - 40) * r * 1.5


hrs = input(&amp;quot;Enter Hours:&amp;quot;)
hrs = float(hrs)
rat = float(input(&amp;quot;Enter Rates:&amp;quot;))

p = computepay(hrs, rat)
print(p)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;5-2&#34;&gt;5-2&lt;/h2&gt;

&lt;h3 id=&#34;problem-4&#34;&gt;Problem&lt;/h3&gt;

&lt;p&gt;Write a program that repeatedly prompts a user for integer numbers until the user enters &amp;lsquo;done&amp;rsquo;. Once &amp;lsquo;done&amp;rsquo; is entered, print out the largest and smallest of the numbers. If the user enters anything other than a valid number catch it with a try/except and put out an appropriate message and ignore the number. Enter 7, 2, bob, 10, and 4 and match the output below.&lt;/p&gt;

&lt;p&gt;写一个程序监测用户输入的整数，直到用户输入“done”程序停止，之后程序输出这批数字的最大值和最小值。需要对输入进行检测，对于不合法的输入需要输出&lt;code&gt;Invalid input&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;code-5&#34;&gt;Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;largest = None
smallest = None
while True:
    num = input(&amp;quot;Enter a number: &amp;quot;)
    if num == &amp;quot;done&amp;quot;:
        break

    try:
        num = int(num)
    except:
        print(&#39;Invalid input&#39;)
        continue

    if largest is None:
        largest = num
        smallest = num
    else:
        if largest &amp;lt; num:
            largest = num
        if smallest &amp;gt; num:
            smallest = num

print(&amp;quot;Maximum is&amp;quot;, largest)
print(&amp;quot;Minimum is&amp;quot;, smallest)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;6-5&#34;&gt;6-5&lt;/h2&gt;

&lt;p&gt;Write code using find() and string slicing (see section 6.10) to extract the number at the end of the line below. Convert the extracted value to a floating point number and print it out.&lt;/p&gt;

&lt;p&gt;通过find和切片截取字符串中的浮点数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;text = &amp;quot;X-DSPAM-Confidence:    0.8475&amp;quot;
index = text.find(&#39;0&#39;)

res = float(text[index:])
print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;7-2&#34;&gt;7-2&lt;/h2&gt;

&lt;p&gt;Write a program that prompts for a file name, then opens that file and reads through the file, looking for lines of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;X-DSPAM-Confidence:    0.8475
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Count these lines and extract the floating point values from each of the lines and compute the average of those values and produce an output as shown below. Do not use the sum() function or a variable named sum in your solution.&lt;/p&gt;

&lt;p&gt;You can download the sample data at &lt;a href=&#34;http://www.py4e.com/code3/mbox-short.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/mbox-short.txt&lt;/a&gt; when you are testing below enter mbox-short.txt as the file name.&lt;/p&gt;

&lt;p&gt;文件操作，提取指定格式行的数据，并计算平均值。标准输出为&lt;code&gt;Average spam confidence: 0.750718518519&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def getNumber(line : str):
    index = line.find(&#39;:&#39;) + 1  #查找冒号更加合适
    return float(line[index:])

# Use the file name mbox-short.txt as the file name
fname = input(&amp;quot;Enter file name: &amp;quot;)
if len(fname) &amp;lt; 1:
    fname = &#39;mbox-short.txt&#39;
fh = open(fname)

Sum = 0
num = 0
for line in fh:
    if not line.startswith(&amp;quot;X-DSPAM-Confidence:&amp;quot;):
        continue
    Sum = Sum + getNumber(line.rstrip())
    num = num + 1

print(&#39;Average spam confidence:&#39;, Sum / num)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;8-4&#34;&gt;8-4&lt;/h2&gt;

&lt;p&gt;Open the file romeo.txt and read it line by line. For each line, split the line into a list of words using the split() method. The program should build a list of words. For each word on each line check to see if the word is already in the list and if not append it to the list. When the program completes, sort and print the resulting words in alphabetical order.&lt;/p&gt;

&lt;p&gt;You can download the sample data at &lt;a href=&#34;http://www.py4e.com/code3/romeo.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/romeo.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;读取文件，统计其中出现过的单词，按字典序输出。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fname = input(&amp;quot;Enter file name: &amp;quot;)
if len(fname) &amp;lt; 1:
    fname = &#39;romeo.txt&#39;
fh = open(fname)
lst = list()

for line in fh:
    line = line.rstrip()
    words = line.split()

    for word in words:
        if word not in lst:
            lst.append(word)

lst.sort()
print(lst)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;8-5&#34;&gt;8-5&lt;/h2&gt;

&lt;p&gt;Open the file mbox-short.txt and read it line by line. When you find a line that starts with &amp;lsquo;From &amp;rsquo; like the following line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will parse the From line using split() and print out the second word in the line (i.e. the entire address of the person who sent the message). Then print out a count at the end.&lt;/p&gt;

&lt;p&gt;Hint: make sure not to include the lines that start with &amp;lsquo;From:&amp;lsquo;.&lt;/p&gt;

&lt;p&gt;You can download the sample data at &lt;a href=&#34;http://www.py4e.com/code3/mbox-short.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.py4e.com/code3/mbox-short.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;读文件，对其中&lt;code&gt;From&lt;/code&gt;开始的行，输出邮件来源并统计个数，在最后输出统计结果。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fname = input(&amp;quot;Enter file name: &amp;quot;)
if len(fname) &amp;lt; 1:
    fname = &amp;quot;mbox-short.txt&amp;quot;

fh = open(fname)
count = 0

for line in fh:
    if not line.startswith(&#39;From &#39;):
        continue
    line = line.split()
    print(line[1])
    count = count + 1

print(&amp;quot;There were&amp;quot;, count, &amp;quot;lines in the file with From as the first word&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;9-4&#34;&gt;9-4&lt;/h2&gt;

&lt;p&gt;Write a program to read through the mbox-short.txt and figure out who has sent the greatest number of mail messages. The program looks for &amp;lsquo;From &amp;rsquo; lines and takes the second word of those lines as the person who sent the mail. The program creates a Python dictionary that maps the sender&amp;rsquo;s mail address to a count of the number of times they appear in the file. After the dictionary is produced, the program reads through the dictionary using a maximum loop to find the most prolific committer.&lt;/p&gt;

&lt;p&gt;统计文件中的发信人行，使用字典存储每个人发送邮件的数目。最后使用一个最大for循环，查找到发送最多邮件的人。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;name = input(&amp;quot;Enter file:&amp;quot;)
if len(name) &amp;lt; 1:
    name = &amp;quot;mbox-short.txt&amp;quot;
handle = open(name)
res = dict()

for line in handle:
    if not line.startswith(&#39;From &#39;):
        continue

    line = line.split()
    author = line[1]
    res[author] = res.get(author, 0) + 1

name = None
count = None
for k, v in res.items():
    if count is None or v &amp;gt; count:
        count = v
        name = k

print(name, count)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;10-2&#34;&gt;10-2&lt;/h2&gt;

&lt;p&gt;Write a program to read through the mbox-short.txt and figure out the distribution by hour of the day for each of the messages. You can pull the hour out from the &amp;lsquo;From &amp;rsquo; line by finding the time and then splitting the string a second time using a colon.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;From stephen.marquard@uct.ac.za Sat Jan  5 09:14:16 2008
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once you have accumulated the counts for each hour, print out the counts, sorted by hour as shown below.&lt;/p&gt;

&lt;p&gt;统计各个时段中邮件的数目，存储到字典之中，最后按照时间顺序输出各个时间段对应的邮件数。（需要对dict进行排序）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;name = input(&amp;quot;Enter file:&amp;quot;)
if len(name) &amp;lt; 1 : name = &amp;quot;mbox-short.txt&amp;quot;
handle = open(name)

status = {}
for line in handle:
    if not line.startswith(&#39;From &#39;):
        continue

    # 抓取时间
    line = line.split()
    line = line[5]
    line = line.split(&#39;:&#39;)

    # 截取时间
    tim = line[0]
    if tim in status:
        status[tim] = status[tim] + 1
    else:
        status[tim] = 1

res = sorted([(k, v) for (k, v) in status.items()])
for k, v in res:
    print(k, v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面将dict转化为list的步骤利用了python的特性。&lt;/p&gt;

&lt;h2 id=&#34;regular-expressions&#34;&gt;Regular Expressions&lt;/h2&gt;

&lt;h3 id=&#34;finding-numbers-in-a-haystack&#34;&gt;Finding Numbers in a Haystack&lt;/h3&gt;

&lt;p&gt;In this assignment you will read through and parse a file with text and numbers. You will extract all the numbers in the file and compute the sum of the numbers.&lt;/p&gt;

&lt;h3 id=&#34;data-files&#34;&gt;Data Files&lt;/h3&gt;

&lt;p&gt;We provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Sample data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/regex_sum_42.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/regex_sum_42.txt&lt;/a&gt; (There are 90 values with a sum=445833)&lt;/li&gt;
&lt;li&gt;Actual data: &lt;a href=&#34;http://py4e-data.dr-chuck.net/regex_sum_275911.txt&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://py4e-data.dr-chuck.net/regex_sum_275911.txt&lt;/a&gt; (There are 92 values and the sum ends with 76)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These links open in a new window. Make sure to save the file into the same folder as you will be writing your Python program. Note: Each student will have a distinct data file for the assignment - so only use your own data file for analysis.&lt;/p&gt;

&lt;h3 id=&#34;data-format&#34;&gt;Data Format&lt;/h3&gt;

&lt;p&gt;The file contains much of the text from the introduction of the textbook except that random numbers are inserted throughout the text. Here is a sample of the output you might see:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;Why should you learn to write programs? 7746
12 1929 8827
Writing programs (or programming) is a very creative
7 and rewarding activity.  You can write programs for
many reasons, ranging from making your living to solving
8837 a difficult data analysis problem to having fun to helping 128
someone else solve a problem.  This book assumes that
everyone needs to know how to program ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sum for the sample text above is 27486. The numbers can appear anywhere in the line. There can be any number of numbers in each line (including none).&lt;/p&gt;

&lt;h3 id=&#34;handling-the-data&#34;&gt;Handling The Data&lt;/h3&gt;

&lt;p&gt;The basic outline of this problem is to read the file, look for integers using the re.findall(), looking for a regular expression of &amp;lsquo;[0-9]+&amp;rsquo; and then converting the extracted strings to integers and summing up the integers.&lt;/p&gt;

&lt;h3 id=&#34;my-code&#34;&gt;My Code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 统计文件中数字的总和
import re

filename = input(&#39;Input filename:&#39;)
if len(filename) &amp;lt; 1:
    filename = &#39;regex_sum_275911.txt&#39;

res = 0
fh = open(filename)
for line in fh:
    tmp = re.findall(&#39;[0-9]+&#39;, line)

    # 计算一行中数字的和
    for x in tmp:
        res = res + int(x)

print(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;两行代码解决问题&lt;/strong&gt;（好熟悉&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Python 2
import re
print sum( [ ****** *** * in **********(&#39;[0-9]+&#39;,**************************.read()) ] )

Python 3:
import re
print( sum( [ ****** *** * in **********(&#39;[0-9]+&#39;,**************************.read()) ] ) )
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>