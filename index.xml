<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Wanakiki`s Blog on Wanakiki`s Blog</title>
    <link>https://wanakiki.github.io/</link>
    <description>Recent content in Wanakiki`s Blog on Wanakiki`s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 20 Apr 2019 19:41:55 +0800</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>数据结构作业一 Zuma List</title>
      <link>https://wanakiki.github.io/2019/zuma-list/</link>
      <pubDate>Sat, 20 Apr 2019 19:41:55 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/zuma-list/</guid>
      <description>

&lt;p&gt;数据结构第一次作业。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;问题分析&#34;&gt;问题分析&lt;/h2&gt;

&lt;p&gt;题目要求书写程序对祖玛消除过程进行回放，输入为原始珠子序列以及玩家所做的一系列操作，要求我们按照游戏规则计算出每次操作后的珠子序列并进行输出。&lt;/p&gt;

&lt;p&gt;祖玛游戏规则：有三个或更多同色珠子变成相邻就会立即消失，并且可能会发生连锁反应。&lt;strong&gt;需要注意，原始情况中出现的三个或更多相邻同色珠子，在没有新珠子或者连锁反应影响时是不会消除的。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;解决方案&#34;&gt;解决方案&lt;/h2&gt;

&lt;p&gt;将新的珠子插入到原有序列，在插入位置向两侧判断同色珠子个数，满足条件则进行删除。考虑到删除后的连锁反应，需要将判断的过程循环执行到无法继续删除。&lt;/p&gt;

&lt;h2 id=&#34;算法设计&#34;&gt;算法设计&lt;/h2&gt;

&lt;p&gt;考虑到整个过程需要多次插入删除的操作，并且查找过程只需要从插入的具体位置向两侧进行判断，所以使用list对珠子序列进行存储。&lt;/p&gt;

&lt;p&gt;插入过程只需要简单的insert函数与advance函数相配合就可以了，使用advance函数使迭代器指到插入位置，之后再用insert函数进行插入。&lt;/p&gt;

&lt;p&gt;比较难的地方在于是否消除的判断上，考虑到迭代器的特殊性，为了避免不必要的麻烦，当list中的元素少于三个的时候直接不进行判断。对三个以上的元素判断时，需要从插入元素的位置向两侧查找相同颜色，可以用&lt;code&gt;end()&lt;/code&gt;和&lt;code&gt;begin()&lt;/code&gt;来判断是否到达了查找的两端，当然，如果在查找过程中就发现了不同的珠子就可以直接停止查找过程。查找结束之后直接对查找到的区间进行删除，同时保留左开右闭区间的右端点作为下次查找过程的起始位置。&lt;/p&gt;

&lt;p&gt;数据的输入和结果输出过程按照题目的要求进行编写即可。&lt;/p&gt;

&lt;h2 id=&#34;流程图&#34;&gt;流程图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29c8oqxjoj30rv0zpn06.jpg&#34; alt=&#34;流程图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;编程实现&#34;&gt;编程实现&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;list&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

void bang(list&amp;lt;char&amp;gt; &amp;amp; beads, int id, char bead){
    list&amp;lt;char&amp;gt;::iterator i, r, l;
    int num = 0;    /*计数*/
    i = beads.begin();
    advance(i, id);
    beads.insert(i, bead);  /*插入元素*/

    /*考虑到多次消除的可能，使用while循环进行消除*/
    while(1){
        if(beads.size() &amp;lt; 3)
            break;
        
        num = 0;
        r = i--;    
        /*这步操作之后r指向被插入元素以后，i指向被插入元素*/
        
        for(; r != beads.end(); r++){
            if(*r == *i)    num ++;
            else    break;
        }           /*向右判断*/

        l = i;          
        /*if(i != beads.begin()){
            l--;
            while (1){
                if(*l != *i){   l++;break;} //l需要加加
                else    num ++;
                
                if(l == beads.begin())  break;
                else    l--;    
            }
        }   //向左判断*/

        /*由流程图发现的简化方法*/
        while(l != beads.begin()){
            l--;
            if(*l != *i){   l++; break;}
            else    num++;
        }


        /*删除部分*/
        if(num &amp;gt; 1){
            beads.erase(l, r);
            i = r;
        }
        else
            break;
    }


    /*输出*/
    if(beads.empty())
        cout &amp;lt;&amp;lt; &#39;-&#39; &amp;lt;&amp;lt; endl;
    else{
        for(i = beads.begin(); i != beads.end(); i++)
            cout &amp;lt;&amp;lt; *i;
        cout &amp;lt;&amp;lt; endl;
    }
    return ;
}
int main(){
    int n, id;
    char bead;
    string initial_beads;
    list&amp;lt;char&amp;gt; beads;

    getline(cin, initial_beads);
    for(int i = 0; i &amp;lt; initial_beads.size(); i++){
        beads.push_back(initial_beads[i]);
    }
    /*构造初始状态*/

    cin &amp;gt;&amp;gt; n;
    while(n--){
        cin &amp;gt;&amp;gt; id &amp;gt;&amp;gt; bead;
        bang(beads, id, bead);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;结果分析&#34;&gt;结果分析&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29c8i4jcrj30gi08o750.jpg&#34; alt=&#34;测试1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ws1.sinaimg.cn/large/006bu4XTly1g29c7vdgspj30hg061dg9.jpg&#34; alt=&#34;测试2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上，经过测试，程序完成要求，并且能够处理初始序列为空的情况。👍&lt;/p&gt;

&lt;h2 id=&#34;总结体会&#34;&gt;总结体会&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;增加了对erase函数的了解：

&lt;ol&gt;
&lt;li&gt;当参数只有一个的时候，原迭代器指向的位置被删除，迭代器无效化，不能对其继续进行操作，否则会造成错误，但函数会返回原位置之后的迭代器，所以可以利用这个特性进行区间删除（省略++步骤）。&lt;/li&gt;
&lt;li&gt;当有两个参数的时候，函数结束之后前一个迭代器会无效化，而后一个迭代器因为删除区间为左闭右开的特点，其指向的位置不会被删除。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;迭代器是一个很玄学的东西，使用不规范很容易带来错误，查错的时候可以优先考虑。&lt;/li&gt;
&lt;li&gt;流程图可以帮忙理清逻辑结构！！！😀&lt;/li&gt;
&lt;li&gt;写程序尽量一次性写完&amp;hellip;&amp;hellip;🤧&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>括号匹配</title>
      <link>https://wanakiki.github.io/2019/kuohao/</link>
      <pubDate>Sat, 20 Apr 2019 14:36:43 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/2019/kuohao/</guid>
      <description>

&lt;p&gt;这个学期开始学数据结构，第一节课老师又提出了这个经典的问题。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;问题描述&#34;&gt;问题描述&lt;/h2&gt;

&lt;p&gt;给出一个只包含&amp;rsquo;(&amp;lsquo;和&amp;rsquo;)&amp;lsquo;的字符串，判断该字符串中的括号是否匹配。并将匹配的括号用&amp;rsquo;_&amp;lsquo;代替，不匹配的括号用&amp;rsquo;$&amp;lsquo;标出。
例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-no&#34;&gt;输入：
(())()))
输出：
(())()))
______$$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;简单解法&#34;&gt;简单解法&lt;/h2&gt;

&lt;p&gt;括号匹配问题是刚开始学习C语言的时候就接触的问题，当时老师引入这个问题的原因可能是为了介绍栈的概念，但是当时班上大多数人都采取了直接用数组模拟的方法。把整个字符串录入，之后遍历整个字符串，遇到右括号就向前寻找是否存在对应的左括号，进行判断。C++代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;string&amp;gt;
using namespace std;
int main(){
    string str, tmp;    
    //tmp用于保留原来的字符串，为了方便直接用string输入
    cin &amp;gt;&amp;gt; str;
    tmp = str;
    for(int i = 0; i &amp;lt; str.length(); i++){
        if(str[i] == &#39;)&#39;){
            for(int j = i - 1; j &amp;gt;= 0; j--){
                if(str[j] == &#39;(&#39;){
                    str[i] = str[j] = &#39;_&#39;;
                    break;
                }
            }
        }
    }
    for(int i = 0; i &amp;lt; str.length(); i++){
        if(str[i] != &#39;_&#39;)
            str[i] = &#39;$&#39;;   //找出不匹配的括号
    }
    cout &amp;lt;&amp;lt; tmp &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; str;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用栈来解决&#34;&gt;使用栈来解决&lt;/h2&gt;

&lt;p&gt;首先忽略掉不匹配括号的标记问题，聚焦于判断整个字符串是否存在不匹配的括号。要看字符串是否匹配，只要看左括号是否有对应的右括号，或者右括号是否有对应的左括号，问题解决方法是相同的。&lt;/p&gt;

&lt;p&gt;读入一个左括号我们就可以把它压入栈中，遇到右括号就弹出栈中的左括号。如果所有的右括号都读取完，栈中还有左括号，或者读入一个右括号栈中已经没有了括号，就意味着该字符串中的括号不匹配。C++代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include&amp;lt;iostream&amp;gt;
#include&amp;lt;stack&amp;gt;
#include&amp;lt;string&amp;gt;
using namespace std;
int main(){
    stack&amp;lt;char&amp;gt; s;
    string tmp;
    cin &amp;gt;&amp;gt; tmp;
    for(int i = 0; i &amp;lt; tmp.length(); i++){
        if(tmp[i] == &#39;(&#39;)
            s.push(tmp[i]);
        else
        {
            if(s.empty())
                cout &amp;lt;&amp;lt; &amp;quot;FALSE&amp;quot;;
            else
            {
                s.pop();
            }
            
        }
        
    }
    if(!s.empty())
        cout &amp;lt;&amp;lt; &amp;quot;FALSE&amp;quot;;
    else
    {
        cout &amp;lt;&amp;lt; &amp;quot;TRUE&amp;quot;;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码完全可以不用栈，设置一个变量来记录当前拥有的左括号的数量就可以大大简化代码。&lt;/p&gt;

&lt;p&gt;如果我们想要知道是哪几个字符不匹配，我的想法是直接将字符的索引压入栈中，因为只有一种括号，把字符压入栈中实际上是不必要之举。将上面的代码输出错误的地方改成记录错误的下标，就可以将出错字符的下标记录下来，当所有的右括号都判断完之后，栈中剩余的所有左括号下标也同样要记录下来。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://wanakiki.github.io/about/</link>
      <pubDate>Sat, 20 Apr 2019 13:54:01 +0800</pubDate>
      
      <guid>https://wanakiki.github.io/about/</guid>
      <description>&lt;p&gt;趁着运动会的假期把GitHub上面博客的生成方式从hexo换到了hugo，希望今后能够坚持下去😀，另外之前没有写多少博文，迁移过来并不会造成太多的麻烦。&lt;/p&gt;

&lt;p&gt;新方式的配置主要参考了&lt;a href=&#34;https://mogeko.me/2018/018/&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Mogeko的博客&lt;/a&gt;，在此对他表示感谢。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>